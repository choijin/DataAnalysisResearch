<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>New Computational Approaches for Markov Decision Processes</AwardTitle>
<AwardEffectiveDate>01/01/2004</AwardEffectiveDate>
<AwardExpirationDate>03/31/2008</AwardExpirationDate>
<AwardTotalIntnAmount>0.00</AwardTotalIntnAmount>
<AwardAmount>365643</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>07030000</Code>
<Directorate>
<Abbreviation>ENG</Abbreviation>
<LongName>Directorate For Engineering</LongName>
</Directorate>
<Division>
<Abbreviation>CMMI</Abbreviation>
<LongName>Div Of Civil, Mechanical, &amp; Manufact Inn</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Robert L. Smith</SignBlockName>
</ProgramOfficer>
<AbstractNarration>Developing practical computational solution methods for large-scale Markov Decision Processes (MDPs), also known as stochastic dynamic programming problems, remains an important and challenging research area.  The complexity of many modern systems that can in principle be modeled using MDPs have resulted in models for which it is not possible to explicitly enumerate the transition probabilities, but for which sample paths can be easily generated, e.g., via a stochastic simulation model.  The project research addresses two other distinct but crucial issues that arise: how best to allocate a computational budget that is used to generate sample paths, and how to produce a robust set of good policies directly (rather than indirectly via value function approximations).  In particular, the main thrusts of our proposed approaches center on two distinct paradigms: effective sampling-based methodologies using multi-armed bandit models and induced correlation for value function estimation; and population-based approaches for finding improving policies, in contrast to the traditional policy iteration method, which iterates on a single policy.  The latter thrust will focus on infinite horizon problems, where there is assumed an optimal stationary policy, whereas the former approaches are intended for finite horizon problems, where backwards induction dynamic programming must be employed.  Algorithms will be developed and then analyzed in terms of their properties such as convergence rate and theoretical bounds on performance, followed by testing on specific application areas to investigate their practical utility.  Specific problem domains include the pricing of American-style financial derivatives; capacity planning and preventive maintenance in manufacturing systems; and communication networks.  &lt;br/&gt;&lt;br/&gt;  &lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>07/08/2003</MinAmdLetterDate>
<MaxAmdLetterDate>12/06/2007</MaxAmdLetterDate>
<ARRAAmount/>
<AwardID>0323220</AwardID>
<Investigator>
<FirstName>Michael</FirstName>
<LastName>Fu</LastName>
<EmailAddress>mfu@isr.umd.edu</EmailAddress>
<StartDate>07/08/2003</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Steven</FirstName>
<LastName>Marcus</LastName>
<EmailAddress>marcus@isr.umd.edu</EmailAddress>
<StartDate>07/08/2003</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Maryland, College Park</Name>
<CityName>College Park</CityName>
<ZipCode>207425141</ZipCode>
<PhoneNumber>3014056269</PhoneNumber>
<StreetAddress>3112 LEE BLDG 7809 Regents Drive</StreetAddress>
<CountryName>United States</CountryName>
<StateName>Maryland</StateName>
<StateCode>MD</StateCode>
</Institution>
<FoaInformation>
<Code>0107000</Code>
<Name>Operations Research</Name>
</FoaInformation>
<ProgramElement>
<Code>5514</Code>
<Text>OPERATIONS RESEARCH</Text>
</ProgramElement>
<ProgramReference>
<Code>067E</Code>
<Text>DESIGN TOOLS</Text>
</ProgramReference>
<ProgramReference>
<Code>068E</Code>
<Text>DESIGN THEORY</Text>
</ProgramReference>
<ProgramReference>
<Code>9146</Code>
<Text>MANUFACTURING BASE RESEARCH</Text>
</ProgramReference>
<ProgramReference>
<Code>9147</Code>
<Text>GENERIC TECHNOL FOR MANUFACTURING CELLS</Text>
</ProgramReference>
<ProgramReference>
<Code>MANU</Code>
<Text>MANUFACTURING</Text>
</ProgramReference>
<Appropriation>
<Code>0103</Code>
</Appropriation>
<Appropriation>
<Code>0104</Code>
</Appropriation>
<Appropriation>
<Code>0105</Code>
</Appropriation>
<Appropriation>
<Code>0107</Code>
</Appropriation>
</Award>
</rootTag>
