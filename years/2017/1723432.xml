<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:Small: Build Code Maintenance and Detecting, Testing, Locating Configuration and Build Errors</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2016</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>166644.00</AwardTotalIntnAmount>
<AwardAmount>166644</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Software has become a critical infrastructure in our society with its&lt;br/&gt;pervasive use in all kinds of products from home appliances to&lt;br/&gt;automobiles, from individual pacemakers and smart phones to air&lt;br/&gt;traffic control systems and high-end computers in large-scale power&lt;br/&gt;grids. During software development, the build process is vital to make&lt;br/&gt;sure that a software product is correctly and reliably constructed and&lt;br/&gt;configured in accordance with different users' operation environments,&lt;br/&gt;operating systems, platforms, and devices. To reliably build a&lt;br/&gt;software product, a build tool is used to execute build code to&lt;br/&gt;generate the executable and deliverable files according to the rules&lt;br/&gt;specified in the build files. As a software project evolves over time,&lt;br/&gt;build code continually evolves and is defect-prone due to the high&lt;br/&gt;rate of changes and complexity of the build files. The complexity of&lt;br/&gt;build code leads to two important issues. First, the maintenance of&lt;br/&gt;complex build code has imposed much extra effort on software&lt;br/&gt;developers. Second, its complexity is a source for configuration and&lt;br/&gt;build errors in software development.&lt;br/&gt;&lt;br/&gt;This project aims to improve software reliability with a comprehensive&lt;br/&gt;approach to develop a scientific foundation for build code analysis to&lt;br/&gt;provide automatic supports for 1) build code maintenance and 2)&lt;br/&gt;detecting, testing, and locating configuration and build errors. We&lt;br/&gt;will first examine configuration and build code errors and related maintenance &lt;br/&gt;tasks in real-world projects. Second, we will develop a scientific foundation&lt;br/&gt;with novel concepts, techniques, and algorithms for build code static&lt;br/&gt;analysis, build code smell and configuration error detection,&lt;br/&gt;refactoring, and change analysis. Third, we will investigate a&lt;br/&gt;foundation for build code dynamic analysis and leverage it to support&lt;br/&gt;fault localization in build code given a reported build&lt;br/&gt;failure. Finally, a theoretical foundation and tool supports&lt;br/&gt;(e.g. semi-automatic test generation) for build code testing will be&lt;br/&gt;developed. Our research will fundamentally advance the body of&lt;br/&gt;knowledge in theoretical foundation for software building, build code&lt;br/&gt;analysis and maintenance. Our results will lead to more reliable&lt;br/&gt;software and improvement in code quality as well as in the developers'&lt;br/&gt;productivity. Our validation efforts involve students and&lt;br/&gt;professionals, promoting teaching and training in information&lt;br/&gt;assurance and software reliability.</AbstractNarration>
<MinAmdLetterDate>01/09/2017</MinAmdLetterDate>
<MaxAmdLetterDate>01/09/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1723432</AwardID>
<Investigator>
<FirstName>Tien</FirstName>
<LastName>Nguyen</LastName>
<PI_MID_INIT>N</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Tien N Nguyen</PI_FULL_NAME>
<EmailAddress>nguyen.n.tien@gmail.com</EmailAddress>
<PI_PHON>9728833893</PI_PHON>
<NSF_ID>000340493</NSF_ID>
<StartDate>01/09/2017</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Texas at Dallas</Name>
<CityName>Richardson</CityName>
<ZipCode>750803021</ZipCode>
<PhoneNumber>9728832313</PhoneNumber>
<StreetAddress>800 W. Campbell Rd., AD15</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>32</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX32</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>800188161</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF TEXAS AT DALLAS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042000273</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Texas at Dallas]]></Name>
<CityName>Richardson</CityName>
<StateCode>TX</StateCode>
<ZipCode>750803021</ZipCode>
<StreetAddress><![CDATA[800 W. Campbell Rd.]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>32</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX32</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~166644</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software becomes a critical infrastructure in our society where it is pervasive in business, education, science, technology, health care, entertainment, etc. During software development, software building in software configuration management is the process that configures the parameters for the software in accordance with users? operation environments, configurations, preferences, and integrates source code, libraries, and other required data in a project into the corresponding deliverables and executable files. The build process is vital since it needs to make sure that a system is correctly constructed and configured for the running environments. The build process is managed by a build tool, i.e., a program that coordinates and controls other programs. A build tool needs to execute the build commands to generate the deliverables according to the rules specified in build files. Build files typically are written in a build language that differs from the languages used in source code, thus, adding extra efforts for software developers.</p> <p>Prior studies have shown that in large-scale software projects, build files are very complex to accommodate multiple system configurations. Especially, as a project evolves, build code continually evolves and is defect-prone due to the high rate of changes in build files. The complexity of build code leads to two important issues. First, the maintenance of complex build code has imposed much effort for software developers. Prior research found that build code maintenance including two key tasks restructuring/refactoring build code and detecting/fixing build errors<strong> </strong>impose from 12-36% overhead on software development. Second, that complexity is a source for configuration and build errors. Configuration errors (e.g., misconfigurations) are among dominant causes for software system failures. This type of build and configuration errors has been reported to cost up to 17% of the total cost for the technical supports in today?s desktop software. Several studies have called for the development of automatic tools to detect and test build errors.</p> <p>Despite the tool supports in code refactoring, defect detection, testing, fault localization for regular code, developers have been struggled in those two tasks: maintaining build code, and detecting/testing/locating configurations and build code errors. Software engineers still have to perform those tasks manually, contributing to such high extra overhead.&nbsp;&nbsp;</p> <p>Over the course of this project, we have introduced a comprehensive approach to develop a scientific foundation for build code analysis to provide automatic supports for 1) build code maintenance and 2) configuration and build error detection, testing, and locating. We first conduced empirical studies on real-world build code error and maintenance efforts. Our results have shown that developers have been putting much effort in maintaining build systems, which become so overwhelming. We then developed a scientific foundation with novel concepts, techniques, algorithms for build code static analysis, build code smell and configuration error detection, refactoring, and change analysis. Specifically, we have developed SYMake, an infrastructure and tool for the analysis of build code in Make. Due to the dynamic nature of Make language, it is challenging to understand and maintain complex Makefiles. SYMake provides a symbolic evaluation algorithm that processes Makefiles and produces a symbolic dependency graph, which represents the build dependencies among source files. We also develop a dynamic analysis framework to support several maintenance tasks for build code. We then leverage our scientific foundation for build code analysis to develop several software maintenance tool suites including</p> <p>1) MKDiff, a method/tool to detect the semantic changes in a build code. It helps developers understand how the build code is changed (e.g., changes in build rules and dependencies), and to verify and validate the correctness of the build process with different build configurations.</p> <p>2) MkFault, a method/tool to localize errors resulting in build crashes, which helps developers quickly locate the code smells and software defects.</p> <p>3) Semex, a novel method/tool to detect semantic conflicts using variability-aware execution for collaborative software development. This helps locate conflicting changes among multiple developers.</p> <p>4) CoPro, a novel formulation of feature-interaction bugs via common program entities enabled/disabled by the features. Leveraging from that, we develop an efficient feature-interaction-aware configuration prioritization technique for a configurable system by ranking the configurations according to their total number of potential bugs.</p> <p>Our results have been generating broader impacts on both research and education in software engineering. Our research eventually leads to more reliable software and less efforts for developers in maintaining build code and software configurations. The process of detecting and preparing of build code and configurations is more effective. Our validation efforts have been involving students and professionals, promoting teaching and training of assuring software reliability.&nbsp; Our results have fostered research activities in related &#64257;elds such as configurable code analysis and configuration management. They also complement well to research on web code analysis and software reliability. Our project has contributed novel teaching modules to the Software Engineering curriculum and provided research opportunities for undergraduate/graduate, minority engineering, and women students.</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 01/06/2020<br>      Modified by: Tien&nbsp;N&nbsp;Nguyen</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Software becomes a critical infrastructure in our society where it is pervasive in business, education, science, technology, health care, entertainment, etc. During software development, software building in software configuration management is the process that configures the parameters for the software in accordance with users? operation environments, configurations, preferences, and integrates source code, libraries, and other required data in a project into the corresponding deliverables and executable files. The build process is vital since it needs to make sure that a system is correctly constructed and configured for the running environments. The build process is managed by a build tool, i.e., a program that coordinates and controls other programs. A build tool needs to execute the build commands to generate the deliverables according to the rules specified in build files. Build files typically are written in a build language that differs from the languages used in source code, thus, adding extra efforts for software developers.  Prior studies have shown that in large-scale software projects, build files are very complex to accommodate multiple system configurations. Especially, as a project evolves, build code continually evolves and is defect-prone due to the high rate of changes in build files. The complexity of build code leads to two important issues. First, the maintenance of complex build code has imposed much effort for software developers. Prior research found that build code maintenance including two key tasks restructuring/refactoring build code and detecting/fixing build errors impose from 12-36% overhead on software development. Second, that complexity is a source for configuration and build errors. Configuration errors (e.g., misconfigurations) are among dominant causes for software system failures. This type of build and configuration errors has been reported to cost up to 17% of the total cost for the technical supports in today?s desktop software. Several studies have called for the development of automatic tools to detect and test build errors.  Despite the tool supports in code refactoring, defect detection, testing, fault localization for regular code, developers have been struggled in those two tasks: maintaining build code, and detecting/testing/locating configurations and build code errors. Software engineers still have to perform those tasks manually, contributing to such high extra overhead.    Over the course of this project, we have introduced a comprehensive approach to develop a scientific foundation for build code analysis to provide automatic supports for 1) build code maintenance and 2) configuration and build error detection, testing, and locating. We first conduced empirical studies on real-world build code error and maintenance efforts. Our results have shown that developers have been putting much effort in maintaining build systems, which become so overwhelming. We then developed a scientific foundation with novel concepts, techniques, algorithms for build code static analysis, build code smell and configuration error detection, refactoring, and change analysis. Specifically, we have developed SYMake, an infrastructure and tool for the analysis of build code in Make. Due to the dynamic nature of Make language, it is challenging to understand and maintain complex Makefiles. SYMake provides a symbolic evaluation algorithm that processes Makefiles and produces a symbolic dependency graph, which represents the build dependencies among source files. We also develop a dynamic analysis framework to support several maintenance tasks for build code. We then leverage our scientific foundation for build code analysis to develop several software maintenance tool suites including  1) MKDiff, a method/tool to detect the semantic changes in a build code. It helps developers understand how the build code is changed (e.g., changes in build rules and dependencies), and to verify and validate the correctness of the build process with different build configurations.  2) MkFault, a method/tool to localize errors resulting in build crashes, which helps developers quickly locate the code smells and software defects.  3) Semex, a novel method/tool to detect semantic conflicts using variability-aware execution for collaborative software development. This helps locate conflicting changes among multiple developers.  4) CoPro, a novel formulation of feature-interaction bugs via common program entities enabled/disabled by the features. Leveraging from that, we develop an efficient feature-interaction-aware configuration prioritization technique for a configurable system by ranking the configurations according to their total number of potential bugs.  Our results have been generating broader impacts on both research and education in software engineering. Our research eventually leads to more reliable software and less efforts for developers in maintaining build code and software configurations. The process of detecting and preparing of build code and configurations is more effective. Our validation efforts have been involving students and professionals, promoting teaching and training of assuring software reliability.  Our results have fostered research activities in related &#64257;elds such as configurable code analysis and configuration management. They also complement well to research on web code analysis and software reliability. Our project has contributed novel teaching modules to the Software Engineering curriculum and provided research opportunities for undergraduate/graduate, minority engineering, and women students.                Last Modified: 01/06/2020       Submitted by: Tien N Nguyen]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
