<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:Medium:Collaborative Research:A comprehensive methodology to pursue reproducible accuracy in ensemble scientific simulations on multi- and many-core platforms</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>01/01/2017</AwardEffectiveDate>
<AwardExpirationDate>05/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>370233.00</AwardTotalIntnAmount>
<AwardAmount>370233</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Ensemble simulations of scientific phenomena typically run for weeks or even months on high-performance computing clusters. The already high level of concurrency of these computing environments is expected to significantly increase in the near future, causing simulations to suffer not only from numerical errors due to limited arithmetic precision but also from the non-determinism in the execution associated with multithreading. Ultimately this trend can compromise the simulation results and break the scientific community's trust in ensemble simulations. This project tackles this problem and defines a methodology to enable the reproducible accuracy of large ensemble simulations on exascale platforms that include multi- and many-core processors. &lt;br/&gt; This project moves along two major fronts. First, the investigators identify common sources of accuracy errors and study their accumulation, propagation, and runtime effects in a controlled environment. This phase includes three research activities: (i) generating code motifs that model those computations that may lead to accuracy errors; (ii) providing multiple implementations of these motifs, called code inspectors, targeting different parallel platforms; and (iii) evaluating the accuracy and runtime of these implementations using a variety of datasets and stress conditions. Second, by installing these code inspectors in real scientific code bases, the investigators study their behavior in uncertain environments. This phase includes two research activities: (i) prioritizing code segments based on quantitative impact scores and matching segments to inspector motifs; and (ii) finding the optimal code inspector implementations and patching the code with them so as to optimize the overall result variance. The applications targeted in this project are deterministic chaotic applications including n-body atomic system simulations and astrophysical simulations.</AbstractNarration>
<MinAmdLetterDate>02/07/2017</MinAmdLetterDate>
<MaxAmdLetterDate>02/07/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1728850</AwardID>
<Investigator>
<FirstName>Michela</FirstName>
<LastName>Becchi</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Michela Becchi</PI_FULL_NAME>
<EmailAddress>mbecchi@ncsu.edu</EmailAddress>
<PI_PHON>9195152440</PI_PHON>
<NSF_ID>000573363</NSF_ID>
<StartDate>02/07/2017</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>North Carolina State University</Name>
<CityName>Raleigh</CityName>
<ZipCode>276957514</ZipCode>
<PhoneNumber>9195152444</PhoneNumber>
<StreetAddress>2601 Wolf Village Way</StreetAddress>
<StreetAddress2><![CDATA[Admin. III, STE 240]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<StateCode>NC</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NC04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>042092122</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>NORTH CAROLINA STATE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>142363428</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[North Carolina State University]]></Name>
<CityName/>
<StateCode>NC</StateCode>
<ZipCode>276957003</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NC02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~370233</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p class="Para2">Many high-performance computing applications from various scientific domains, such as molecular dynamics, climate modeling, astrophysical simulations, and experimental mathematics, use floating-point arithmetic. Floating-point arithmetic is by definition approximate since real numbers are not guaranteed to be represented exactly by a finite number of bits. The approximate nature of floating-point numbers can lead to inaccuracy and reproducibility issues, which can be especially problematic for long-running applications. Indeed, previous work has shown that 64-bit IEEE floating-point arithmetic can be insufficient for many computations and applications, such as ill-conditioned linear systems, large summations, long-time or large-scale physical simulations, and experimental mathematics.</p> <p class="Para2">Several high-precision libraries encoding real numbers using more than 64 bits are available. While the need for high accuracy can be met through the use of these libraries, they can result in a significant cost in execution time. For example, we have observed an 80x slowdown when porting a Computational Fluid Dynamics application from double (i.e., 64-bit) to 256-bit precision (using a popular high precision library). A performance drop of this magnitude can make the execution time of large-scale scientific simulations prohibitive. One approach to mitigate this problem is to use high-precision arithmetic for only a subset of the variables and operations in a given program, thus trading off accuracy and performance. This requires determining the variables and operations that are most critical to the program?s accuracy. Previous efforts, focused on single and double precision, have proposed tuning assistants that explore the search space resulting from assigning different precisions to the floating-point variables within a given program. These methods, however, typically require many runs of the program. This can even result, on a single input, in hours of tuning for programs with execution times on the order of few seconds.</p> <p class="Para2">In this project, we have broadened the analysis to applications that require high-precision arithmetic to guarantee a sufficient level of accuracy, and we have proposed mechanisms and tools to balance accuracy and performance by providing mixed-precision versions of these applications. Because of the high cost of high-precision arithmetic, reducing the size of the search space is in this case critical. This holds particularly for applications that have long runtimes even when using double-precision arithmetic alone. In addition, having a tuning methodology that leads to results that are consistent across different inputs is equally important, since the tuning overhead is justifiable only if the application is run multiple times on different inputs. The most significant contributions of this work are the following.</p> <p class="Para2">First, to limit the tuning time and the sensitivity of the tuning results to the inputs, we have designed a tuning method that leverages compiler analysis. In particular, we have observed that frequently executed loops tend to affect not only performance, but also accuracy, especially if they implement repeated summations and multiplications and include a large number of data-dependent floating-point operations. Based on this observation, we have designed a loop-aware tuning strategy, and we have used it to analyze the effect of tuning down subsets of operations incrementally. Our tuning strategy uses the following criteria: the number of occurrences of a particular variable or operation throughout the code, the presence of the variable or operation in accumulation-like computation patterns (e.g., global summations), and the execution frequency of the block of code containing that operation. We have implemented our tuning strategy in an autotuner for CPU applications that follows a two-step approach. First, it uses compiler analysis to generate a tuning plan specific to the program but largely independent of its input data. The tuning plan consists of a sequence of iterations, each specifying a set of operations to be tuned down from higher to lower precision. Second, the tool executes the tuning plan by modifying the program and running it with a given input and a prescribed error bound.</p> <p class="Para2">Second, we have extended the proposed tuning method to GPU applications. To this end, we have performed an extensive analysis of the floating-point support offered by modern GPUs. Our analysis has targeted single-precision, double-precision and various high precision libraries, and has covered resource requirements (e.g., registers), operations? latency, throughput, and memory transfer costs. Based on this analysis, we have proposed a mixed-precision autotuner for floating-point applications running on GPU. Our tuner supports single, double and 128-bit composite precision, and can be easily extended to other arithmetic precisions. To reduce the tuning space while identifying representative tuning points, our autotuner leverages compiler analysis. In particular, our tuning strategy considers code patterns prone to error propagation and performance degradation when using high precision data types (e.g., loops, accumulation patterns, floating-point intensive code sections), and GPU-specific considerations (CPU-GPU memory transfers, kernel configurations, shared memory variables and atomic operations). We have evaluated both our CPU and GPU tools on a set of scientific applications from open-source benchmark suites.</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/27/2020<br>      Modified by: Michela&nbsp;Becchi</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Many high-performance computing applications from various scientific domains, such as molecular dynamics, climate modeling, astrophysical simulations, and experimental mathematics, use floating-point arithmetic. Floating-point arithmetic is by definition approximate since real numbers are not guaranteed to be represented exactly by a finite number of bits. The approximate nature of floating-point numbers can lead to inaccuracy and reproducibility issues, which can be especially problematic for long-running applications. Indeed, previous work has shown that 64-bit IEEE floating-point arithmetic can be insufficient for many computations and applications, such as ill-conditioned linear systems, large summations, long-time or large-scale physical simulations, and experimental mathematics. Several high-precision libraries encoding real numbers using more than 64 bits are available. While the need for high accuracy can be met through the use of these libraries, they can result in a significant cost in execution time. For example, we have observed an 80x slowdown when porting a Computational Fluid Dynamics application from double (i.e., 64-bit) to 256-bit precision (using a popular high precision library). A performance drop of this magnitude can make the execution time of large-scale scientific simulations prohibitive. One approach to mitigate this problem is to use high-precision arithmetic for only a subset of the variables and operations in a given program, thus trading off accuracy and performance. This requires determining the variables and operations that are most critical to the program?s accuracy. Previous efforts, focused on single and double precision, have proposed tuning assistants that explore the search space resulting from assigning different precisions to the floating-point variables within a given program. These methods, however, typically require many runs of the program. This can even result, on a single input, in hours of tuning for programs with execution times on the order of few seconds. In this project, we have broadened the analysis to applications that require high-precision arithmetic to guarantee a sufficient level of accuracy, and we have proposed mechanisms and tools to balance accuracy and performance by providing mixed-precision versions of these applications. Because of the high cost of high-precision arithmetic, reducing the size of the search space is in this case critical. This holds particularly for applications that have long runtimes even when using double-precision arithmetic alone. In addition, having a tuning methodology that leads to results that are consistent across different inputs is equally important, since the tuning overhead is justifiable only if the application is run multiple times on different inputs. The most significant contributions of this work are the following. First, to limit the tuning time and the sensitivity of the tuning results to the inputs, we have designed a tuning method that leverages compiler analysis. In particular, we have observed that frequently executed loops tend to affect not only performance, but also accuracy, especially if they implement repeated summations and multiplications and include a large number of data-dependent floating-point operations. Based on this observation, we have designed a loop-aware tuning strategy, and we have used it to analyze the effect of tuning down subsets of operations incrementally. Our tuning strategy uses the following criteria: the number of occurrences of a particular variable or operation throughout the code, the presence of the variable or operation in accumulation-like computation patterns (e.g., global summations), and the execution frequency of the block of code containing that operation. We have implemented our tuning strategy in an autotuner for CPU applications that follows a two-step approach. First, it uses compiler analysis to generate a tuning plan specific to the program but largely independent of its input data. The tuning plan consists of a sequence of iterations, each specifying a set of operations to be tuned down from higher to lower precision. Second, the tool executes the tuning plan by modifying the program and running it with a given input and a prescribed error bound. Second, we have extended the proposed tuning method to GPU applications. To this end, we have performed an extensive analysis of the floating-point support offered by modern GPUs. Our analysis has targeted single-precision, double-precision and various high precision libraries, and has covered resource requirements (e.g., registers), operations? latency, throughput, and memory transfer costs. Based on this analysis, we have proposed a mixed-precision autotuner for floating-point applications running on GPU. Our tuner supports single, double and 128-bit composite precision, and can be easily extended to other arithmetic precisions. To reduce the tuning space while identifying representative tuning points, our autotuner leverages compiler analysis. In particular, our tuning strategy considers code patterns prone to error propagation and performance degradation when using high precision data types (e.g., loops, accumulation patterns, floating-point intensive code sections), and GPU-specific considerations (CPU-GPU memory transfers, kernel configurations, shared memory variables and atomic operations). We have evaluated both our CPU and GPU tools on a set of scientific applications from open-source benchmark suites.          Last Modified: 09/27/2020       Submitted by: Michela Becchi]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
