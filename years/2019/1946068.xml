<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Small: Collaborative: Automated Detection and Repair of Error Handling Bugs in SSL/TLS Implementations</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>01/01/2019</AwardEffectiveDate>
<AwardExpirationDate>10/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>43077.00</AwardTotalIntnAmount>
<AwardAmount>43077</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Secure Sockets Layer (SSL)/Transport Layer Security (TLS) protocols are critical to internet security. However, the software that implements SSL/TLS protocols is especially vulnerable to security flaws and the consequences can be disastrous.  A large number of security flaws in SSL/TLS implementations (such as man-in-the-middle attacks, denial-of-service attacks, and buffer overflow attacks) result from incorrect error handling.  These errors are often hard to detect and localize using existing techniques because many of them do not display any obvious erroneous behaviors (e.g., crash, assertion failure, etc.) but they cause subtle inaccuracies that completely violate the security and privacy guarantees of SSL/TLS. This project aims to improve error handling mechanisms in SSL/TLS implementations by building novel tools that reduce developer effort in writing and maintaining correct error handling code while making SSL/TLS implementations more secure and robust. &lt;br/&gt;&lt;br/&gt;This project develops a framework for improving the robustness of error handling code in SSL/TLS  implementations. The framework has three main objectives. First, error specifications for different SSL/TLS functions are automatically inferred to learn how they communicate the failures. Next, the inferred specifications are used to build a tool for automatically detecting error handling bugs. Finally, the framework also provides new program repair tools that can automatically fix the detected bugs. Therefore, the framework provides end-to-end assistance in maintaining error-handling code in SSL/TLS implementations and thus significantly improves internet security.</AbstractNarration>
<MinAmdLetterDate>08/16/2019</MinAmdLetterDate>
<MaxAmdLetterDate>08/16/2019</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1946068</AwardID>
<Investigator>
<FirstName>Baishakhi</FirstName>
<LastName>Ray</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Baishakhi Ray</PI_FULL_NAME>
<EmailAddress>rayb@cs.columbia.edu</EmailAddress>
<PI_PHON>3037482958</PI_PHON>
<NSF_ID>000701468</NSF_ID>
<StartDate>08/16/2019</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Columbia University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100276902</ZipCode>
<PhoneNumber>2128546851</PhoneNumber>
<StreetAddress>2960 Broadway</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049179401</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049179401</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Columbia University]]></Name>
<CityName>New York</CityName>
<StateCode>NY</StateCode>
<ZipCode>100276902</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9102</Code>
<Text>WOMEN, MINORITY, DISABLED, NEC</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~43077</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span id="docs-internal-guid-d7a5742c-7fff-38c8-83e3-6c4de45d528d"> </span></p> <p><span id="docs-internal-guid-1e44743a-7fff-2d70-e7c7-65e1f200eceb"> </span></p> <p dir="ltr"><span>Correct error handling is essential for building reliable and secure systems. Unfortunately, low-level languages like C often do not support any error handling primitives and leave it up to the developers to create their own mechanisms for error propagation and handling. However, in practice, the developers often make mistakes while writing the repetitive and tedious error handling code and inadvertently introduce bugs. Such error handling bugs often have severe consequences undermining the security and reliability of the affected systems. Fixing these bugs is also tiring&mdash;they are repetitive and cumbersome to implement. As such this project was aimed at automatically detecting and fixing error handling bugs.&nbsp; There were four significant outcomes:</span></p> <p>&nbsp;</p> <p dir="ltr"><span>[1] In order to understand the true nature of error handling bugs that occur widely in practice, we conducted a comprehensive study of real error handling bugs from 6 large open-source software including OpenSSL, GnuTLS, WolfSSL, Curl, Httpd, and Linux. We created a taxonomy of these bugs to understand their underlying causes. Our results indicate that error handling bugs usually occur due to four causes: Incorrect/Missing Error Checks, Incorrect/Missing Error Propagation, Incorrect/Missing Error Outputs, and Incorrect/Missing Resource Release. While existing bug-finding tools can partially detect some of these bugs, a large proportion of them remains yet undetected. This empirical knowledge motivates the design of our error detection and repair tool.&nbsp;</span></p> <p>&nbsp;</p> <p dir="ltr"><span>[2]&nbsp; We design and implement a tool that can detect and categorize all classes of error handling bugs. Using symbolic execution, the tool first explores all the error paths&mdash;the paths along which a function can fail. If a function fails, the error needs to be handled properly along the error path. To ensure that, the tool uses a combination of static analysis techniques and verify whether the error value returned from the failing function is checked, propagated upstream, or logged. If none of these happen, the tool reports error handling bugs. The tool further ensures that a program can fail gracefully by releasing all the allocated resources. If resources are not freed along an error path, the tool reports those cases as bugs. We find that the tool can detect error handling bugs with 100% to 84% precision and around 95% recall. To provide developers more information about the underlying causes of the bugs, the tool also categorizes these bugs with 83% to 96% precision and above 90% recall. We discovered 102 new error handling bugs across different programs&mdash;at least 53 of which lead to security flaws that break the security guarantees of SSL/TLS.&nbsp;</span></p> <p>&nbsp;</p> <p dir="ltr"><span>[3] We propose an algorithm to automatically generate patches for fixing different types of error handling bugs. This algorithm modifies the Abstract Syntax Tree (AST) of the buggy code to introduce the bug-fixes. One of the key characteristics of our patch generation algorithm is that the generated patches not only fix the corresponding error handling bugs but also blend into the existing error handling code seamlessly. Therefore, such patches are more useful to the developers as demonstrated by the fact that several of our automatically generated patches are already accepted by OpenSSL developers as bug-fixes without any further modifications. Overall, the bug-fixing phase generates acceptable patches with 72% to 84% precision.</span></p> <p>&nbsp;</p> <p dir="ltr"><span>[4] Manually creating error specifications is tedious and error-prone. We further present a new technique that automatically infers error specifications of API functions based on their usage patterns in C programs. Our key insight is that error-handling code tend to have fewer branching points and program statements than the code implementing regular functionality. Our scheme leverages this property to automatically identify error handling code at API call sites and infer the corresponding error constraints. We found that our technique can infer correct API error specifications with an average precision of 77% and recall of 47%.&nbsp;</span></p> <p>&nbsp;</p> <p dir="ltr"><span>We further leverage the knowledge gained from this project to identify and fix general-purpose bugs. For such purpose, we </span><span>use Machine Learning techniques to increase scalability for the larger codebase. We also have broadened the scope of the project to include Machine Learning based software. Since such software are fundamentally different in their implementations (e.g., neural network vs. finite state machine), we incorporate a new type of code analysis technique. To this end, </span><span>the interdisciplinary nature of the team helped bring together advances and applications in three different fields: Security, Software Engineering, and Machine Learning.&nbsp;</span></p> <p>&nbsp;</p><br> <p>            Last Modified: 03/10/2020<br>      Modified by: Baishakhi&nbsp;Ray</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[      Correct error handling is essential for building reliable and secure systems. Unfortunately, low-level languages like C often do not support any error handling primitives and leave it up to the developers to create their own mechanisms for error propagation and handling. However, in practice, the developers often make mistakes while writing the repetitive and tedious error handling code and inadvertently introduce bugs. Such error handling bugs often have severe consequences undermining the security and reliability of the affected systems. Fixing these bugs is also tiring&mdash;they are repetitive and cumbersome to implement. As such this project was aimed at automatically detecting and fixing error handling bugs.  There were four significant outcomes:    [1] In order to understand the true nature of error handling bugs that occur widely in practice, we conducted a comprehensive study of real error handling bugs from 6 large open-source software including OpenSSL, GnuTLS, WolfSSL, Curl, Httpd, and Linux. We created a taxonomy of these bugs to understand their underlying causes. Our results indicate that error handling bugs usually occur due to four causes: Incorrect/Missing Error Checks, Incorrect/Missing Error Propagation, Incorrect/Missing Error Outputs, and Incorrect/Missing Resource Release. While existing bug-finding tools can partially detect some of these bugs, a large proportion of them remains yet undetected. This empirical knowledge motivates the design of our error detection and repair tool.     [2]  We design and implement a tool that can detect and categorize all classes of error handling bugs. Using symbolic execution, the tool first explores all the error paths&mdash;the paths along which a function can fail. If a function fails, the error needs to be handled properly along the error path. To ensure that, the tool uses a combination of static analysis techniques and verify whether the error value returned from the failing function is checked, propagated upstream, or logged. If none of these happen, the tool reports error handling bugs. The tool further ensures that a program can fail gracefully by releasing all the allocated resources. If resources are not freed along an error path, the tool reports those cases as bugs. We find that the tool can detect error handling bugs with 100% to 84% precision and around 95% recall. To provide developers more information about the underlying causes of the bugs, the tool also categorizes these bugs with 83% to 96% precision and above 90% recall. We discovered 102 new error handling bugs across different programs&mdash;at least 53 of which lead to security flaws that break the security guarantees of SSL/TLS.     [3] We propose an algorithm to automatically generate patches for fixing different types of error handling bugs. This algorithm modifies the Abstract Syntax Tree (AST) of the buggy code to introduce the bug-fixes. One of the key characteristics of our patch generation algorithm is that the generated patches not only fix the corresponding error handling bugs but also blend into the existing error handling code seamlessly. Therefore, such patches are more useful to the developers as demonstrated by the fact that several of our automatically generated patches are already accepted by OpenSSL developers as bug-fixes without any further modifications. Overall, the bug-fixing phase generates acceptable patches with 72% to 84% precision.    [4] Manually creating error specifications is tedious and error-prone. We further present a new technique that automatically infers error specifications of API functions based on their usage patterns in C programs. Our key insight is that error-handling code tend to have fewer branching points and program statements than the code implementing regular functionality. Our scheme leverages this property to automatically identify error handling code at API call sites and infer the corresponding error constraints. We found that our technique can infer correct API error specifications with an average precision of 77% and recall of 47%.     We further leverage the knowledge gained from this project to identify and fix general-purpose bugs. For such purpose, we use Machine Learning techniques to increase scalability for the larger codebase. We also have broadened the scope of the project to include Machine Learning based software. Since such software are fundamentally different in their implementations (e.g., neural network vs. finite state machine), we incorporate a new type of code analysis technique. To this end, the interdisciplinary nature of the team helped bring together advances and applications in three different fields: Security, Software Engineering, and Machine Learning.           Last Modified: 03/10/2020       Submitted by: Baishakhi Ray]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
