<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER: Decomposing Operating Systems for Better Control over Policy and Privacy</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2018</AwardEffectiveDate>
<AwardExpirationDate>09/30/2020</AwardExpirationDate>
<AwardTotalIntnAmount>200000.00</AwardTotalIntnAmount>
<AwardAmount>200000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Matt Mutka</SignBlockName>
<PO_EMAI>mmutka@nsf.gov</PO_EMAI>
<PO_PHON>7032927344</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Mobile personal and internet connected devices (called Internet of Things (IoT) devices), provide functionality including communication, image/audio capture, location determination, and biometric sensing.  The enhanced functionality of these devices has enabled two new classes of attacks: data breaches from malicious software applications and Operating Systems (OS) compromises, and large scale Distributed Denial of Service (DDoS) attacks.  These attacks often result from users not being able to control the actions of their devices.  Some actions might be in direct contradiction to the users' wishes. This project addresses the problem of mismatch between device functionality and user policy by introducing a new software layer that mediates access to low-level computing hardware.&lt;br/&gt;&lt;br/&gt;The project designs a new "Policy Kernel" that mediates with hardware and existing "Functionality Kernels".  To demonstrate the policy-kernel's versatility, the proposed work includes implementation of prototype applications that address privacy leaks in mobile devices, DDoS prevention in IoT devices, and maintaining device integrity even if the functionality kernel is compromised.  The policy kernel selectively intercepts all hardware access by existing kernels, and ensures that the user policy is not violated.  Applying the user policy requires the policy kernel to be able to disable access to hardware selectively, and to transform or reduce the resolution of data returned by hardware devices.&lt;br/&gt;&lt;br/&gt;The ability to apply user policy unambiguously and securely will solve, perhaps, the biggest emerging problem for personal- and IoT devices. Prototype applications will demonstrate the versatility and potential of the proposed work: enabling functionality for important scenarios that, for now, must be accepted on `"faith".  The proposed design relieves device manufacturers from having to anticipate how their product will be used, where it might be placed, who will use it, and what sensitive data it might inadvertently collect.  Such a design can provide a foundation for how secure and privacy-preserving system software for personal- and IoT devices is built.&lt;br/&gt;&lt;br/&gt;The policy kernel source code, along with application code will be publicly available.  All research results will be disseminated via conference and journal publications.  All code, data, analysis tools, and publications will be online at https://www.cs.umd.edu/projects/secpath.&lt;br/&gt;&lt;br/&gt;This award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.</AbstractNarration>
<MinAmdLetterDate>08/04/2018</MinAmdLetterDate>
<MaxAmdLetterDate>08/04/2018</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1840902</AwardID>
<Investigator>
<FirstName>Samrat</FirstName>
<LastName>Bhattacharjee</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Samrat Bhattacharjee</PI_FULL_NAME>
<EmailAddress>bobby@cs.umd.edu</EmailAddress>
<PI_PHON>3014051658</PI_PHON>
<NSF_ID>000261786</NSF_ID>
<StartDate>08/04/2018</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Maryland, College Park</Name>
<CityName>College Park</CityName>
<ZipCode>207425141</ZipCode>
<PhoneNumber>3014056269</PhoneNumber>
<StreetAddress>3112 LEE BLDG 7809 Regents Drive</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Maryland</StateName>
<StateCode>MD</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MD05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>790934285</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF MARYLAND, COLLEGE PARK</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>003256088</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Maryland, College Park]]></Name>
<CityName>College Park</CityName>
<StateCode>MD</StateCode>
<ZipCode>207425141</ZipCode>
<StreetAddress><![CDATA[3112 LEE BLDG 7809 Regents Drive]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Maryland</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MD05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<Appropriation>
<Code>0118</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2018~200000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p class="p1"><span class="s1">Personal smart devices provide users with powerful capabilities for</span></p> <p class="p1"><span class="s1">communication, productivity, health, education, and entertainment; many of</span></p> <p class="p1"><span class="s1">these applications and services operate over sensitive data related to the</span></p> <p class="p1"><span class="s1">user (e.g., recorded audio, location, finances). Naturally, this sensitive</span></p> <p class="p1"><span class="s1">data is the target of many attacks, ranging from malicious applications to</span></p> <p class="p1"><span class="s1">compromises of the platform software (OS, privileged services, etc.).</span></p> <p class="p1"><span class="s1">Unfortunately, the amount of control users have on this data is limited.</span></p> <p class="p1"><span class="s1">First, existing systems do not provide support for users to express their</span></p> <p class="p1"><span class="s1">policies either due to incomplete settings (e.g., cannot prevent app access</span></p> <p class="p1"><span class="s1">to motion sensors on Android) or limited expressivity (e.g., can</span></p> <p class="p1"><span class="s1">enable/disable location, but not adjust data resolution). Second, even when</span></p> <p class="p1"><span class="s1">there is support for a desired policy, there is little to no assurance that</span></p> <p class="p1"><span class="s1">it is being enforced; large platforms, such as in the case of smart devices,</span></p> <p class="p1"><span class="s1">have been shown to be hard to secure as a whole.</span></p> <p class="p2"><span class="s1">&nbsp;</span></p> <p class="p1"><span class="s1">We have developed a new, isolated enforcement layer (AIO) that enables</span></p> <p class="p1"><span class="s1">transparency and expressive, end-to-end control over the software that</span></p> <p class="p1"><span class="s1">collects, processes, and shares I/O data. AIO provides a framework</span></p> <p class="p1"><span class="s1">that allows users to directly specify and reason about high level data</span></p> <p class="p1"><span class="s1">disposition policies, e.g., &ldquo;my touchscreen PIN input should only be</span></p> <p class="p1"><span class="s1">available to the bank server&rdquo;. AIO ensures that these policies are</span></p> <p class="p1"><span class="s1">enforced regardless of the behavior or compromise of platform</span></p> <p class="p1"><span class="s1">software, including the OS. AIO inherently recognizes and supports</span></p> <p class="p1"><span class="s1">many mutually distrusting principals (e.g., device manufacturer,</span></p> <p class="p1"><span class="s1">user), providing a means for: 1) scoping trust to each principal, 2)</span></p> <p class="p1"><span class="s1">safely composing software from multiple principals, and 3) enabling</span></p> <p class="p1"><span class="s1">more-privileged principals enforce policies over paths constructed by</span></p> <p class="p1"><span class="s1">less-privileged principals. Policies can be used to construct and</span></p> <p class="p1"><span class="s1">compose various forms of assurance over I/O data, such as</span></p> <p class="p1"><span class="s1">confidentiality and provenance; AIO provides a way to prove these</span></p> <p class="p1"><span class="s1">assurances through (remote) attestation.</span></p> <p class="p1"><span class="s1">To give applications the ability to choose abstractions that best meet</span></p> <p class="p1"><span class="s1">their individual needs, we have further developed a new Operating</span></p> <p class="p1"><span class="s1">System deconstructoin principle called the null-Kernel.<span>&nbsp; </span>The</span></p> <p class="p1"><span class="s1">null-Kernel makes it possible to expose multiple abstractions for the</span></p> <p class="p1"><span class="s1">same underlying resource simultaneously. The difficulty in exposing</span></p> <p class="p1"><span class="s1">low and high level abstractions simultaneously is one of</span></p> <p class="p1"><span class="s1">interference. With few exceptions, all abstractions have a set of</span></p> <p class="p1"><span class="s1">invariants that must be maintained for the abstraction to offer a</span></p> <p class="p1"><span class="s1">useful contract with its callers. If multiple high level abstractions</span></p> <p class="p1"><span class="s1">are built on top of the same low level abstraction (e.g., two separate</span></p> <p class="p1"><span class="s1">file systems using the same block device) we need a mechanism to</span></p> <p class="p1"><span class="s1">prevent interference between different high level abstractions. A</span></p> <p class="p1"><span class="s1">traditional OS achieves this by specifying how abstractions may be</span></p> <p class="p1"><span class="s1">used a priori and requiring a supervisory process (i.e., the kernel)</span></p> <p class="p1"><span class="s1">to enforce usage. Unfortunately, a priori specifications cannot meet</span></p> <p class="p1"><span class="s1">the needs of all applications and must have embedded within them their</span></p> <p class="p1"><span class="s1">own design trade-offs.</span></p> <p class="p2"><span class="s1">&nbsp;</span></p> <p class="p1"><span class="s1">The null-Kernel architecture specifies that abstractions be specified</span></p> <p class="p1"><span class="s1">in terms of extensible capabilities, with which it is safe to expose</span></p> <p class="p1"><span class="s1">multiple abstractions over the same resources. Other OS architectures</span></p> <p class="p1"><span class="s1">use capabilities, but they too are defined in terms of existing</span></p> <p class="p1"><span class="s1">abstractions a priori. Instead, we suggest that capabilities be</span></p> <p class="p1"><span class="s1">defined and enforced by the abstractions they protect. New</span></p> <p class="p1"><span class="s1">abstractions that expose hitherto undefined capabilities are created</span></p> <p class="p1"><span class="s1">as needed and are built on top of the existing abstractions. The</span></p> <p class="p1"><span class="s1">null-Kernel is not defined in terms of what does and does not execute</span></p> <p class="p1"><span class="s1">in supervisor mode. The only constraint specified by the null-Kernel</span></p> <p class="p1"><span class="s1">is that capabilities are enforced and that abstractions maintain all</span></p> <p class="p1"><span class="s1">invariants between calls, and we note that this can be achieved</span></p> <p class="p1"><span class="s1">without mode switches when hardware or language features make this</span></p> <p class="p1"><span class="s1">possible.</span></p> <p class="p2"><span class="s1">&nbsp;</span></p> <p class="p2"><span class="s1">&nbsp;</span></p> <p class="p2"><span class="s1">&nbsp;</span></p> <p>&nbsp;</p><br> <p>            Last Modified: 11/12/2020<br>      Modified by: Samrat&nbsp;Bhattacharjee</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Personal smart devices provide users with powerful capabilities for communication, productivity, health, education, and entertainment; many of these applications and services operate over sensitive data related to the user (e.g., recorded audio, location, finances). Naturally, this sensitive data is the target of many attacks, ranging from malicious applications to compromises of the platform software (OS, privileged services, etc.). Unfortunately, the amount of control users have on this data is limited. First, existing systems do not provide support for users to express their policies either due to incomplete settings (e.g., cannot prevent app access to motion sensors on Android) or limited expressivity (e.g., can enable/disable location, but not adjust data resolution). Second, even when there is support for a desired policy, there is little to no assurance that it is being enforced; large platforms, such as in the case of smart devices, have been shown to be hard to secure as a whole.   We have developed a new, isolated enforcement layer (AIO) that enables transparency and expressive, end-to-end control over the software that collects, processes, and shares I/O data. AIO provides a framework that allows users to directly specify and reason about high level data disposition policies, e.g., "my touchscreen PIN input should only be available to the bank server". AIO ensures that these policies are enforced regardless of the behavior or compromise of platform software, including the OS. AIO inherently recognizes and supports many mutually distrusting principals (e.g., device manufacturer, user), providing a means for: 1) scoping trust to each principal, 2) safely composing software from multiple principals, and 3) enabling more-privileged principals enforce policies over paths constructed by less-privileged principals. Policies can be used to construct and compose various forms of assurance over I/O data, such as confidentiality and provenance; AIO provides a way to prove these assurances through (remote) attestation. To give applications the ability to choose abstractions that best meet their individual needs, we have further developed a new Operating System deconstructoin principle called the null-Kernel.  The null-Kernel makes it possible to expose multiple abstractions for the same underlying resource simultaneously. The difficulty in exposing low and high level abstractions simultaneously is one of interference. With few exceptions, all abstractions have a set of invariants that must be maintained for the abstraction to offer a useful contract with its callers. If multiple high level abstractions are built on top of the same low level abstraction (e.g., two separate file systems using the same block device) we need a mechanism to prevent interference between different high level abstractions. A traditional OS achieves this by specifying how abstractions may be used a priori and requiring a supervisory process (i.e., the kernel) to enforce usage. Unfortunately, a priori specifications cannot meet the needs of all applications and must have embedded within them their own design trade-offs.   The null-Kernel architecture specifies that abstractions be specified in terms of extensible capabilities, with which it is safe to expose multiple abstractions over the same resources. Other OS architectures use capabilities, but they too are defined in terms of existing abstractions a priori. Instead, we suggest that capabilities be defined and enforced by the abstractions they protect. New abstractions that expose hitherto undefined capabilities are created as needed and are built on top of the existing abstractions. The null-Kernel is not defined in terms of what does and does not execute in supervisor mode. The only constraint specified by the null-Kernel is that capabilities are enforced and that abstractions maintain all invariants between calls, and we note that this can be achieved without mode switches when hardware or language features make this possible.                Last Modified: 11/12/2020       Submitted by: Samrat Bhattacharjee]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
