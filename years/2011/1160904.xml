<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>Synthesis and Analysis of Heap Data Structures</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>05/01/2012</AwardEffectiveDate>
<AwardExpirationDate>04/30/2019</AwardExpirationDate>
<AwardTotalIntnAmount>848378.00</AwardTotalIntnAmount>
<AwardAmount>1012139</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Almost all software today is developed in two stages. First, a human writes a program and subsequently various automated tools process that program to produce the actual computer code that is the software application. Over time, researchers have found ways to shift more of the burden of developing software from the programmer to the automated tools, which has gradually made software development more and more productive. One area of software development that has not changed for a couple of decades is the way in which the structure of data is programmed. The organization of data is still described in relatively low-level terms as links between individual objects in memory, which is too low-level for the tools to reason successfully about. As a result, programmers must spend significant time hand-coding and tuning their data structures, and there are significant missed opportunities for improvements to program performance, correctness, and security.&lt;br/&gt;&lt;br/&gt;We propose to try a new approach to this problem, consisting of two parts: we will synthesize data structures from high-level relational specifications.  We will also use inference techniques to automatically analyze the program?s use of the relations. In a relational style of programming explicit pointers are eliminated, removing one of the biggest impediments to automatic reasoning. We believe recent advances in the analysis of control flow, destructive updates, and low-level indexing operations make it feasible to capture most other aspects of programs.&lt;br/&gt;&lt;br/&gt;If successful, programs, including concurrent programs, will be written at a higher level and be more easily retargeted to new situations because the data representations are not fixed in advance, and tools will be able to do a more reliable, efficient, and scalable job of optimizing resources and verifying properties of programs. As part of the project, we will seek to demonstrate these benefits by conducting studies of our techniques applied to realistic challenge applications.</AbstractNarration>
<MinAmdLetterDate>04/26/2012</MinAmdLetterDate>
<MaxAmdLetterDate>03/15/2018</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1160904</AwardID>
<Investigator>
<FirstName>Alexander</FirstName>
<LastName>Aiken</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Alexander Aiken</PI_FULL_NAME>
<EmailAddress>aiken@cs.stanford.edu</EmailAddress>
<PI_PHON>6507253359</PI_PHON>
<NSF_ID>000281933</NSF_ID>
<StartDate>04/26/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Stanford University</Name>
<CityName>Stanford</CityName>
<ZipCode>943052004</ZipCode>
<PhoneNumber>6507232300</PhoneNumber>
<StreetAddress>450 Jane Stanford Way</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>009214214</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>LELAND STANFORD JUNIOR UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>009214214</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Stanford University]]></Name>
<CityName>Stanford</CityName>
<StateCode>CA</StateCode>
<ZipCode>943059025</ZipCode>
<StreetAddress><![CDATA[Stanford University]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~241340</FUND_OBLG>
<FUND_OBLG>2013~607038</FUND_OBLG>
<FUND_OBLG>2015~163761</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Reasoning about how computations represent data structures, for both performance and correctness, is a significant challenge for developing reliable and performant software.&nbsp; &nbsp;In this project we explored higher-level representations of data than are currently used, in particular relations.&nbsp; We especially focused on the use of relations as the representation for all data in concurrent, parallel, and/or distributed programs, and how using relations as the core representation helped in this setting.&nbsp; Significant theoretical results included a general model for partitioning data, as well as automatic algorithms for doing that partitioning and assignment of program data to different computational units.&nbsp; We used these techniques to demonstrate directly, on practical applications, how to significantly improve the performance of common graph analytics and deep learning computations.&nbsp; The idea of using relations as a universal representation has been standard in the database community for decades, but this work led to much wider consideration of it as the basis for a universal representation in programming languages.</p> <p>We also did significant work in verification, using the fact that relations are higher level to simplify the reasoning about programs.&nbsp; In some cases we were led into related problems that needed to be solved, such as reasoning about floating point, in order to tackle practical applications that involved relations combined with some other data type.&nbsp; &nbsp;Another related problem we addressed is automatically understanding program input formats, which is needed to automate data loading into whatever data representation one is interested in; in this domain we produced an efficient and practical algorithm for automatically inferring an input format from examples.</p><br> <p>            Last Modified: 07/08/2019<br>      Modified by: Alexander&nbsp;Aiken</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Reasoning about how computations represent data structures, for both performance and correctness, is a significant challenge for developing reliable and performant software.   In this project we explored higher-level representations of data than are currently used, in particular relations.  We especially focused on the use of relations as the representation for all data in concurrent, parallel, and/or distributed programs, and how using relations as the core representation helped in this setting.  Significant theoretical results included a general model for partitioning data, as well as automatic algorithms for doing that partitioning and assignment of program data to different computational units.  We used these techniques to demonstrate directly, on practical applications, how to significantly improve the performance of common graph analytics and deep learning computations.  The idea of using relations as a universal representation has been standard in the database community for decades, but this work led to much wider consideration of it as the basis for a universal representation in programming languages.  We also did significant work in verification, using the fact that relations are higher level to simplify the reasoning about programs.  In some cases we were led into related problems that needed to be solved, such as reasoning about floating point, in order to tackle practical applications that involved relations combined with some other data type.   Another related problem we addressed is automatically understanding program input formats, which is needed to automate data loading into whatever data representation one is interested in; in this domain we produced an efficient and practical algorithm for automatically inferring an input format from examples.       Last Modified: 07/08/2019       Submitted by: Alexander Aiken]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
