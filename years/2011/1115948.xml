<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TC: Small: Server-side Verification of Client Behavior in Distributed Applications</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2011</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>472502.00</AwardTotalIntnAmount>
<AwardAmount>472502</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This research will develop techniques that enable a server to verify the behavior of a client with which it is communicating as being consistent with the sanctioned client software.  A client's behavior might deviate from the sanctioned client software due to manipulation of the client software or its data structures by an adversary with physical access to the client computer or by malware that has infected the client.  This manipulation may yield incorrect state at the client; examples might include modifications to shared state in a collaborative application that should not have been possible, or an input to an imminent server-side invocation containing content that the sanctioned client software would not have allowed.  If this state is authoritative within a larger distributed application or otherwise dangerous to the server or other clients, then this incorrect state may compromise the integrity of the application.  The techniques developed in this proposed work will detect client behaviors arising from such modifications or, more specifically, any client-to-server messages that are inconsistent with the sanctioned client software.&lt;br/&gt;&lt;br/&gt;A central challenge in validating client behavior is that this behavior is the result of client processing with inputs that are potentially unknown to the server.  These unknown inputs can include environmental inputs at the client (e.g., values sensed at the client location), user inputs (e.g., the user's keystrokes), and even which server messages were processed by the client at the point at which it sent the message being verified.  To permit verification despite this obstacle, this project will investigate the use of symbolic execution of the sanctioned client software and constraint solving to enable the server to determine whether there are any inputs that could have given rise to this client message.  If it finds that no inputs could have given rise to this message, then it detects the client behavior as being inconsistent with the sanctioned client software.  The project will produce new research results and tools to enable this analysis to be performed efficiently.  Moreover, the use of computer games as one vehicle to demonstrate this research makes this project ideal for outreach to high-school students and undergraduates, with whom computer games are immensely popular.</AbstractNarration>
<MinAmdLetterDate>08/07/2011</MinAmdLetterDate>
<MaxAmdLetterDate>08/07/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1115948</AwardID>
<Investigator>
<FirstName>Michael</FirstName>
<LastName>Reiter</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Michael Reiter</PI_FULL_NAME>
<EmailAddress>michael.reiter@duke.edu</EmailAddress>
<PI_PHON>9196606524</PI_PHON>
<NSF_ID>000161868</NSF_ID>
<StartDate>08/07/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of North Carolina at Chapel Hill</Name>
<CityName>CHAPEL HILL</CityName>
<ZipCode>275991350</ZipCode>
<PhoneNumber>9199663411</PhoneNumber>
<StreetAddress>104 AIRPORT DR STE 2200</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<StateCode>NC</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NC04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>608195277</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>142363428</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of North Carolina at Chapel Hill]]></Name>
<CityName>CHAPEL HILL</CityName>
<StateCode>NC</StateCode>
<ZipCode>275991350</ZipCode>
<StreetAddress><![CDATA[104 AIRPORT DR STE 2200]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NC04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramReference>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~472502</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Tampering with clients in client-server protocols or applications is<br />an ingredient in numerous abuses.&nbsp; These abuses can involve exploits<br />on the server directly, or manipulation of application state for which<br />the client is authoritative.&nbsp; An example of the former is the<br />high-profile "Heartbleed" vulnerability, which enabled a tampered TLS<br />client to extract contents of server memory. Examples of the latter<br />are "invalid command" game cheats that permit clients greater<br />powers/resources in the game.<br /><br />The ideal defense would be to implement formally verified servers that<br />incorporate all necessary input validation and application-specific<br />checking. However, in practice, current production servers have<br />codebases too large to retrofit into a formally verified model.&nbsp; Since<br />it is generally impossible to anticipate all such abuses, in this<br />project we explored a holistic approach to validating client behavior as<br />consistent with a sanctioned client program. In this approach, a<br />behavioral verifier monitors each client message as it is delivered to<br />the server, to determine whether the sequence of messages received<br />from the client so far is consistent with the program the client is<br />believed to be running and the messages that the server has sent to<br />the client. Performing this verification is challenging primarily<br />because inputs or nondeterministic events at the client may be unknown<br />to the verifier, and thus, the verifier must solve for whether there<br />exist inputs that could have driven the client software to send the<br />messages it did. Furthermore, some of those inputs may be protected by<br />cryptographic guarantees (private keys in asymmetric cryptography),<br />and maliciously crafted fields may themselves be hidden by encryption,<br />as is the case with Heartbleed.<br /><br />Our central contribution has been to show that legitimate client<br />behavior can in fact be verified, not against a simplified protocol<br />model but against the client program, in two types of applications<br />(game clients and cryptographic protocols). Intuitively, we limit an<br />attacker to only behaviors that could be effected by a legitimate<br />client. We believe this advance to be important: in showing that<br />messages from a client can be quickly verified as legitimate or<br />potentially malicious, we narrow the time between zero-day exploit and<br />detection to mere seconds.&nbsp; Moreover, our examination of 70 OpenSSL<br />CVEs from 2014-2016 showed that 23 out of 37 TLS/DTLS server-side<br />vulnerabilities required tampering with feasible client behavior as an<br />ingredient in exploitation. Our technique accomplishes verification<br />with no vulnerability-specific configuration and, indeed, could have<br />discovered all of these client exploit attempts even prior to the<br />vulnerabilities&rsquo; disclosure.<br /><br />Our verifier compares client messages against a specific client<br />implementation, and so it is most appropriate in scenarios where an<br />expected client implementation is known. For example, while a plethora<br />of TLS implementations exist on the open internet, only a few TLS<br />clients are likely to be part of a corporate deployment where<br />installed software is tightly controlled.&nbsp; Similarly, a game typically<br />has relatively few sanctioned game clients.&nbsp; Knowledge of the<br />implementation might also arise by the client revealing its<br />identification string explicitly (e.g., as in SSH) or by particulars<br />of its handshake (e.g., as in TLS). That said, we also made progress<br />on generalizing our verifier to apply across multiple minor revisions.</p><br> <p>            Last Modified: 12/16/2016<br>      Modified by: Michael&nbsp;Reiter</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Tampering with clients in client-server protocols or applications is an ingredient in numerous abuses.  These abuses can involve exploits on the server directly, or manipulation of application state for which the client is authoritative.  An example of the former is the high-profile "Heartbleed" vulnerability, which enabled a tampered TLS client to extract contents of server memory. Examples of the latter are "invalid command" game cheats that permit clients greater powers/resources in the game.  The ideal defense would be to implement formally verified servers that incorporate all necessary input validation and application-specific checking. However, in practice, current production servers have codebases too large to retrofit into a formally verified model.  Since it is generally impossible to anticipate all such abuses, in this project we explored a holistic approach to validating client behavior as consistent with a sanctioned client program. In this approach, a behavioral verifier monitors each client message as it is delivered to the server, to determine whether the sequence of messages received from the client so far is consistent with the program the client is believed to be running and the messages that the server has sent to the client. Performing this verification is challenging primarily because inputs or nondeterministic events at the client may be unknown to the verifier, and thus, the verifier must solve for whether there exist inputs that could have driven the client software to send the messages it did. Furthermore, some of those inputs may be protected by cryptographic guarantees (private keys in asymmetric cryptography), and maliciously crafted fields may themselves be hidden by encryption, as is the case with Heartbleed.  Our central contribution has been to show that legitimate client behavior can in fact be verified, not against a simplified protocol model but against the client program, in two types of applications (game clients and cryptographic protocols). Intuitively, we limit an attacker to only behaviors that could be effected by a legitimate client. We believe this advance to be important: in showing that messages from a client can be quickly verified as legitimate or potentially malicious, we narrow the time between zero-day exploit and detection to mere seconds.  Moreover, our examination of 70 OpenSSL CVEs from 2014-2016 showed that 23 out of 37 TLS/DTLS server-side vulnerabilities required tampering with feasible client behavior as an ingredient in exploitation. Our technique accomplishes verification with no vulnerability-specific configuration and, indeed, could have discovered all of these client exploit attempts even prior to the vulnerabilities? disclosure.  Our verifier compares client messages against a specific client implementation, and so it is most appropriate in scenarios where an expected client implementation is known. For example, while a plethora of TLS implementations exist on the open internet, only a few TLS clients are likely to be part of a corporate deployment where installed software is tightly controlled.  Similarly, a game typically has relatively few sanctioned game clients.  Knowledge of the implementation might also arise by the client revealing its identification string explicitly (e.g., as in SSH) or by particulars of its handshake (e.g., as in TLS). That said, we also made progress on generalizing our verifier to apply across multiple minor revisions.       Last Modified: 12/16/2016       Submitted by: Michael Reiter]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
