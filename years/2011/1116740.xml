<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Empirical Studies, Principles and Techniques for Software Systems with Complex Configuration Spaces</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/15/2011</AwardEffectiveDate>
<AwardExpirationDate>06/30/2016</AwardExpirationDate>
<AwardTotalIntnAmount>500000.00</AwardTotalIntnAmount>
<AwardAmount>500000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Today's software systems are increasingly built from flexible combinations of components that can be configured in a multitude of different ways.  For example, the popular Firefox web browser has more than a thousand configuration options.  While a high degree of configurability has many benefits, it also makes testing and reasoning about configurable software a major challenge.  The goals of this proposed work are 1) to develop new techniques to efficiently discover the structure of software systems' configuration spaces, and 2) to exploit that information to improve common software engineering tasks, specifically testing and program understanding.  In particular, this work will allow software developers to quickly and accurately answer questions such as, What are the "right" configurations to test a system under?  How can we avoid testing a system under "unnecessary" configurations?  How does software configuration change as systems evolve? We expect that, as much of the software used today is configurable, the advances made in this project in understanding and testing configurable systems will have widespread benefits in the reliability and trustworthiness of critical software.&lt;br/&gt;&lt;br/&gt;The proposed technical approach will pursue four main directions. First, the PIs will develop a representation of "effective" configuration spaces---the configurations needed to achieve a specific goal---that is both usable by software engineering tools and understandable to developers.  Second, the PIs will develop novel techniques that compute the effective configuration space of a system. Third, the PIs will explore a number of software engineering applications that will make use of effective configuration space information, including configuration-aware test case selection, configuration-aware regression testing, and several program understanding tasks for configurable systems.  Finally, the PIs will conduct a wide range of fundamental empirical studies that will test the research hypotheses and evaluate the proposed approach on large scale subject systems. Among others outcomes, these studies will examine the effective configurations of a range of systems; investigate how those configurations evolve over time; and determine how failures relate to system configurations. The results will impact both practice and education.</AbstractNarration>
<MinAmdLetterDate>07/13/2011</MinAmdLetterDate>
<MaxAmdLetterDate>07/24/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1116740</AwardID>
<Investigator>
<FirstName>Adam</FirstName>
<LastName>Porter</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Adam A Porter</PI_FULL_NAME>
<EmailAddress>aporter@cs.umd.edu</EmailAddress>
<PI_PHON>3014052702</PI_PHON>
<NSF_ID>000437686</NSF_ID>
<StartDate>07/13/2011</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Jeffrey</FirstName>
<LastName>Foster</LastName>
<PI_MID_INIT>S</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Jeffrey S Foster</PI_FULL_NAME>
<EmailAddress>jfoster@cs.tufts.edu</EmailAddress>
<PI_PHON>6176272225</PI_PHON>
<NSF_ID>000095036</NSF_ID>
<StartDate>07/13/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Maryland, College Park</Name>
<CityName>College Park</CityName>
<ZipCode>207425141</ZipCode>
<PhoneNumber>3014056269</PhoneNumber>
<StreetAddress>3112 LEE BLDG 7809 Regents Drive</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Maryland</StateName>
<StateCode>MD</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MD05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>790934285</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF MARYLAND, COLLEGE PARK</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>003256088</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Maryland, College Park]]></Name>
<CityName>College Park</CityName>
<StateCode>MD</StateCode>
<ZipCode>207425141</ZipCode>
<StreetAddress><![CDATA[3112 LEE BLDG 7809 Regents Drive]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Maryland</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MD05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~500000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Today&rsquo;s software systems are increasingly built from flexible combinations of components that can be configured in a multitude of different ways. While a high degree of configurability has many benefits, it also adds combinatorial complexity to the already difficult testing problem, as in theory, each test case may need to be run under all of the tremendous number of possible system configurations. In practice this is intractable, and thus a central problem in configurable software development is choosing the right set of configurations under which to test and analyze a system.</p> <p><br />The goal of our research was to develop new techniques for empirically understanding the configuration space structure of today&rsquo;s software systems, and to find ways to exploit that structure to improve software engineering for configurable systems. Solutions to this problem will lower the cost andimprove the quality of creating configurable software systems.</p> <p><br />The main hypotheses of this project were that (1) for many practical tasks, systems, and test suites, a software system&rsquo;s effective configuration space---the configurations needed to achieve a specific goal---is a tiny subset of its full configuration space; and (2) if we can efficiently identify or approximate a system&rsquo;s effective configuration space, then we can use that information to greatly improve the cost-effectiveness of testing and analyzing configurable systems.</p> <p><br />Our work strongly suggests that both hypotheses are true. First, we obtained substantial empirical evidence that for many practical tasks, systems, and test suites, a software system&rsquo;s effective configuration space is a tiny subset of its full configuration space.&nbsp;</p> <p><br />We also developed and evaluated two new techniques to approximate a system&rsquo;s effective configuration space.</p> <p>The first technique, iTree, uses a novel combination of low-strength combinatorial interaction testing, runtime instrumentation, and machine learning to explore a program's effective configuration space. Our empirical results show that iTree is more likely to discover high-coverage configuration sets, and do so more rapidly, than existing techniques such as combinatorial interaction testing or random configuration testing. Our results also show that that iTree is scalable to large systems.</p> <p>The second technique, iGen, is a new, dynamic analysis-based approach to discovering "interactions," which are formulae over configuration options that control whether certain code coverage is achievable. Thus, by knowing a system's interactions, a developer can determine useful information about configurations, e.g., given a location, determine what configurations cover it; given an interaction, determine what locations it covers; find important options and compute a minimal set of configurations to achieve certain coverage; etc.<br />iGen discovers interactions by iteratively running a subject program under a test suite and set of configurations; inferring potential interactions from the resulting coverage information; and then generating new configurations that aim to refine the inferred interactions on the next iteration. By carefully choosing new configurations in this last step, iGen is able to quickly converge to a final, precise set of interactions using only a small set of configurations.</p><br> <p>            Last Modified: 09/27/2016<br>      Modified by: Adam&nbsp;A&nbsp;Porter</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Today?s software systems are increasingly built from flexible combinations of components that can be configured in a multitude of different ways. While a high degree of configurability has many benefits, it also adds combinatorial complexity to the already difficult testing problem, as in theory, each test case may need to be run under all of the tremendous number of possible system configurations. In practice this is intractable, and thus a central problem in configurable software development is choosing the right set of configurations under which to test and analyze a system.   The goal of our research was to develop new techniques for empirically understanding the configuration space structure of today?s software systems, and to find ways to exploit that structure to improve software engineering for configurable systems. Solutions to this problem will lower the cost andimprove the quality of creating configurable software systems.   The main hypotheses of this project were that (1) for many practical tasks, systems, and test suites, a software system?s effective configuration space---the configurations needed to achieve a specific goal---is a tiny subset of its full configuration space; and (2) if we can efficiently identify or approximate a system?s effective configuration space, then we can use that information to greatly improve the cost-effectiveness of testing and analyzing configurable systems.   Our work strongly suggests that both hypotheses are true. First, we obtained substantial empirical evidence that for many practical tasks, systems, and test suites, a software system?s effective configuration space is a tiny subset of its full configuration space.    We also developed and evaluated two new techniques to approximate a system?s effective configuration space.  The first technique, iTree, uses a novel combination of low-strength combinatorial interaction testing, runtime instrumentation, and machine learning to explore a program's effective configuration space. Our empirical results show that iTree is more likely to discover high-coverage configuration sets, and do so more rapidly, than existing techniques such as combinatorial interaction testing or random configuration testing. Our results also show that that iTree is scalable to large systems.  The second technique, iGen, is a new, dynamic analysis-based approach to discovering "interactions," which are formulae over configuration options that control whether certain code coverage is achievable. Thus, by knowing a system's interactions, a developer can determine useful information about configurations, e.g., given a location, determine what configurations cover it; given an interaction, determine what locations it covers; find important options and compute a minimal set of configurations to achieve certain coverage; etc. iGen discovers interactions by iteratively running a subject program under a test suite and set of configurations; inferring potential interactions from the resulting coverage information; and then generating new configurations that aim to refine the inferred interactions on the next iteration. By carefully choosing new configurations in this last step, iGen is able to quickly converge to a final, precise set of interactions using only a small set of configurations.       Last Modified: 09/27/2016       Submitted by: Adam A Porter]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
