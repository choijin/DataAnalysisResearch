<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>Computing without a Leader: Building Blocks for Internet-Scale, Robust Computing</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2011</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>365710.00</AwardTotalIntnAmount>
<AwardAmount>381499</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Rahul Shah</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>How do ant colonies, bee hives, and markets function even when there is no leader?   A starting point for answering this question is the fundamental problem of agreement in distributed computing: Byzantine agreement.  The Byzantine agreement problem is to devise a protocol so that a group of agents, each with a private input can agree on a single common output that is equal to some agent's input.  The problem is complicated by the fact that an unknown subset of the agents suffer Byzantine faults: they can engage in arbitrary deviations from the protocol, including false messages and collusion.  Byzantine agreement has found applications in many areas, including peer-to-peer systems, database systems, control systems, grid computing, cloud computing and game theory.  Unfortunately, continued application is hampered by a stark barrier: there is no practical, scalable algorithm for Byzantine agreement.  In particular, all current Byzantine agreement algorithms require all-to-all communication: each agent must talk with every other agent.&lt;br/&gt;&lt;br/&gt;This research will directly address this barrier by designing scalable algorithms for Byzantine agreement and other related problems.  Our goal is to design algorithms that are scalable in the sense that each agent sends a number of bits that is O(sqrt(n) log n), and total latency is O(log n), where n is the number of processors; and robust in the sense that they can tolerate up to a constant fraction of Byzantine faults.  In addition to Byzantine agreement, we will design scalable and robust algorithms for the following three related problems.  First, Subcommittee Election: All processors agree on one or more subcommittees of size O(log n), where the fraction of bad processors in each subcommittee is within epsilon of the fraction of bad processors in the network, for any positive epsilon.  Second, MapReduce: Enable the MapReduce software framework, even when there is no master.  Finally, Robust Multiparty Computation: Each processor starts with a private input and there is a publicly known function F on n variables; the goal is for all users to learn the output of F at the point given by the private inputs.  The long-term vision is to develop a technique, based on Byzantine agreement, that is on par with techniques like cryptography and error-correcting codes by 1) being frequently used in practice and applicable across a wide range of applications; and 2) having a clean interface between theory and practice.</AbstractNarration>
<MinAmdLetterDate>08/11/2011</MinAmdLetterDate>
<MaxAmdLetterDate>03/09/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1117985</AwardID>
<Investigator>
<FirstName>Jared</FirstName>
<LastName>Saia</LastName>
<PI_MID_INIT>C</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Jared C Saia</PI_FULL_NAME>
<EmailAddress>saia@cs.unm.edu</EmailAddress>
<PI_PHON>5052772256</PI_PHON>
<NSF_ID>000260597</NSF_ID>
<StartDate>08/11/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of New Mexico</Name>
<CityName>Albuquerque</CityName>
<ZipCode>871310001</ZipCode>
<PhoneNumber>5052774186</PhoneNumber>
<StreetAddress>1700 Lomas Blvd. NE, Suite 2200</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New Mexico</StateName>
<StateCode>NM</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NM01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>868853094</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF NEW MEXICO, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>784121725</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of New Mexico]]></Name>
<CityName>Albuquerque</CityName>
<StateCode>NM</StateCode>
<ZipCode>871310001</ZipCode>
<StreetAddress><![CDATA[1700 Lomas Blvd. NE, Suite 2200]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Mexico</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NM01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7796</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramReference>
<Code>7329</Code>
<Text>COMPILERS</Text>
</ProgramReference>
<ProgramReference>
<Code>7927</Code>
<Text>COMPLEXITY &amp; CRYPTOGRAPHY</Text>
</ProgramReference>
<ProgramReference>
<Code>7934</Code>
<Text>PARAL/DISTRIBUTED ALGORITHMS</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~365710</FUND_OBLG>
<FUND_OBLG>2012~15789</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This grant has had several significant outcomes.</p> <p>First, we designed efficient algorithms for the multiparty computation problem (MPC). &nbsp;In the MPC problem, n parties each have a private input. &nbsp;They want to jointly compute a function f of n variables over their inputs, without revealing any information about the private inputs (beyond what can be learned from the output of f). &nbsp;An algorithm for MPC enables decentralized simulation of a mediator, since the function f can be the advice offered by the mediator, based on private information obtained from all the players.</p> <p>Our main result was an algorithm that solves the MPC problem while requiring each player to send and receive a number of bits that is about square root of n, and requires latency that is polylogarithmic in n. &nbsp;This contrasts with previous results for this problem where the number of messages sent is linear in n. &nbsp;We obtained this result by making significant use of a new tool: quorums, which are small groups of mostly good processors that work together as a single functional unit. &nbsp;Our paper describing this result won a best paper award at the International Conference on Distributed Computing and Networking (ICDCN), 2014. &nbsp; Our result in this area used mathematical and algorithmic tools that we previously developed in solving the Byzantine agreement problem.&nbsp;</p> <p>A final result is in Interactive Computation, which asks: how can two parties compute over a noisy channel? We describe the first algorithm that enables two party interactive computation, where the resource costs of both parties scale well with the number of bits that are (adversarially) corrupted on the channel. This work has results in a conference and journal publication. &nbsp;In recent work, we are extending the result to multiple parties.</p> <p>Invited talks and presentations on this research include an invited keynote talk at the International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM), 2014, and invited talks at Osaka University, Yale, and the Workshop on Localized Algorithms (WOLA) at Microsoft Research.</p> <p>Finally, this grant has supported several PhD students. &nbsp;Two of these students have graduated, and are now post docs at Yale. Mahnush Movahedi is a female student who is working with Mariana Raykova at Yale, and Mahdi Zamani is her husband who is working with Joan Feigenbaum at Yale. &nbsp;Two other PhD students are both on track to complete their first papers this year: Diksha Gupta and Abhinav Aggarwal.</p><br> <p>            Last Modified: 10/10/2016<br>      Modified by: Jared&nbsp;C&nbsp;Saia</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This grant has had several significant outcomes.  First, we designed efficient algorithms for the multiparty computation problem (MPC).  In the MPC problem, n parties each have a private input.  They want to jointly compute a function f of n variables over their inputs, without revealing any information about the private inputs (beyond what can be learned from the output of f).  An algorithm for MPC enables decentralized simulation of a mediator, since the function f can be the advice offered by the mediator, based on private information obtained from all the players.  Our main result was an algorithm that solves the MPC problem while requiring each player to send and receive a number of bits that is about square root of n, and requires latency that is polylogarithmic in n.  This contrasts with previous results for this problem where the number of messages sent is linear in n.  We obtained this result by making significant use of a new tool: quorums, which are small groups of mostly good processors that work together as a single functional unit.  Our paper describing this result won a best paper award at the International Conference on Distributed Computing and Networking (ICDCN), 2014.   Our result in this area used mathematical and algorithmic tools that we previously developed in solving the Byzantine agreement problem.   A final result is in Interactive Computation, which asks: how can two parties compute over a noisy channel? We describe the first algorithm that enables two party interactive computation, where the resource costs of both parties scale well with the number of bits that are (adversarially) corrupted on the channel. This work has results in a conference and journal publication.  In recent work, we are extending the result to multiple parties.  Invited talks and presentations on this research include an invited keynote talk at the International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM), 2014, and invited talks at Osaka University, Yale, and the Workshop on Localized Algorithms (WOLA) at Microsoft Research.  Finally, this grant has supported several PhD students.  Two of these students have graduated, and are now post docs at Yale. Mahnush Movahedi is a female student who is working with Mariana Raykova at Yale, and Mahdi Zamani is her husband who is working with Joan Feigenbaum at Yale.  Two other PhD students are both on track to complete their first papers this year: Diksha Gupta and Abhinav Aggarwal.       Last Modified: 10/10/2016       Submitted by: Jared C Saia]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
