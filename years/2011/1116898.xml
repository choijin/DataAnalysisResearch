<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Adapting Dataflow Analysis for Efficient and Precise Parallel Program Monitoring</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2011</AwardEffectiveDate>
<AwardExpirationDate>07/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>478599.00</AwardTotalIntnAmount>
<AwardAmount>491399</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Due to the industry-wide shift to multi-core processing, future&lt;br/&gt;applications will only run faster if they are written as parallel&lt;br/&gt;software (i.e. where the work for a single program is accomplished by&lt;br/&gt;simultaneously performing different parts of that work on different&lt;br/&gt;processors).  Unfortunately history has taught us that writing&lt;br/&gt;parallel software is a very error-prone task for programmers.  To&lt;br/&gt;address this challenge, this research project is creating a powerful&lt;br/&gt;new mechanism for identifying and hopefully fixing bugs in parallel&lt;br/&gt;software on large-scale production systems.  Hopefully the resulting&lt;br/&gt;framework will not only support the parallel execution of existing&lt;br/&gt;monitoring tools, but it will also spawn the creation of new classes&lt;br/&gt;of powerful tools that can recognize subtle bugs in parallel software.&lt;br/&gt;Such tools can help programmers continue to reap the performance&lt;br/&gt;benefits of future microprocessors, thereby continuing to enable all&lt;br/&gt;of the benefits that increasingly-faster computation has had on the&lt;br/&gt;economy, science and technology, and our everyday lives in an&lt;br/&gt;Internet-connected world.&lt;br/&gt;&lt;br/&gt;More specifically, the focus of this project is on sophisticated&lt;br/&gt;online program monitoring tools that model various aspects of program&lt;br/&gt;correctness at an instruction-by-instruction granularity.  To strike a&lt;br/&gt;practical balance between performance, precision, and convenience for&lt;br/&gt;the tool developer, this research has developed a novel framework that&lt;br/&gt;introduces explicit "windows of uncertainty" combined with a new&lt;br/&gt;approach for avoiding a state space explosion in the analysis&lt;br/&gt;(inspired by Tarjan's interval analysis approach to dataflow analysis).</AbstractNarration>
<MinAmdLetterDate>07/29/2011</MinAmdLetterDate>
<MaxAmdLetterDate>04/11/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1116898</AwardID>
<Investigator>
<FirstName>Todd</FirstName>
<LastName>Mowry</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Todd Mowry</PI_FULL_NAME>
<EmailAddress>tcm@cs.cmu.edu</EmailAddress>
<PI_PHON>4122683725</PI_PHON>
<NSF_ID>000216388</NSF_ID>
<StartDate>07/29/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Carnegie-Mellon University</Name>
<CityName>PITTSBURGH</CityName>
<ZipCode>152133815</ZipCode>
<PhoneNumber>4122688746</PhoneNumber>
<StreetAddress>5000 Forbes Avenue</StreetAddress>
<StreetAddress2><![CDATA[WQED Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052184116</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CARNEGIE MELLON UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052184116</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Carnegie-Mellon University]]></Name>
<CityName>PITTSBURGH</CityName>
<StateCode>PA</StateCode>
<ZipCode>152133815</ZipCode>
<StreetAddress><![CDATA[5000 Forbes Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~478599</FUND_OBLG>
<FUND_OBLG>2014~12800</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><!-- p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Helvetica} --> <p class="p1">In the old days, you could run your software faster by simply waiting until a new computer came out with a faster clock rate. &nbsp;Today, that is no longer possible: clock rates are not improving, but instead computers are supporting increasing amounts of parallelism (i.e. the computers contain multiple processors or "cores"). &nbsp;Unfortunately, writing software to take advantage of parallelism is a notoriously difficult task: history has taught us that as difficult as it is to avoid software bugs under normal circumstances, bugs are even more problematic in parallel software.</p> <p>In this project, we have developed a new approach for creating tools that look for bugs in parallel software as that software executes. &nbsp;A major challenge in creating such tools is understanding how a software thread running on one processor is interacting with the software threads running (at the same time) on other processors, since these interactions (through accesses to shared memory) are not directly visible to software.&nbsp; A key innovation in our approach is that we model an explicit &ldquo;window of uncertainty&rdquo; (combined with new analysis techniques) that enables our bug-finding tools run in parallel, which is critical in order for them to be able to keep up with the programs that they are monitoring.&nbsp; One side effect of modeling a window of uncertainty, however, is that bug-finding tools may sometimes produce false positives, where they report a bug that does not actually exist.&nbsp; Hence a major focus of our project has been on improving the precision of our analysis framework without sacrificing the performance of the bug-finding tools.</p> <p>Our first major outcome focused on extending our original framework to model the effects of explicit synchronization operations between software threads in the monitored parallel programs.&nbsp; Including the effects of these synchronization operations presented major challenges, both in terms of proving the correctness of our enhanced model and also maintaining its performance. Fortunately, we were able to prove the correctness of our enhanced model, and it reduced the number of false positives in a bug-finding tool (that looked for potential security vulnerabilities) by roughly a factor of 18.&nbsp; This improved precision did come at a performance cost, however, as it slowed down our tool by roughly a factor of two.&nbsp;</p> <p>Our second major outcome focused on achieving a balance between precision and run-time overhead by explicitly modeling &ldquo;uncertain&rdquo; states (i.e. cases where both safe and unsafe possibilities were observed within the window of uncertainty).&nbsp; These &ldquo;uncertain&rdquo; states enabled us to distinguish &ldquo;false positives&rdquo; from &ldquo;true positives&rdquo; in our analysis, thereby improving our precision.&nbsp; In addition, it enabled a dynamically adaptive mode of execution where our bug-finding tools can adjust the size of the window of uncertainty on-the-fly in order to trade off precision for performance in an intelligent way, based upon whether &ldquo;uncertain&rdquo; cases are actually observed dynamically.&nbsp; This dynamic approach enabled us to achieve a &ldquo;best of both worlds&rdquo; result with high precision and low run-time overhead.</p> <p class="p1">&nbsp;</p><br> <p>            Last Modified: 11/01/2016<br>      Modified by: Todd&nbsp;Mowry</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ In the old days, you could run your software faster by simply waiting until a new computer came out with a faster clock rate.  Today, that is no longer possible: clock rates are not improving, but instead computers are supporting increasing amounts of parallelism (i.e. the computers contain multiple processors or "cores").  Unfortunately, writing software to take advantage of parallelism is a notoriously difficult task: history has taught us that as difficult as it is to avoid software bugs under normal circumstances, bugs are even more problematic in parallel software.  In this project, we have developed a new approach for creating tools that look for bugs in parallel software as that software executes.  A major challenge in creating such tools is understanding how a software thread running on one processor is interacting with the software threads running (at the same time) on other processors, since these interactions (through accesses to shared memory) are not directly visible to software.  A key innovation in our approach is that we model an explicit "window of uncertainty" (combined with new analysis techniques) that enables our bug-finding tools run in parallel, which is critical in order for them to be able to keep up with the programs that they are monitoring.  One side effect of modeling a window of uncertainty, however, is that bug-finding tools may sometimes produce false positives, where they report a bug that does not actually exist.  Hence a major focus of our project has been on improving the precision of our analysis framework without sacrificing the performance of the bug-finding tools.  Our first major outcome focused on extending our original framework to model the effects of explicit synchronization operations between software threads in the monitored parallel programs.  Including the effects of these synchronization operations presented major challenges, both in terms of proving the correctness of our enhanced model and also maintaining its performance. Fortunately, we were able to prove the correctness of our enhanced model, and it reduced the number of false positives in a bug-finding tool (that looked for potential security vulnerabilities) by roughly a factor of 18.  This improved precision did come at a performance cost, however, as it slowed down our tool by roughly a factor of two.   Our second major outcome focused on achieving a balance between precision and run-time overhead by explicitly modeling "uncertain" states (i.e. cases where both safe and unsafe possibilities were observed within the window of uncertainty).  These "uncertain" states enabled us to distinguish "false positives" from "true positives" in our analysis, thereby improving our precision.  In addition, it enabled a dynamically adaptive mode of execution where our bug-finding tools can adjust the size of the window of uncertainty on-the-fly in order to trade off precision for performance in an intelligent way, based upon whether "uncertain" cases are actually observed dynamically.  This dynamic approach enabled us to achieve a "best of both worlds" result with high precision and low run-time overhead.         Last Modified: 11/01/2016       Submitted by: Todd Mowry]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
