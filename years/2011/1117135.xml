<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Small: Fluid Communication for Parallel Programs</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2011</AwardEffectiveDate>
<AwardExpirationDate>07/31/2013</AwardExpirationDate>
<AwardTotalIntnAmount>199967.00</AwardTotalIntnAmount>
<AwardAmount>214967</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Every aspect of parallel software development is more complicated than for&lt;br/&gt;serial programs.  This research focuses on one of the primary sources of&lt;br/&gt;complexity: intra-application communication.  Currently it is a programmer's&lt;br/&gt;responsibility to find an efficient mapping of their application's&lt;br/&gt;communication patterns onto the communication infrastructure of the target&lt;br/&gt;system.  This research flips that responsibility by developing a flexible&lt;br/&gt;communication architecture and associated tools and algorithms that allow the&lt;br/&gt;target platform to be specialized for a particular application, rather than&lt;br/&gt;vice versa.  In addition to reducing the programmer's burden, specialization&lt;br/&gt;has the potential to improve communication efficiency while the automated&lt;br/&gt;techniques can increase portability.  &lt;br/&gt;&lt;br/&gt;This research poses questions whose answers have consequences at several&lt;br/&gt;levels of the traditional system stack: Can programmers be freed from&lt;br/&gt;hardware-specific optimization of communication without degrading performance?&lt;br/&gt;What abstractions are needed to allow hardware to adapt to the programmer,&lt;br/&gt;rather than the other way around?  Can communication efficiency be improved&lt;br/&gt;when running on an application-specific communication platform?  The project&lt;br/&gt;answers these questions by exploring abstractions and algorithms to profile a&lt;br/&gt;parallel program's communication, synthesize a custom network design, and&lt;br/&gt;implement it in a configurable network architecture substrate.  The research&lt;br/&gt;methods center around the X10 language, and include compiler instrumentation&lt;br/&gt;passes, offline communication profile analyses, development of a portable&lt;br/&gt;network intermediate representation, and network place and route software&lt;br/&gt;algorithms.</AbstractNarration>
<MinAmdLetterDate>07/22/2011</MinAmdLetterDate>
<MaxAmdLetterDate>04/18/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1117135</AwardID>
<Investigator>
<FirstName>Martha</FirstName>
<LastName>Kim</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Martha A Kim</PI_FULL_NAME>
<EmailAddress>martha@cs.columbia.edu</EmailAddress>
<PI_PHON>2129397094</PI_PHON>
<NSF_ID>000528915</NSF_ID>
<StartDate>07/22/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Columbia University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100276902</ZipCode>
<PhoneNumber>2128546851</PhoneNumber>
<StreetAddress>2960 Broadway</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049179401</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049179401</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Columbia University]]></Name>
<CityName>NEW YORK</CityName>
<StateCode>NY</StateCode>
<ZipCode>100276902</ZipCode>
<StreetAddress><![CDATA[2960 Broadway]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1714</Code>
<Text>Special Projects - CNS</Text>
</ProgramElement>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7354</Code>
<Text>COMPUTER SYSTEMS</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9178</Code>
<Text>UNDERGRADUATE EDUCATION</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~199967</FUND_OBLG>
<FUND_OBLG>2012~15000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p class="p1">In order to make efficient use of modern computing hardware, it is often necessary for software to be parallelized. &nbsp;Parallelization can often be challenging, particularly with respect to understanding a program's runtime behavior and diagnosing correctness and performance problems. &nbsp;The goal of this project was to develop and apply a new perspective from which to analyze a parallel program's execution.&nbsp;</p> <p class="p2">&nbsp;</p> <p class="p1">As a result of this award, we have developed the concept of a parallel block vector profile. &nbsp;This profile&nbsp;considers an application in fragments called basic blocks, revealing the degree of parallelism exhibited by the application, i.e., the number of parallel threads, each time each basic block is executed. &nbsp;There are a number of ways to exploit this information. &nbsp;For example, we have analyzed applications on a per-fragment basis, and found, contrary to prevalent models, that basic blocks do not always belong exclusively to the serial or parallel regions of an application. &nbsp;A second analysis, explored the scalability of an application on a per-block basis, a much finer granularity than has been previously explored. &nbsp;A third use would be in conjunction with a timing model, to help reveal hidden performance bottlenecks. &nbsp;Because a parallel block vector profile simply reveals information, its uses are potentially both numerous and varied.</p> <p class="p2">&nbsp;</p> <p class="p1">A second outcome of this award was the development and release of an open source tool, called Harmony, which can be used to collect parallel block vector profiles. &nbsp;Collecting the fine-grained information demanded by the profiles without incurring substantial overhead is a non-trivial endeavor, and Harmony has been carefully designed and optimize to minimize any perturbation to the application under measurement.</p> <p>&nbsp;</p><br> <p>            Last Modified: 11/03/2013<br>      Modified by: Martha&nbsp;A&nbsp;Kim</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[In order to make efficient use of modern computing hardware, it is often necessary for software to be parallelized.  Parallelization can often be challenging, particularly with respect to understanding a program's runtime behavior and diagnosing correctness and performance problems.  The goal of this project was to develop and apply a new perspective from which to analyze a parallel program's execution.    As a result of this award, we have developed the concept of a parallel block vector profile.  This profile considers an application in fragments called basic blocks, revealing the degree of parallelism exhibited by the application, i.e., the number of parallel threads, each time each basic block is executed.  There are a number of ways to exploit this information.  For example, we have analyzed applications on a per-fragment basis, and found, contrary to prevalent models, that basic blocks do not always belong exclusively to the serial or parallel regions of an application.  A second analysis, explored the scalability of an application on a per-block basis, a much finer granularity than has been previously explored.  A third use would be in conjunction with a timing model, to help reveal hidden performance bottlenecks.  Because a parallel block vector profile simply reveals information, its uses are potentially both numerous and varied.   A second outcome of this award was the development and release of an open source tool, called Harmony, which can be used to collect parallel block vector profiles.  Collecting the fine-grained information demanded by the profiles without incurring substantial overhead is a non-trivial endeavor, and Harmony has been carefully designed and optimize to minimize any perturbation to the application under measurement.          Last Modified: 11/03/2013       Submitted by: Martha A Kim]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
