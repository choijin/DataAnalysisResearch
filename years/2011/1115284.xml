<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Small: A Comprehensive Framework for Real-Time Multiprocessor Synchronization</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/15/2011</AwardEffectiveDate>
<AwardExpirationDate>07/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>450000.00</AwardTotalIntnAmount>
<AwardAmount>450000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The advent of multicore technologies has fueled much recent work on methods for designing, deploying, and verifying multiprocessor implementations of real-time applications.  Such methods must necessarily be rooted in resource allocation techniques that facilitate predictable system designs.  In work on such techniques, scheduling algorithms, which allocate processor time, have received the greatest attention.  Synchronization algorithms, which coordinate access to other resources, have received much less attention.&lt;br/&gt;&lt;br/&gt;The current state-of-the-art regarding real-time multiprocessor synchronization is that simple locking protocols can be supported, but not much else.  This is a serious impediment that is limiting the evolution of real-time applications to "multicore-ready" versions.  Driven by this, a rich set of multiprocessor real-time synchronization mechanisms is being developed in this project.  These mechanisms are motivated by real application needs, as have arisen in joint work involving the investigators and industry colleagues at AT&amp;T and Northrop Grumman.  Such mechanisms are being designed for use within several system models, also motivated by real needs.  These include models wherein various complexities exist, such as having tasks of differing criticalities, multiple subsystems that must be "isolated" from one another, heterogeneous hardware components, dynamic task behaviors, etc.  In all of this work, the design of optimal synchronization protocols is being emphasized.  These protocols are being prototyped and evaluated within a open-source UNC-produced real-time Linux extension called LITMUS^RT.  Broader impacts will include continued joint research with industry colleagues, and the development of publicly-available open-source software that can be used by other institutions for research and teaching purposes.</AbstractNarration>
<MinAmdLetterDate>08/08/2011</MinAmdLetterDate>
<MaxAmdLetterDate>08/20/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1115284</AwardID>
<Investigator>
<FirstName>James</FirstName>
<LastName>Anderson</LastName>
<PI_MID_INIT>H</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>James H Anderson</PI_FULL_NAME>
<EmailAddress>anderson@cs.unc.edu</EmailAddress>
<PI_PHON>9195906057</PI_PHON>
<NSF_ID>000481767</NSF_ID>
<StartDate>08/08/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Sanjoy</FirstName>
<LastName>Baruah</LastName>
<PI_MID_INIT>K</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Sanjoy K Baruah</PI_FULL_NAME>
<EmailAddress>Baruah@wustl.edu</EmailAddress>
<PI_PHON>3149357546</PI_PHON>
<NSF_ID>000762080</NSF_ID>
<StartDate>08/08/2011</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of North Carolina at Chapel Hill</Name>
<CityName>CHAPEL HILL</CityName>
<ZipCode>275991350</ZipCode>
<PhoneNumber>9199663411</PhoneNumber>
<StreetAddress>104 AIRPORT DR STE 2200</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<StateCode>NC</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NC04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>608195277</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>142363428</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of North Carolina at Chapel Hill]]></Name>
<CityName>CHAPEL HILL</CityName>
<StateCode>NC</StateCode>
<ZipCode>275991350</ZipCode>
<StreetAddress><![CDATA[104 AIRPORT DR STE 2200]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NC04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1714</Code>
<Text>Special Projects - CNS</Text>
</ProgramElement>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7354</Code>
<Text>COMPUTER SYSTEMS</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~130000</FUND_OBLG>
<FUND_OBLG>2012~320000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Real-time systems are systems in which some computations have deadline constraints. &nbsp;For example, when the brake pedal of a car is depressed, the car should begin to slow within a specified number of milliseconds. &nbsp;The computations that must be supported within a real-time system are usually called "tasks." &nbsp;(A task is essentially just a computer program.) &nbsp;To save on hardware costs, it is often the case that many tasks with separate deadline requirements have to be supported on the same hardware platform. &nbsp;To ensure that each task meets its deadline requirements, a real-time scheduler must be used within the operating system that is cognizant of task deadlines and schedules tasks accordingly.</p> <p><br />Complicating matters further, tasks often interact with each other by sharing data and even hardware devices. &nbsp;When such sharing occurs, locking protocols must also be used. &nbsp;Such protocols coordinate accesses to shared resources, usually be requiring that each such resource is accessed by only one task at a time. &nbsp;The term "locking protocol" derives from the fact that such protocols enable tasks to "lock" shared resources for exclusive use. &nbsp;(In some cases, several tasks may together lock shared resources for coordinated use.) &nbsp;In the case of real-time systems, any locking protocol that is used must be cognizant of task deadline requirements, just like the scheduler. &nbsp;Also, for the given locking-protocol/scheduler combination employed, analysis must be obtained that can be used to mathematically prove that tasks will meet their deadlines.</p> <p><br />From the perspective of designing and realizing real-time systems, one of the most profound recent developments in the computing arena is the advent of multicore computers. &nbsp;Such computers actually consist of multiple processors. &nbsp;Thus, a multicore computer can execute many tasks in parallel, i.e., at the same time. &nbsp;The introduction of parallelism greatly complicates the design of real-time schedulers, real-time locking protocols, and the analysis for validating deadline requirements that underlies their use.</p> <p><br />This project was directed at the design of real-time locking protocols for multicore computers. &nbsp;The specific objective was to develop protocols that are both flexible and optimal. &nbsp;The term "flexible" means that protocols are desired that can be applied with few restrictions. &nbsp;For example, most previously developed real-time multicore locking protocols require that a task can lock only one resource at a time. &nbsp;This is a limiting assumption in many real-world scenarios where tasks need access to multiple resources simultaneously. &nbsp;The term "optimal" means that protocols are desired that are provably the "best possible" in a certain mathematical sense. &nbsp;The stated objective was met by designing and analyzing a number of new optimal real-time locking protocols for multicore computers. &nbsp;Additionally, various related issues involving the integration of such protocols within real-time schedulers were investigated. &nbsp;This locking/scheduling-oriented work was the main intellectual contribution of this project.</p> <p><br />In terms of broader impacts, the investigators presented talks on this work at numerous institutions, conferences, workshops, etc. &nbsp;Additionally, the results of this project formed the basis of the dissertations of two graduate students. &nbsp;These results have also fundamentally altered how the topic of real-time locking is taught at the investigators' institution.</p> <p>&nbsp;</p><br> <p>            Last Modified: 08/12/2015<br>      Modified by: Sanjoy&nbsp;K&nbsp;Baruah</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Real-time systems are systems in which some computations have deadline constraints.  For example, when the brake pedal of a car is depressed, the car should begin to slow within a specified number of milliseconds.  The computations that must be supported within a real-time system are usually called "tasks."  (A task is essentially just a computer program.)  To save on hardware costs, it is often the case that many tasks with separate deadline requirements have to be supported on the same hardware platform.  To ensure that each task meets its deadline requirements, a real-time scheduler must be used within the operating system that is cognizant of task deadlines and schedules tasks accordingly.   Complicating matters further, tasks often interact with each other by sharing data and even hardware devices.  When such sharing occurs, locking protocols must also be used.  Such protocols coordinate accesses to shared resources, usually be requiring that each such resource is accessed by only one task at a time.  The term "locking protocol" derives from the fact that such protocols enable tasks to "lock" shared resources for exclusive use.  (In some cases, several tasks may together lock shared resources for coordinated use.)  In the case of real-time systems, any locking protocol that is used must be cognizant of task deadline requirements, just like the scheduler.  Also, for the given locking-protocol/scheduler combination employed, analysis must be obtained that can be used to mathematically prove that tasks will meet their deadlines.   From the perspective of designing and realizing real-time systems, one of the most profound recent developments in the computing arena is the advent of multicore computers.  Such computers actually consist of multiple processors.  Thus, a multicore computer can execute many tasks in parallel, i.e., at the same time.  The introduction of parallelism greatly complicates the design of real-time schedulers, real-time locking protocols, and the analysis for validating deadline requirements that underlies their use.   This project was directed at the design of real-time locking protocols for multicore computers.  The specific objective was to develop protocols that are both flexible and optimal.  The term "flexible" means that protocols are desired that can be applied with few restrictions.  For example, most previously developed real-time multicore locking protocols require that a task can lock only one resource at a time.  This is a limiting assumption in many real-world scenarios where tasks need access to multiple resources simultaneously.  The term "optimal" means that protocols are desired that are provably the "best possible" in a certain mathematical sense.  The stated objective was met by designing and analyzing a number of new optimal real-time locking protocols for multicore computers.  Additionally, various related issues involving the integration of such protocols within real-time schedulers were investigated.  This locking/scheduling-oriented work was the main intellectual contribution of this project.   In terms of broader impacts, the investigators presented talks on this work at numerous institutions, conferences, workshops, etc.  Additionally, the results of this project formed the basis of the dissertations of two graduate students.  These results have also fundamentally altered how the topic of real-time locking is taught at the investigators' institution.          Last Modified: 08/12/2015       Submitted by: Sanjoy K Baruah]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
