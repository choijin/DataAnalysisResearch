<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Medium: Collaborative Research: Portable Performance for Parallel Managed Languages Across the Many-Core Spectrum</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/01/2012</AwardEffectiveDate>
<AwardExpirationDate>12/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>493938.00</AwardTotalIntnAmount>
<AwardAmount>509938</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Computers with many tens to hundreds of ?cores? are on their way, but programming languages and tools&lt;br/&gt;that exploit them well have lagged. At the same time, there are emerging programming languages intended&lt;br/&gt;for writing programs to run on these computers. These languages, such as X10 and Fortress, add support for&lt;br/&gt;new concepts that make it easier to write many-core programs, but there does not yet exist good compiler and&lt;br/&gt;run-time support for these languages. Systems that run Java, namely Java virtual machines such as those that&lt;br/&gt;run on virtually every laptop, desktop, and server today, supply much of what the new languages need, but&lt;br/&gt;fall short in some important ways. In particular they do not provide for saying in which part of memory to&lt;br/&gt;place particular objects, on which core to run which computations, easy ways to get all cores busy working&lt;br/&gt;on different parts of a big piece of data, or for synchronizing and getting right all the data manipulations&lt;br/&gt;happening at the same time. This project is extending an existing research Java virtual machine (Jikes&lt;br/&gt;RVM) with support for many ways of doing the things that the new languages need in order to run well&lt;br/&gt;on many-core computers. The primary goal is to devise extensions to standard Java virtual machines for&lt;br/&gt;this new world, and to make it possible for many others to experiment with different ways of implementing&lt;br/&gt;these extensions, thus leveraging the creativity of the whole community of language and virtual machine&lt;br/&gt;researchers. Secondary goals include offering reasonably good initial implementations of virtual machine&lt;br/&gt;extensions as a starting point for future research and development, and proposing specific extensions to the&lt;br/&gt;Java virtual machine specification standard.</AbstractNarration>
<MinAmdLetterDate>06/15/2012</MinAmdLetterDate>
<MaxAmdLetterDate>08/29/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1162246</AwardID>
<Investigator>
<FirstName>J. Eliot</FirstName>
<LastName>Moss</LastName>
<PI_MID_INIT>B</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>J. Eliot B Moss</PI_FULL_NAME>
<EmailAddress>moss@cs.umass.edu</EmailAddress>
<PI_PHON>4135454206</PI_PHON>
<NSF_ID>000261930</NSF_ID>
<StartDate>06/15/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Timothy</FirstName>
<LastName>Richards</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Timothy Richards</PI_FULL_NAME>
<EmailAddress>richards@cs.umass.edu</EmailAddress>
<PI_PHON>4135455229</PI_PHON>
<NSF_ID>000600567</NSF_ID>
<StartDate>06/15/2012</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Massachusetts Amherst</Name>
<CityName>Hadley</CityName>
<ZipCode>010359450</ZipCode>
<PhoneNumber>4135450698</PhoneNumber>
<StreetAddress>Research Administration Building</StreetAddress>
<StreetAddress2><![CDATA[100 Venture Way, Suite 201]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>153926712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF MASSACHUSETTS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>079520631</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Massachusetts Amherst]]></Name>
<CityName>Amherst</CityName>
<StateCode>MA</StateCode>
<ZipCode>010039264</ZipCode>
<StreetAddress><![CDATA[140 Governors Drive]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1714</Code>
<Text>Special Projects - CNS</Text>
</ProgramElement>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7354</Code>
<Text>COMPUTER SYSTEMS</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9178</Code>
<Text>UNDERGRADUATE EDUCATION</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~168274</FUND_OBLG>
<FUND_OBLG>2013~341664</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>For some time, individual computer cores have not become faster, because they would overheat.&nbsp; To provide increasing computational power, computers now provide more "cores" (individual processors) on the same "chip" or board.&nbsp; Thus, to make an application run faster, it needs to be coded to use multiple cores.&nbsp; But this requires complex coordination between the cores, notoriously difficult to program.</p> <p>A feature called <em>transactions</em> helps simplify this programming, by allowing the programmer to indicate a whole series of steps that need to be done <em>as a unit</em> to avoid corrupting the computation.&nbsp; A classic example of this in real life is transferring funds between two accounts - one account must show the removal of funds and the other an addition of the same amount.&nbsp; It must not be possible to have only one part of the transaction occur, or else money has been (from the standpoint of the record keeping) created or it has disappeared, rather than simply moving.</p> <p>A variety of transaction schemes have been devised, and one achievement of this project was to implement a number of them for the Java programming language, in a way that can work for any Java implementation.&nbsp; Some schemes perform better than others in diffierent circumstances, so it turned out to be useful to support <em>multiple</em> schemes at once.</p> <p>Furthermore, transaction support in software involves noticeable bookkeeping overhead.&nbsp; Therefore, processor manufacturers have started to make available certain limited hardware support for transactions.&nbsp; This project developed ways to seamlessly run various transactions in hardware (when they meet the hardware's limitations) or in software (when they don't).&nbsp; Furthermore, it developed ways to use software to glue together multiple hardware transactions into a larger overall transaction, in certain circumstances (ones that can be expected to occur in many software libraries).</p> <p>In these ways the project contributed to making it easier to develop correct software that performs well for applications exploiting multiple cores on multicore computers.</p><br> <p>            Last Modified: 05/04/2017<br>      Modified by: J. Eliot&nbsp;B&nbsp;Moss</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ For some time, individual computer cores have not become faster, because they would overheat.  To provide increasing computational power, computers now provide more "cores" (individual processors) on the same "chip" or board.  Thus, to make an application run faster, it needs to be coded to use multiple cores.  But this requires complex coordination between the cores, notoriously difficult to program.  A feature called transactions helps simplify this programming, by allowing the programmer to indicate a whole series of steps that need to be done as a unit to avoid corrupting the computation.  A classic example of this in real life is transferring funds between two accounts - one account must show the removal of funds and the other an addition of the same amount.  It must not be possible to have only one part of the transaction occur, or else money has been (from the standpoint of the record keeping) created or it has disappeared, rather than simply moving.  A variety of transaction schemes have been devised, and one achievement of this project was to implement a number of them for the Java programming language, in a way that can work for any Java implementation.  Some schemes perform better than others in diffierent circumstances, so it turned out to be useful to support multiple schemes at once.  Furthermore, transaction support in software involves noticeable bookkeeping overhead.  Therefore, processor manufacturers have started to make available certain limited hardware support for transactions.  This project developed ways to seamlessly run various transactions in hardware (when they meet the hardware's limitations) or in software (when they don't).  Furthermore, it developed ways to use software to glue together multiple hardware transactions into a larger overall transaction, in certain circumstances (ones that can be expected to occur in many software libraries).  In these ways the project contributed to making it easier to develop correct software that performs well for applications exploiting multiple cores on multicore computers.       Last Modified: 05/04/2017       Submitted by: J. Eliot B Moss]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
