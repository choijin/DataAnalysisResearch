<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: MEDIUM: Achieving Software Reliability without True Test Oracles</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2012</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>894582.00</AwardTotalIntnAmount>
<AwardAmount>894582</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Conventional software testing checks whether each output is correct for the set of test inputs. But for some software, it is not known what the correct output should be for some inputs -- yet it is still important to detect coding errors in that software, so they can be fixed. This dilemma arises frequently for machine learning, simulation and optimization applications, often "Programs which were written in order to determine the answer in the first place. There would be no need to write such programs, if the correct answer were known." As these kinds of applications are frequently used in public infrastructure and biomedical research (domains targeted in this research), it is critical to detect and fix errors before a calamity occurs.&lt;br/&gt; &lt;br/&gt;Fortunately, many such applications reflect 'metamorphic properties' that define a relationship between pairs of inputs and outputs, such that for any previous input i with its already known output o, one can easily derive a test input i' and predict the expected output o'. If the actual output o'' is different from o', then there must be an error in the code. This project investigates methodology for determining the metamorphic properties of software and for devising good test cases from which the secondary tests can be derived. The project extends the inputs/outputs considered in previous work on metamorphic testing to focus on application state, before and after, rather than just functional parameters and results. The research also extends the pairwise relations implied by metamorphic properties to 'semantic similarity' for nondeterministic applications, applied to profiles from numerous executions, since an exact relation cannot be expected to hold for a single pair of test executions. These extensions enable treatment of more sophisticated properties that preliminary experiments have shown to reveal defects that were not detected otherwise.</AbstractNarration>
<MinAmdLetterDate>03/26/2012</MinAmdLetterDate>
<MaxAmdLetterDate>07/08/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1161079</AwardID>
<Investigator>
<FirstName>Gail</FirstName>
<LastName>Kaiser</LastName>
<PI_MID_INIT>E</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Gail E Kaiser</PI_FULL_NAME>
<EmailAddress>kaiser@cs.columbia.edu</EmailAddress>
<PI_PHON>2129397081</PI_PHON>
<NSF_ID>000094973</NSF_ID>
<StartDate>03/26/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Columbia University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100276902</ZipCode>
<PhoneNumber>2128546851</PhoneNumber>
<StreetAddress>2960 Broadway</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049179401</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049179401</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Columbia University]]></Name>
<CityName>New York</CityName>
<StateCode>NY</StateCode>
<ZipCode>100277003</ZipCode>
<StreetAddress><![CDATA[1214 Amsterdam Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~289247</FUND_OBLG>
<FUND_OBLG>2013~298100</FUND_OBLG>
<FUND_OBLG>2014~307235</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>It is well-known that most if not all software contains defects or flaws, often called "bugs". &nbsp;Some bugs are mild nuisances and can be ignored or worked around, but others can result in catastrophic and expensive failures. &nbsp;Software testing is the primary means by which software engineers seek to reduce the number of bugs, particularly the most severe bugs, by detecting them in advance so they can be fixed. &nbsp;The basic mechanism for testing is to choose a set of inputs deemed likely to trigger typical programming errors, run the software with those inputs safely in the development lab, and check that the results are correct. &nbsp;Unfortunately, this approach does not work very well for some kinds of software, where we do not always know what the result should be. &nbsp;One popular class of such software is known as "machine learning". &nbsp;We need a better approach to testing for bugs in such software.</p> <p>One approach, originally suggested by others, is to use technical knowledge called the "metamorphic properties" of the application, or of the domain, because it is often possible to check the metamorphic properties even when we cannot check the result. &nbsp;Metamorphic properties describe the relationship between pairs of executions, one test case with a known input and a known output (which we may not know is correct or incorrect), with a way to create a new test case where the new input is derived from the original input and the expected output is derived from the original output. &nbsp;If the actual output when we run the new test case does not match its expected output, we know there is a bug in the software, even though we do not know whether either output is correct (and they might both be wrong).</p> <p>But although it may be possible to determine the metamorphic properties of the software, so they can be checked during software testing, it is not always easy. &nbsp;Thus we investigated three ways to improve metamorphic testing and make it more practical. &nbsp;First, we developed techniques to automatically determine likely metamorphic properties for the software engineer to consider. &nbsp;Second, since it is often simpler to determine the metamorphic properties of small functional elements of a software application than the application as a whole, and because sometimes the full application does not even have usable metamorphic properties, we investigated how to check the metamorphic properties of individual functions as well as of the full application. Finally, we broadened the range of metamorphic properties that can be specified and checked to consider the application's internal state, since sometimes its hard or impossible to define a useful metamorphic property only considering the inputs and outputs. &nbsp;</p> <p>These improvements to metamorphic testing can also find bugs in conventional software, where software engineers can indeed check the outputs for correctness, but that are still not caught by conventional test cases. &nbsp;For example, sometimes errors build up in the internal state of an application, without being evident in the outputs until later.</p> <p>&nbsp;</p><br> <p>            Last Modified: 10/03/2016<br>      Modified by: Gail&nbsp;E&nbsp;Kaiser</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ It is well-known that most if not all software contains defects or flaws, often called "bugs".  Some bugs are mild nuisances and can be ignored or worked around, but others can result in catastrophic and expensive failures.  Software testing is the primary means by which software engineers seek to reduce the number of bugs, particularly the most severe bugs, by detecting them in advance so they can be fixed.  The basic mechanism for testing is to choose a set of inputs deemed likely to trigger typical programming errors, run the software with those inputs safely in the development lab, and check that the results are correct.  Unfortunately, this approach does not work very well for some kinds of software, where we do not always know what the result should be.  One popular class of such software is known as "machine learning".  We need a better approach to testing for bugs in such software.  One approach, originally suggested by others, is to use technical knowledge called the "metamorphic properties" of the application, or of the domain, because it is often possible to check the metamorphic properties even when we cannot check the result.  Metamorphic properties describe the relationship between pairs of executions, one test case with a known input and a known output (which we may not know is correct or incorrect), with a way to create a new test case where the new input is derived from the original input and the expected output is derived from the original output.  If the actual output when we run the new test case does not match its expected output, we know there is a bug in the software, even though we do not know whether either output is correct (and they might both be wrong).  But although it may be possible to determine the metamorphic properties of the software, so they can be checked during software testing, it is not always easy.  Thus we investigated three ways to improve metamorphic testing and make it more practical.  First, we developed techniques to automatically determine likely metamorphic properties for the software engineer to consider.  Second, since it is often simpler to determine the metamorphic properties of small functional elements of a software application than the application as a whole, and because sometimes the full application does not even have usable metamorphic properties, we investigated how to check the metamorphic properties of individual functions as well as of the full application. Finally, we broadened the range of metamorphic properties that can be specified and checked to consider the application's internal state, since sometimes its hard or impossible to define a useful metamorphic property only considering the inputs and outputs.    These improvements to metamorphic testing can also find bugs in conventional software, where software engineers can indeed check the outputs for correctness, but that are still not caught by conventional test cases.  For example, sometimes errors build up in the internal state of an application, without being evident in the outputs until later.          Last Modified: 10/03/2016       Submitted by: Gail E Kaiser]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
