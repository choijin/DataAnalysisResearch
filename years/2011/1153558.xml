<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER:Theories and Tools for Safe Concurrent Data Structures</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2011</AwardEffectiveDate>
<AwardExpirationDate>08/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>199972.00</AwardTotalIntnAmount>
<AwardAmount>199972</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Existing techniques for reasoning about the behavior and correctness of software running on multi-processor computers assume that each location in the shared memory always has a single, unique value as observed by the processors. But, on modern computer systems, this assumption is false---programs executing on different processors may simultaneously observe different values for some locations in memory. As a consequence, when applied to some important classes of programs, existing reasoning techniques may falsely assert that an incorrect program is in fact correct, thus potentially leading to runtime errors or even security breaches. The goal of this research project is to develop foundational theories and automatic, practical tools for program reasoning that are correct for such modern multi-processor computer systems.&lt;br/&gt;&lt;br/&gt;The theory consists of a Hoare-style program logic, which deeply incorporates the specifics of the x86 memory model, and which can be used to give rigorous, high-level proofs of partial correctness properties of C-like, multi-threaded programs. The logic is inspired by separation logic, and embodies a x86-specific principle of local reasoning, which allows specifications and proofs to be restricted to just those resources used at runtime, instead of the global system state. The project additionally includes program checkers based on this logic, for automatically constructing proofs of partially-specified programs. Using these tools, the project intends to target, in particular, concurrent data structures: concurrent, and typically race-prone implementations of traditional sequential data structures, which carefully omit locks and other synchronization instructions to maximize concurrent throughput.</AbstractNarration>
<MinAmdLetterDate>09/02/2011</MinAmdLetterDate>
<MaxAmdLetterDate>09/02/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1153558</AwardID>
<Investigator>
<FirstName>Warren</FirstName>
<LastName>Hunt, Jr.</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Warren A Hunt, Jr.</PI_FULL_NAME>
<EmailAddress>hunt@cs.utexas.edu</EmailAddress>
<PI_PHON>5124719748</PI_PHON>
<NSF_ID>000369883</NSF_ID>
<StartDate>09/02/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Texas at Austin</Name>
<CityName>Austin</CityName>
<ZipCode>787595316</ZipCode>
<PhoneNumber>5124716424</PhoneNumber>
<StreetAddress>3925 W Braker Lane, Ste 3.340</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>170230239</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF TEXAS AT AUSTIN</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042000273</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Texas at Austin]]></Name>
<CityName>Austin</CityName>
<StateCode>TX</StateCode>
<ZipCode>787137726</ZipCode>
<StreetAddress><![CDATA[P.O. Box 7726]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>21</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX21</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~199972</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Our work under this contract focused on verifying the correctness of parallel programs. Most modern computers (including virtually all personal computers) have multiple processors, enabling them to run programs that ``multitask'' -- i.e., perform multiple concurrent tasks at the same time for efficiency purposes. Our goal has been to develop tools which enable programmers and software designers to understand if, and why, their parallel programs actually operate as expected. Parallel programs are generally more error-prone than sequential (that is, non-parallel) programs, because of the increased complexity required to get the various parallel components to communicate properly. &nbsp;Matters are further complicated by unintuitive behaviors caused by certain hardware optimizations, most of which are designed to be invisible for sequential programs, but become design headaches the instant parallelism is introduced.<br />To verify the correctness of parallel programs, we need to ensure that our tools are based on a realistic ``programming model'' of the underlying hardware, which should incorporate aspects of the hardware relevant to running the program. &nbsp;We need to respect those complexities in our verification environment -- we cannot present the programmer with a programming model that is too ``ideal'' and abstracts away from real-world issues.<br />To this end, we have performed extensive research on x86-TSO, the de facto specification of the ``memory model'' for the x86 microprocessor, which is found in most personal computers. This memory model was developed by Sewell et al. with the intention of making mathematically precise the ambiguous language in the Intel and AMD x86 manuals, while still being true to the reality of multiprocessor x86 machines. In particular, when multiple processors access the same memory location with reads or writes, it is sometimes difficult to discern the data values that will be read, because of certain hardware optimizations that enable processors to ``delay'' their writes under various circumstances. The x86-TSO model captures this uncertainty. We have modeled an instruction set architecture (ISA) that uses x86-TSO as its underlying memory model. All of our instructions are implemented in terms of the primitive x86-TSO transitions.<br />Traditional testing cannot find all bugs, because it can only test a small percentage of possible inputs. Our approach to software correctness employs rigorous proof based on a formal model, rather than testing. We have used our model to prove some simple programs correct, and we believe our work is a novel modeling effort -- we have formalized a rigorous memory model, which is a basis for our ISA model. This work complements a detailed formal model of the x86 ISA under development at the University of Texas at Austin. &nbsp;That x86 model is currently sequential, but could be enhanced to handle parallel programs with the modeling techniques we have developed. Indeed, that project is currently being pursued under new NSF funding.<br />Intellectual Merit<br />We have created a formal, executable ISA model, based on the x86-TSO memory model, in the ACL2 theorem proving environment. &nbsp;Moreover, we have used this model to prove correctness of several small multiprocessor programs. &nbsp;Unlike other formal approaches to multiprocessor program correctness, our approach can provide greater trust in two respects: proofs rely only on the correctness of our tools and our model, as there are no intervening abstractions to trust; and we reason directly about machine-level code, with no trust put on a compiler.<br />Broader Impact<br />Our work under this contract has been made available via github. ACL2 users and others interested in program verification with real-world memory models are free to use, or (we hope) improve upon our tools to further the goal of mathematically proving the correctness of p...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Our work under this contract focused on verifying the correctness of parallel programs. Most modern computers (including virtually all personal computers) have multiple processors, enabling them to run programs that ``multitask'' -- i.e., perform multiple concurrent tasks at the same time for efficiency purposes. Our goal has been to develop tools which enable programmers and software designers to understand if, and why, their parallel programs actually operate as expected. Parallel programs are generally more error-prone than sequential (that is, non-parallel) programs, because of the increased complexity required to get the various parallel components to communicate properly.  Matters are further complicated by unintuitive behaviors caused by certain hardware optimizations, most of which are designed to be invisible for sequential programs, but become design headaches the instant parallelism is introduced. To verify the correctness of parallel programs, we need to ensure that our tools are based on a realistic ``programming model'' of the underlying hardware, which should incorporate aspects of the hardware relevant to running the program.  We need to respect those complexities in our verification environment -- we cannot present the programmer with a programming model that is too ``ideal'' and abstracts away from real-world issues. To this end, we have performed extensive research on x86-TSO, the de facto specification of the ``memory model'' for the x86 microprocessor, which is found in most personal computers. This memory model was developed by Sewell et al. with the intention of making mathematically precise the ambiguous language in the Intel and AMD x86 manuals, while still being true to the reality of multiprocessor x86 machines. In particular, when multiple processors access the same memory location with reads or writes, it is sometimes difficult to discern the data values that will be read, because of certain hardware optimizations that enable processors to ``delay'' their writes under various circumstances. The x86-TSO model captures this uncertainty. We have modeled an instruction set architecture (ISA) that uses x86-TSO as its underlying memory model. All of our instructions are implemented in terms of the primitive x86-TSO transitions. Traditional testing cannot find all bugs, because it can only test a small percentage of possible inputs. Our approach to software correctness employs rigorous proof based on a formal model, rather than testing. We have used our model to prove some simple programs correct, and we believe our work is a novel modeling effort -- we have formalized a rigorous memory model, which is a basis for our ISA model. This work complements a detailed formal model of the x86 ISA under development at the University of Texas at Austin.  That x86 model is currently sequential, but could be enhanced to handle parallel programs with the modeling techniques we have developed. Indeed, that project is currently being pursued under new NSF funding. Intellectual Merit We have created a formal, executable ISA model, based on the x86-TSO memory model, in the ACL2 theorem proving environment.  Moreover, we have used this model to prove correctness of several small multiprocessor programs.  Unlike other formal approaches to multiprocessor program correctness, our approach can provide greater trust in two respects: proofs rely only on the correctness of our tools and our model, as there are no intervening abstractions to trust; and we reason directly about machine-level code, with no trust put on a compiler. Broader Impact Our work under this contract has been made available via github. ACL2 users and others interested in program verification with real-world memory models are free to use, or (we hope) improve upon our tools to further the goal of mathematically proving the correctness of parallel programs.       Last Modified: 10/09/2015       Submitted by: Warren A Hunt, Jr.]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
