<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: AF: Medium: Collaborative Research: The Pochoir Stencil Compiler</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/01/2012</AwardEffectiveDate>
<AwardExpirationDate>09/30/2014</AwardExpirationDate>
<AwardTotalIntnAmount>173584.00</AwardTotalIntnAmount>
<AwardAmount>173584</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Many high-end scientific applications perform stencil computations in their inner loops.  A stencil defines the value of a grid point in a d-dimensional spatial grid at time t as a function of neighboring grid points at recent times before t. Stencil computations are conceptually simple to implement using nested loops, but looping implementations suffer from poor cache performance on multicore processors.  Cache-oblivious divide-and-conquer stencil codes can achieve an order of magnitude improvement in cache efficiency over looping implementations, but most programmers find it difficult to write cache-oblivious stencil codes.  Moreover, open problems remain in adapting these algorithms to realistic applications that lack the perfect regularity of simple examples.  This project's investigation of cache-oblivious stencil compilation enables ordinary programmers of stencil computations to enjoy the benefits of multicore technology without requiring them to write code any more complex than naive nested loops.&lt;br/&gt;&lt;br/&gt;The research project is developing a language embedded in C++ that can express stencil computations concisely and can be compiled automatically into highly efficient algorithmic code for multicore processors and other platforms.  The Pochoir stencil compiler compiles stencil computations that exhibit complex boundary conditions, such as periodic, constant, Dirichlet, Neumann, mirrored, and phase factors; irregularities, including macroscopic and microscopic inhomogeneities, as well as irregular shapes;  general complex dependencies, such as push dependencies, horizontal dependencies, and dynamic dependencies.&lt;br/&gt;To achieve these goals, the researchers are developing provably good algorithms for complex stencil computations; exploring how domain-specific compiler technology can achieve speedups from efficient cache management, processor-pipeline scheduling, and parallel computation; investigating how to run stencils efficiently on a wide variety of architectures such as multicore, distributed-memory clusters, graphical processing units, FPGA's, and future exascale machines; demonstrating the effectiveness of their research by developing a production-quality stencil compiler; developing a benchmark suite and benchmarking system for evaluating Pochoir.&lt;br/&gt;&lt;br/&gt;This research enables scientific researchers and others to easily produce highly efficient codes for complex stencil computations.  The codes make good use of the memory hierarchy and processor pipelines endemic to multicore processors and run fast on a diverse set of hardware platforms.  This research eases the development and maintenance of a wide variety of stencil-based applications ? ranging across physics, biology, chemistry, energy, climate, mechanical and electrical engineering, finance, and other areas ? benefiting these application areas, as well as society at large.</AbstractNarration>
<MinAmdLetterDate>04/05/2012</MinAmdLetterDate>
<MaxAmdLetterDate>05/02/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1162196</AwardID>
<Investigator>
<FirstName>Rezaul</FirstName>
<LastName>Chowdhury</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Rezaul A Chowdhury</PI_FULL_NAME>
<EmailAddress>rezaul@cs.stonybrook.edu</EmailAddress>
<PI_PHON>6316328959</PI_PHON>
<NSF_ID>000599542</NSF_ID>
<StartDate>04/05/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>SUNY at Stony Brook</Name>
<CityName>Stony Brook</CityName>
<ZipCode>117940001</ZipCode>
<PhoneNumber>6316329949</PhoneNumber>
<StreetAddress>WEST 5510 FRK MEL LIB</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>804878247</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>RESEARCH FOUNDATION FOR THE STATE UNIVERSITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>020657151</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[SUNY at Stony Brook]]></Name>
<CityName/>
<StateCode>NY</StateCode>
<ZipCode>117943366</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7329</Code>
<Text>COMPILERS</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~83366</FUND_OBLG>
<FUND_OBLG>2013~90218</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This research investigated the problem of generating high-efficiency cache-oblivious code for real-world stencil computations that make good use of the memory hierarchy and processor pipelines, starting with simple-to-write linguistic specifications. The goal was to make a wide variety of stencil-based applications --- ranging across physics, biology, chemistry, energy, climate, mechanical and electrical engineering, finance, and other areas --- easier to develop and maintain, benefiting these application areas, as well as society at large. The outcome was a robust stencil compiler that handles homogeneous stencil rules on rectangular shapes, simple boundary conditions, and simple dependency rules. Approaches to handle complex boundary conditions, inhomogeneities, irregular shapes, and complicated dependencies were also investigated. Results were also obtained on performing stencil computations on unstructured graphs, achieving pipeline parallelism on the fly, and delivering optimal cache performance without trading off parallelism.</p> <p>The researchers developed PRISM, a chromatic-scheduling algorithm for executing dynamic data-graph&nbsp;computations. Data-graph computations are an extension of stencil computations from simple grids to&nbsp;general unstructured graphs. PRISM uses a vertex-coloring of the graph to coordinate updates performed&nbsp;in a round, precluding the need for mutual-exclusion locks or other nondeterministic data synchronization.&nbsp;PRISM has provably good bounds on work and span, and these theoretical guarantees are matched by good&nbsp;empirical performance. The researchers also developed PRISM-R, a variation of PRISM that executes dynamic&nbsp;data-graph computations deterministically even when updates modify global variables with associative&nbsp;operations. PRISM-R satisfies the same theoretical bounds as PRISM, but its implementation is more involved.</p> <p>The researchers investigated how a concurrency platform for fork-join parallelism can be enhanced to&nbsp;support pipeline parallelism in a provably efficient manner. Indeed, one can imagine performing a&nbsp;stencil computation as a pipeline. The researchers proposed simple linguistics for specifying pipeline&nbsp;parallelism, designed a provably efficient scheduling algorithm that integrates pipeline parallelism&nbsp;into a work-stealing scheduler for fork-join parallelism, and analyzed the algorithm. The proposed&nbsp;linguistics allow the structure of the pipeline to be specified "on the fly," as opposed to the&nbsp;"build-and-run" approach taken by existing concurrency platforms, thereby allowing a more flexible&nbsp;structure of the pipeline. The proposed mechanism has been incorporated into Cilk-M, a Cilk-based&nbsp;work-stealing runtime system. Benchmark results indicate that the prototype implementation has low&nbsp;serial overhead and good scalability.&nbsp;</p> <p>The researchers invented parallel &ldquo;Cache-Oblivious Wavefront&rdquo; (COW) algorithms. Unlike most state-of-the-art&nbsp;cache-oblivious parallel algorithms for stencils and dynamic programming (DP) problems that trade off&nbsp;parallelism for better cache performance, COW algorithms aim to achieve the same without sacrificing parallelism.&nbsp;COW algorithms perform divide-and-conquer (DAC) of the stencil/DP grid in exactly the same way as standard&nbsp;cache-optimal recursive DAC-based algorithms, but consider a recursive subtask ready for execution as soon as&nbsp;all its real dependency constraints are satisfied. COW algorithms inherit the cache-obliviousness and (serial)&nbsp;cache-optimality properties of the standard recursive DAC-based algorithms. But by scheduling a recursive subtask&nbsp;ready for execution based only on its real dependency constraints, COW algorithms lead to potentially improved&nbsp;parallelism. Experimental results on stencil and DP computations support these claims.</p> <...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This research investigated the problem of generating high-efficiency cache-oblivious code for real-world stencil computations that make good use of the memory hierarchy and processor pipelines, starting with simple-to-write linguistic specifications. The goal was to make a wide variety of stencil-based applications --- ranging across physics, biology, chemistry, energy, climate, mechanical and electrical engineering, finance, and other areas --- easier to develop and maintain, benefiting these application areas, as well as society at large. The outcome was a robust stencil compiler that handles homogeneous stencil rules on rectangular shapes, simple boundary conditions, and simple dependency rules. Approaches to handle complex boundary conditions, inhomogeneities, irregular shapes, and complicated dependencies were also investigated. Results were also obtained on performing stencil computations on unstructured graphs, achieving pipeline parallelism on the fly, and delivering optimal cache performance without trading off parallelism.  The researchers developed PRISM, a chromatic-scheduling algorithm for executing dynamic data-graph computations. Data-graph computations are an extension of stencil computations from simple grids to general unstructured graphs. PRISM uses a vertex-coloring of the graph to coordinate updates performed in a round, precluding the need for mutual-exclusion locks or other nondeterministic data synchronization. PRISM has provably good bounds on work and span, and these theoretical guarantees are matched by good empirical performance. The researchers also developed PRISM-R, a variation of PRISM that executes dynamic data-graph computations deterministically even when updates modify global variables with associative operations. PRISM-R satisfies the same theoretical bounds as PRISM, but its implementation is more involved.  The researchers investigated how a concurrency platform for fork-join parallelism can be enhanced to support pipeline parallelism in a provably efficient manner. Indeed, one can imagine performing a stencil computation as a pipeline. The researchers proposed simple linguistics for specifying pipeline parallelism, designed a provably efficient scheduling algorithm that integrates pipeline parallelism into a work-stealing scheduler for fork-join parallelism, and analyzed the algorithm. The proposed linguistics allow the structure of the pipeline to be specified "on the fly," as opposed to the "build-and-run" approach taken by existing concurrency platforms, thereby allowing a more flexible structure of the pipeline. The proposed mechanism has been incorporated into Cilk-M, a Cilk-based work-stealing runtime system. Benchmark results indicate that the prototype implementation has low serial overhead and good scalability.   The researchers invented parallel "Cache-Oblivious Wavefront" (COW) algorithms. Unlike most state-of-the-art cache-oblivious parallel algorithms for stencils and dynamic programming (DP) problems that trade off parallelism for better cache performance, COW algorithms aim to achieve the same without sacrificing parallelism. COW algorithms perform divide-and-conquer (DAC) of the stencil/DP grid in exactly the same way as standard cache-optimal recursive DAC-based algorithms, but consider a recursive subtask ready for execution as soon as all its real dependency constraints are satisfied. COW algorithms inherit the cache-obliviousness and (serial) cache-optimality properties of the standard recursive DAC-based algorithms. But by scheduling a recursive subtask ready for execution based only on its real dependency constraints, COW algorithms lead to potentially improved parallelism. Experimental results on stencil and DP computations support these claims.  The researchers investigated high-performance parallel implementations of dynamic programs with more complicated dependency patterns than those encountered in stencil computations. Traditional looping codes implementing d...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
