<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TC: Small: WATCHDOG: Hardware-Assisted Prevention of All Use-After-Free Security Vulnerabilities</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2011</AwardEffectiveDate>
<AwardExpirationDate>07/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>499961.00</AwardTotalIntnAmount>
<AwardAmount>499961</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>A use-after-free error is a software flaw that potentially allows an attacker to remotely inject malicious software or corrupt memory values. Such attacks can result in the theft of private data, propagation of worms and viruses, or the creation of botnet nodes that can be programmed to spew spam or disrupt Internet traffic.  Recently, use-after-free vulnerabilities have been found in crucial software such as Microsoft's Internet Explorer, Adobe Acrobat Reader, and Firefox among others.  The goal of the Watchdog project is to devise hardware and software mechanisms to prevent all such vulnerabilities.&lt;br/&gt;&lt;br/&gt;To prevent use-after-free vulnerabilities, the researchers will develop hardware for enforcing safe manual memory management, without compromising system performance.  They will study a formal model of their designs to establish the correctness of the techniques.  The hardware designs will be prototyped using detailed micro-architectural simulations.  The researchers will evaluate correctness and performance by using a suite of benchmark tests and off-the-shelf software.  The tools and prototypes will be openly distributed for others to build upon, and the research findings will be integrated into the security and hardware courses taught by the researchers.  If successful, the technology developed by this research will have significant societal impacts, improving the security of our computing ecosystem by eliminating an important class of vulnerabilities that is actively being exploited to compromise systems and spread malware.</AbstractNarration>
<MinAmdLetterDate>07/18/2011</MinAmdLetterDate>
<MaxAmdLetterDate>03/31/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1116682</AwardID>
<Investigator>
<FirstName>Stephan</FirstName>
<LastName>Zdancewic</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephan A Zdancewic</PI_FULL_NAME>
<EmailAddress>stevez@cis.upenn.edu</EmailAddress>
<PI_PHON>2158982661</PI_PHON>
<NSF_ID>000220116</NSF_ID>
<StartDate>03/31/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Stephan</FirstName>
<LastName>Zdancewic</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephan A Zdancewic</PI_FULL_NAME>
<EmailAddress>stevez@cis.upenn.edu</EmailAddress>
<PI_PHON>2158982661</PI_PHON>
<NSF_ID>000220116</NSF_ID>
<StartDate>07/18/2011</StartDate>
<EndDate>07/08/2015</EndDate>
<RoleCode>Former Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Milo</FirstName>
<LastName>Martin</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Milo Martin</PI_FULL_NAME>
<EmailAddress>milom@cis.upenn.edu</EmailAddress>
<PI_PHON>2157462972</PI_PHON>
<NSF_ID>000383219</NSF_ID>
<StartDate>07/18/2011</StartDate>
<EndDate>07/08/2015</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Pennsylvania</Name>
<CityName>Philadelphia</CityName>
<ZipCode>191046205</ZipCode>
<PhoneNumber>2158987293</PhoneNumber>
<StreetAddress>Research Services</StreetAddress>
<StreetAddress2><![CDATA[3451 Walnut St, 5th Flr Franklin]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>042250712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042250712</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Pennsylvania]]></Name>
<CityName>Philadelphia</CityName>
<StateCode>PA</StateCode>
<ZipCode>191046205</ZipCode>
<StreetAddress><![CDATA[Research Services]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramReference>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~499961</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The lack of memory safety in languages such as C and C++ is a root source of exploitable security vulnerabilities prevalent in more computing infrastructure. This project explored both hardware and software techniques toeliminate such vulnerabilities by enforcing comprehensive memory safety. In bothcases, the technical approach is to associate space bounds and identifiermetadata with pointers, propagate them on pointer operations, and check them onpointer dereferences. Checking the bounds and identifier metadata provides bothprecise, byte-granularity buffer-overflow protection and protection fromuse-after-free errors, even in the presence of reallocations.</p> <p>This project explored the effectiveness of storing pointer metadata in a disjoint metadata space to provide both comprehensive protection and enhance compatibility with existing code. Our implementations reduce the runtime overhead with hardware extensions that use micro-operations to implement metadata access and checking and a dedicated identifier cache to reduce checking overhead. The hardware extension also eliminates metadata copies via register renaming in the out-of-order core.</p> <p>Subsequently, we have proposed a set of ISA extensions called WatchdogLite that provides hardware acceleration for a compiler implementation of pointer-based checking. This division of labor between the compiler and the hardware allows for hardware acceleration while using only preexisting architectural registers. By leveraging the compiler to identify pointers, perform check elimination, and insert the new instructions, this approach attains performance similar to prior hardware-intensive approaches without adding any hardware structures for tracking metadata.</p> <p>During the course of this project, Intel developed Memory Protection Extensions(MPX) and released the ISA specification in 2013. Intel&rsquo;s MPX extensions are similar to WatchdogLite. Intel&rsquo;s software implementation---PointerChecker---is similar to SoftBoundCETS. Intel MPX uses pointer-based checking with disjoint metadata, adding new instructions for efficiently accessing the metadata shadowspace, and adding instruction for accelerating bounds checking. In contrast with WatchdogLite, MPX does not include support for accelerating use-after-freechecking. PI Santosh Nagarakatte has collaborated with Intel to explore the addition of use-after-free checking support to Intel MPX.</p> <p>We also discovered that Intel MPX&rsquo;s support for incremental deployment of bounds checking results in the loss of comprehensiveness in the presence of insidious type casts from integers to pointers either directly or indirectly through memory. Particularly, any arbitrary pointer manufactured through type casts will be allowed to access any location in memory (even with MPX protection) because(1) the pointer in the metadata space is not updated during integer operations,(2) the pointer loaded and the pointer in the metadata space would mismatch on a metadata load, and (3) the result is an un-bounded pointer. The compiler can identify the occurrence of such type casts either implicitly or explicitly and warn the programmer about them.</p> <p>During the course of this project, we also explored various other extensions to memory safety. First, we have investigated the impact of compiler optimizations on instrumentation added for memory safety. We have also developed methods tocheck if compiler optimizations can erroneously remove instrumentation added by memory safety transformation. Second, we have also developed a suite of micro-optimizations to reduce the overhead of memory safety checks. Third,enforcing atomicity and race freedom for memory safety instrumentation with multithreaded programs.</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 10/24/2017<br>      Modified by: Stephan&nbsp;A&nbsp;Zdancewic</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The lack of memory safety in languages such as C and C++ is a root source of exploitable security vulnerabilities prevalent in more computing infrastructure. This project explored both hardware and software techniques toeliminate such vulnerabilities by enforcing comprehensive memory safety. In bothcases, the technical approach is to associate space bounds and identifiermetadata with pointers, propagate them on pointer operations, and check them onpointer dereferences. Checking the bounds and identifier metadata provides bothprecise, byte-granularity buffer-overflow protection and protection fromuse-after-free errors, even in the presence of reallocations.  This project explored the effectiveness of storing pointer metadata in a disjoint metadata space to provide both comprehensive protection and enhance compatibility with existing code. Our implementations reduce the runtime overhead with hardware extensions that use micro-operations to implement metadata access and checking and a dedicated identifier cache to reduce checking overhead. The hardware extension also eliminates metadata copies via register renaming in the out-of-order core.  Subsequently, we have proposed a set of ISA extensions called WatchdogLite that provides hardware acceleration for a compiler implementation of pointer-based checking. This division of labor between the compiler and the hardware allows for hardware acceleration while using only preexisting architectural registers. By leveraging the compiler to identify pointers, perform check elimination, and insert the new instructions, this approach attains performance similar to prior hardware-intensive approaches without adding any hardware structures for tracking metadata.  During the course of this project, Intel developed Memory Protection Extensions(MPX) and released the ISA specification in 2013. Intel?s MPX extensions are similar to WatchdogLite. Intel?s software implementation---PointerChecker---is similar to SoftBoundCETS. Intel MPX uses pointer-based checking with disjoint metadata, adding new instructions for efficiently accessing the metadata shadowspace, and adding instruction for accelerating bounds checking. In contrast with WatchdogLite, MPX does not include support for accelerating use-after-freechecking. PI Santosh Nagarakatte has collaborated with Intel to explore the addition of use-after-free checking support to Intel MPX.  We also discovered that Intel MPX?s support for incremental deployment of bounds checking results in the loss of comprehensiveness in the presence of insidious type casts from integers to pointers either directly or indirectly through memory. Particularly, any arbitrary pointer manufactured through type casts will be allowed to access any location in memory (even with MPX protection) because(1) the pointer in the metadata space is not updated during integer operations,(2) the pointer loaded and the pointer in the metadata space would mismatch on a metadata load, and (3) the result is an un-bounded pointer. The compiler can identify the occurrence of such type casts either implicitly or explicitly and warn the programmer about them.  During the course of this project, we also explored various other extensions to memory safety. First, we have investigated the impact of compiler optimizations on instrumentation added for memory safety. We have also developed methods tocheck if compiler optimizations can erroneously remove instrumentation added by memory safety transformation. Second, we have also developed a suite of micro-optimizations to reduce the overhead of memory safety checks. Third,enforcing atomicity and race freedom for memory safety instrumentation with multithreaded programs.             Last Modified: 10/24/2017       Submitted by: Stephan A Zdancewic]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
