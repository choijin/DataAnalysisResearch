<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Medium: Collaborative: Breaking the Satisfiability Modulo Theories (SMT) Bottleneck in Symbolic Security Analysis</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2012</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>399816.00</AwardTotalIntnAmount>
<AwardAmount>399816</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The security of our software is critical for consumer confidence, the protection of privacy and valuable intellectual property, and of course national security. Because of our society's increased reliance on software, security breaches can lead to serious personal or corporate losses, and endanger the privacy, liberties, and even the lives of individuals. As threats to software security have become more sophisticated, so too have the techniques and analyses developed to improve it. Symbolic execution has emerged as a fundamental tool for security applications. Its main idea is to run a program using symbolic instead of concrete values: a set of symbols are assigned to the program inputs, and the outputs are expressed as a set of "verification conditions", logical formulas over the input symbols.  A number of successful security analyses use symbolic execution and similar methods to recast security questions about programs as constraint satisfaction problems in some formal logic. Automatic reasoners for that logic can then be used to solve those problems.  In the last few years, solvers based on Satisfiability Modulo Theories (SMT) techniques have become a natural choice in such approaches to security because of their superior performance and automation compared to more traditional theorem provers and their greater generality with respect to ad-hoc tools or propositional satisfiability solvers.&lt;br/&gt;&lt;br/&gt;This collaborative project brings together experts in security and in SMT to pursue two complementary research goals: (i) harness the full power of SMT solvers to improve current security tools based on symbolic analysis; and (ii) design and develop new techniques to address the needs of anticipated future security applications. Specific activities addressing these goals include: collecting challenge benchmark problems from existing security analyses and developing targeted SMT optimizations for these benchmarks; developing appropriate security abstractions in the SMT language used to express security verification conditions; developing logical theories and algorithms for reasoning about character strings in such verification conditions; exposing a general framework for extending the verification condition language; and developing techniques for computing symbolic solution sets for SMT constraints. These activities are expected to (i) significantly increase the flexibility, performance, and reasoning capabilities of SMT solvers in support of security applications; (ii) improve the performance and scalability of current security analyses by leveraging the reasoning power of SMT solvers; and (iii) provide a foundation for new, more powerful, and more expressive security analyses. Overall, this project will help create more scalable and expressive security applications which could have a considerable impact on society as they enable the production of software much more resistant to security attacks.</AbstractNarration>
<MinAmdLetterDate>08/14/2012</MinAmdLetterDate>
<MaxAmdLetterDate>08/14/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1228768</AwardID>
<Investigator>
<FirstName>Clark</FirstName>
<LastName>Barrett</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Clark Barrett</PI_FULL_NAME>
<EmailAddress>barrett@cs.stanford.edu</EmailAddress>
<PI_PHON>6507360822</PI_PHON>
<NSF_ID>000423674</NSF_ID>
<StartDate>08/14/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>New York University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100121019</ZipCode>
<PhoneNumber>2129982121</PhoneNumber>
<StreetAddress>70 WASHINGTON SQUARE S</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>041968306</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>NEW YORK UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041968306</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[New York University]]></Name>
<CityName/>
<StateCode>NY</StateCode>
<ZipCode>100121019</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~399816</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The security of our software is critical for consumer confidence, protection of privacy, protection of valuable intellectual property, and even national security. &nbsp;As threats to software security have become more sophisticated, so too have the techniques developed to ensure security. &nbsp;One technique that has become a fundamental tool in software security is symbolic execution. &nbsp;In this technique, a program is executed symbolically, with the result that it is possible to analyze many different program executions at the same time by using a solver for symbolic constraints.</p> <p>Solvers based on Satisfiability Modulo Theories (SMT) methods are a natural choice in such approaches to security (examples include automatic exploit generation, malware analysis, and input filtering) because of: (i) their superior performance and automation compared to more traditional solvers; and (ii) their greater generality with respect to ad-hoc tools and propositional solvers.In this project, we developed three new theory solvers useful in security analyses.</p> <p>The first is a new theory solver for bitvectors. &nbsp;This theory is at the heart of most program analyses as the theory of bitvectors is used to represent all machine arithmetic operations. &nbsp;Our new theory combines two approaches (called lazy and eager) to get the maximum performance. &nbsp;The implementation in CVC4 has ranked near the top in the annual SMT competitions for the last few years and is being used in security applications in industry (at Google for example).</p> <p>The second is a new theory of character strings. &nbsp;String manipulation is at the heart of several high-profile security attacks, including SQL injection and cross-site scripting attacks. &nbsp;Our new solver for strings can be used to automatically reason about code that might be vulnerable to such attacks. &nbsp;Over the course of the project, the string solver has become increasingly sophisticated. &nbsp;By the end of the project, we could solve all benchmarks in a large suite obtained from a security tool.</p> <p>Finally, we developed a theory solver for finite sets with cardinality. &nbsp;Sets are a key mathematical building block in many abstractions and reasoning systems. &nbsp;By providing a native theory solver for sets that can be combined with other theories (including bitvectors and strings), it is possible to model a wide variety of operations and abstractions.</p> <p>All of these solvers were implemented in the open source SMT solver CVC4 which is available online at http://cvc4.cs.nyu.edu. &nbsp;CVC4 is being used in a large number of academic and industrial projects and applications, including security applications, and the new capabilities developed in this project will directly benefit those efforts.</p><br> <p>            Last Modified: 01/15/2017<br>      Modified by: Clark&nbsp;Barrett</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The security of our software is critical for consumer confidence, protection of privacy, protection of valuable intellectual property, and even national security.  As threats to software security have become more sophisticated, so too have the techniques developed to ensure security.  One technique that has become a fundamental tool in software security is symbolic execution.  In this technique, a program is executed symbolically, with the result that it is possible to analyze many different program executions at the same time by using a solver for symbolic constraints.  Solvers based on Satisfiability Modulo Theories (SMT) methods are a natural choice in such approaches to security (examples include automatic exploit generation, malware analysis, and input filtering) because of: (i) their superior performance and automation compared to more traditional solvers; and (ii) their greater generality with respect to ad-hoc tools and propositional solvers.In this project, we developed three new theory solvers useful in security analyses.  The first is a new theory solver for bitvectors.  This theory is at the heart of most program analyses as the theory of bitvectors is used to represent all machine arithmetic operations.  Our new theory combines two approaches (called lazy and eager) to get the maximum performance.  The implementation in CVC4 has ranked near the top in the annual SMT competitions for the last few years and is being used in security applications in industry (at Google for example).  The second is a new theory of character strings.  String manipulation is at the heart of several high-profile security attacks, including SQL injection and cross-site scripting attacks.  Our new solver for strings can be used to automatically reason about code that might be vulnerable to such attacks.  Over the course of the project, the string solver has become increasingly sophisticated.  By the end of the project, we could solve all benchmarks in a large suite obtained from a security tool.  Finally, we developed a theory solver for finite sets with cardinality.  Sets are a key mathematical building block in many abstractions and reasoning systems.  By providing a native theory solver for sets that can be combined with other theories (including bitvectors and strings), it is possible to model a wide variety of operations and abstractions.  All of these solvers were implemented in the open source SMT solver CVC4 which is available online at http://cvc4.cs.nyu.edu.  CVC4 is being used in a large number of academic and industrial projects and applications, including security applications, and the new capabilities developed in this project will directly benefit those efforts.       Last Modified: 01/15/2017       Submitted by: Clark Barrett]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
