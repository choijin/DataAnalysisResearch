<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER: A Study of the Limitations of High Performance Code Generation in Vectorizing Compilers</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2012</AwardEffectiveDate>
<AwardExpirationDate>09/30/2014</AwardExpirationDate>
<AwardTotalIntnAmount>83376.00</AwardTotalIntnAmount>
<AwardAmount>83376</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Most modern microprocessors support some form of vector operations that allow the same operation to be applied to small vectors of arguments simultaneously.  Studies have shown that use of these instructions can improve the performance of many scientific codes by a factor of 2 or more.  Unfortunately, the state of the art in autovectorization falls far short of this goal, only achieving improvements of 20-30% on the same codes.&lt;br/&gt;&lt;br/&gt;While studies have shown that current autovectorizing compilers do not identify all of the opportunities for vectorization, little is known about why they fail to do so.  The PI will study the problem of mapping between high-level idealized vector code and the idiosyncratic vector instructions found on real hardware.  The PI plans to use the Spiral code generation and autotuning system to generate a large set of test cases for evaluating how well existing autovectorizing compilers manage such mappings.  This research will make it possible to develop better autovectorizing compilers by identifying the program transformations that are required to generate vectorized code for real hardware. The performance benefits of such compilers will improve the performance of applications ranging from multimedia software to scientific computing.</AbstractNarration>
<MinAmdLetterDate>09/26/2012</MinAmdLetterDate>
<MaxAmdLetterDate>09/26/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1251185</AwardID>
<Investigator>
<FirstName>Franz</FirstName>
<LastName>Franchetti</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Franz Franchetti</PI_FULL_NAME>
<EmailAddress>franzf@ece.cmu.edu</EmailAddress>
<PI_PHON>4122688746</PI_PHON>
<NSF_ID>000209896</NSF_ID>
<StartDate>09/26/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Carnegie-Mellon University</Name>
<CityName>PITTSBURGH</CityName>
<ZipCode>152133815</ZipCode>
<PhoneNumber>4122688746</PhoneNumber>
<StreetAddress>5000 Forbes Avenue</StreetAddress>
<StreetAddress2><![CDATA[WQED Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052184116</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CARNEGIE MELLON UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052184116</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Carnegie-Mellon University]]></Name>
<CityName>Pittsburgh</CityName>
<StateCode>PA</StateCode>
<ZipCode>152133815</ZipCode>
<StreetAddress><![CDATA[5000 Forbes Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7329</Code>
<Text>COMPILERS</Text>
</ProgramReference>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~83376</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>SIMD instruction sets (single instruction, multiple data) like Intel&rsquo;s SSE and AVX, ARM&rsquo;s NEON, and PowerPC&rsquo;s AltiVec are pervasive in current microprocessors, and add tremendously to the performance potential and energy efficiency of these processors. Unfortunately, automatic vectorization&mdash;generating vector instructions from standard C or FORTRAN source code&mdash;is challenging. This issue has been researched extensively in the context of traditional vector computers, and then again in the context of graphics cards and now SIMD instruction sets. Compilers have become good in extracting SIMD operations from well-formed code. However, there are gaps in compiler vectorization.</p> <p><strong>Intellectual merit.</strong> Our research in this project shows that there remains a costly and unnecessary gap in automatic vectorization. Humans are able to provide much better vector implementations for a wide range of algorithms than the best vectorising compilers are able to produce. However, combining a vectorising compiler with our automatic performance tuning and code generation system SPIRAL (a system that can automatically generate code variants and try them out) leads to compiler-vectorized code on par with the best human vectorised code for the best found examples. This shows that there is no inherent barrier that prevents compilers from producing the best possible vectorised code. The problem we identified is that the compiler is unable to find the necessary code transformations&mdash;transformations that humans do intuitively and that the code generation and autotuning system SPIRAL is able to automatically perform.</p> <p><strong>Broader impact.</strong> Our research shows that SIMD vector instructions are an important component of modern microprocessors that lead to good performance and power efficiency. Research in compiler vectorization has the potential to overcome the current gap, despite the already expended research effort. We believe that current SIMD extensions are sufficiently different from vectorization targets researched in the past, and thus more research is warranted. The results of this project are used in graduate teaching at Carnegie Mellon University.</p><br> <p>            Last Modified: 06/30/2015<br>      Modified by: Franz&nbsp;Franchetti</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ SIMD instruction sets (single instruction, multiple data) like IntelÆs SSE and AVX, ARMÆs NEON, and PowerPCÆs AltiVec are pervasive in current microprocessors, and add tremendously to the performance potential and energy efficiency of these processors. Unfortunately, automatic vectorization&mdash;generating vector instructions from standard C or FORTRAN source code&mdash;is challenging. This issue has been researched extensively in the context of traditional vector computers, and then again in the context of graphics cards and now SIMD instruction sets. Compilers have become good in extracting SIMD operations from well-formed code. However, there are gaps in compiler vectorization.  Intellectual merit. Our research in this project shows that there remains a costly and unnecessary gap in automatic vectorization. Humans are able to provide much better vector implementations for a wide range of algorithms than the best vectorising compilers are able to produce. However, combining a vectorising compiler with our automatic performance tuning and code generation system SPIRAL (a system that can automatically generate code variants and try them out) leads to compiler-vectorized code on par with the best human vectorised code for the best found examples. This shows that there is no inherent barrier that prevents compilers from producing the best possible vectorised code. The problem we identified is that the compiler is unable to find the necessary code transformations&mdash;transformations that humans do intuitively and that the code generation and autotuning system SPIRAL is able to automatically perform.  Broader impact. Our research shows that SIMD vector instructions are an important component of modern microprocessors that lead to good performance and power efficiency. Research in compiler vectorization has the potential to overcome the current gap, despite the already expended research effort. We believe that current SIMD extensions are sufficiently different from vectorization targets researched in the past, and thus more research is warranted. The results of this project are used in graduate teaching at Carnegie Mellon University.       Last Modified: 06/30/2015       Submitted by: Franz Franchetti]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
