<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Automatic Generation of High Efficiency Graphics Systems</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>03/15/2013</AwardEffectiveDate>
<AwardExpirationDate>02/28/2018</AwardExpirationDate>
<AwardTotalIntnAmount>503914.00</AwardTotalIntnAmount>
<AwardAmount>503914</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05020000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>IIS</Abbreviation>
<LongName>Div Of Information &amp; Intelligent Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Maria Zemankova</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>The next generation of visual computing applications will require graphics systems to execute within a wide range of computing environments (from embedded devices to supercomputers) and be both more powerful and orders of magnitude more efficient than existing systems today. Unfortunately, creating efficient rendering solutions for any one platform or any one class of workloads is currently a laborious, expert-level task whose difficulty discourages innovation in interactive graphics techniques and graphics hardware architecture. In response, the PI is developing technologies that, given knowledge of a virtual scene, a specific rendering task, and parallel hardware platform, can automatically generate an optimized graphics system implementation specialized for this context. The core idea is to develop unifying representations for the large space of algorithmic approaches to key rendering problems such as surface visibility and shading and then to leverage these representations in new intelligent renderer compilation systems that identity efficient algorithms for a given workload and machine context. In this system, selecting appropriate algorithms is as much a part of the renderer compilation process as synthesis of high performance code. Defining new core graphics programming abstractions that embody these parameterized algorithmic spaces, exploring their application scope, and determining what graphics domain knowledge is fundamental to automating graphics system optimization are significant research components of this project. A second component of the project involves modeling and characterizing graphics system behavior in order to guide automated discovery of efficient solutions.&lt;br/&gt;&lt;br/&gt;Graphics system performance is a fundamental enabler of new visual computing applications. In particular, project success stands to catalyze the impact of visual computing in mobile and embedded environments, where photorealistic augmented reality and high-resolution display of information will be transformative to tasks such as navigation, worker training, as well as new forms of digital entertainment and the arts. Success also stands to have cross-disciplinary benefit to the domain of scientific computing, as hardware, software, and compilation technologies developed for graphics acceleration continue to have widespread impact on the advancement of general parallel computing. High-performance visual computing topics will be used as a central component of efforts to modernize parallel computing education. The results of this effort will be available to the public as an on-line textbook and web reference for modern parallel computing. The project web site (http://graphics.cs.cmu.edu/projects/renderergenerator/) provides additional information on the project.</AbstractNarration>
<MinAmdLetterDate>03/21/2013</MinAmdLetterDate>
<MaxAmdLetterDate>02/02/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1253530</AwardID>
<Investigator>
<FirstName>Kayvon</FirstName>
<LastName>Fatahalian</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Kayvon Fatahalian</PI_FULL_NAME>
<EmailAddress>kayvonf@cs.stanford.edu</EmailAddress>
<PI_PHON>6504976043</PI_PHON>
<NSF_ID>000624440</NSF_ID>
<StartDate>03/21/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Carnegie-Mellon University</Name>
<CityName>PITTSBURGH</CityName>
<ZipCode>152133815</ZipCode>
<PhoneNumber>4122688746</PhoneNumber>
<StreetAddress>5000 Forbes Avenue</StreetAddress>
<StreetAddress2><![CDATA[WQED Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052184116</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CARNEGIE MELLON UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052184116</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Carnegie-Mellon University]]></Name>
<CityName>Pittsburgh</CityName>
<StateCode>PA</StateCode>
<ZipCode>152133890</ZipCode>
<StreetAddress><![CDATA[5000 Forbes Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7453</Code>
<Text>GRAPHICS &amp; VISUALIZATION</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>7453</Code>
<Text>GRAPHICS &amp; VISUALIZATION</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0117</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~91748</FUND_OBLG>
<FUND_OBLG>2014~96069</FUND_OBLG>
<FUND_OBLG>2015~100567</FUND_OBLG>
<FUND_OBLG>2016~105295</FUND_OBLG>
<FUND_OBLG>2017~110235</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span id="docs-internal-guid-acdeb439-5b81-0227-9bd6-3a9758ff58d5"> </span></p> <p dir="ltr"><span>Modern real-time graphics systems must simulate complex visual effects, and do so at high frame rates on high-resolution displays. Therefore, this project aimed to develop new graphics programming languages, compiler frameworks, and graphics techniques that enable rapid (and sometimes fully automatic) performance optimization when targeting modern parallel machines. Since modern graphics applications are complex code bases, our efforts also sought to simultaneously preserve or improve the productivity and extensibility of graphics programming platforms.&nbsp; Several of the systems developed in this project have successfully been transferred into daily industry usage settings.</span></p> <p dir="ltr"><span><span> </span></span><span><span> </span></span><span><span> </span></span></p> <p dir="ltr">Rapid Optimization of 3D Rendering Systems:</p> <p dir="ltr">One major thrust of this project asked the question: to what extent can the process of optimizing complex real-time graphics systems be accelerated or automated by new graphics programming languages and compilers? In other words, can graphics systems self optimize? We conducted a number of projects that responded to this question:</p> <p dir="ltr"><span><span> </span></span><span><span> </span></span><span><span> </span></span><span><span> </span></span></p> <p dir="ltr"><span>Adaptive, multi-rate GPU shading: </span><span>&nbsp;We developed GPU graphics pipeline mechanisms for real-time multi-rate shading&mdash;a technique for reducing the cost of surface shading computations based on evaluating different components of the shading function at different spatial frequencies depending on need.</span></p> <p dir="ltr"><span><span> </span></span><span><span> </span></span><span><span> </span></span><span><span> </span></span><span><span> </span></span><span> </span><span><span> </span></span><span> </span><span><span> </span></span><span><span> </span></span></p> <p dir="ltr"><span>Automatic shader level-of-detail via approximate compilation: &nbsp;</span><span>We developed compilation techniques for automatically simplifying 3D graphics shader programs. &nbsp;Our approximating compiler would accept a complex, but expensive to evaluate, shader program as input, then determine which instructions could be removed without significantly changing the visual output of the program for a given scene. This approach simplified shaders in only seconds or minutes, making it plausible for use in shader development workflows.</span></p> <p dir="ltr"><span>Spire: a shading language for enabling rapid exploration of shader optimization choices: </span><span>We developed Spire, a domain-specific language for graphics pipeline programming that provided abstractions for real-time 3D graphics developers to quickly explore the space of critical global program optimization decisions. This space included algorithmic approximations that span CPU/GPU logic, decisions about what values to precompute prior to rendering, and data structures needed to store intermediates during rendering. </span></p> <p>Self-refining games: To automatically specialize the content of graphics applications, we explored the idea of self-refining games, which leverage massive scale precomputation to automatically refine the visual fidelity of their content in response to the actions of users.</p> <p dir="ltr"><span><span> </span></span><span><span> </span></span><span><span> </span></span><span><span> </span></span></p> <p dir="ltr"><span>Autoscheduling Halide: </span></p> <p dir="ltr"><span>&nbsp;</span><span>While the examples above apply to 3D graphics applications, a second thrust of our work focused on achieving high performance in the domain of image processing. We developed an algorithm for automatically scheduling Halide image processing programs onto modern parallel machines and demonstrated that automatically scheduled Halide code was often performance-competitive with the hand-written output of professional programmers. (Halide is a programming language for image processing created at MIT and Google.) &nbsp;The Halide autoscheduler is now part of the open source Halide programming system and maintained by full-time engineers at Google. It can be successfully run on image processing workloads typical of consumer computational photography applications (used in millions of smart phones and in datacenters today). </span></p> <p>Slang: Language Mechanisms for Extensible Real-time Shading Systems</p> <p>The final research thrust of this award addressed the challenge of simultaneously achieving high developer productivity and high performance when implementing the complex shading systems of modern 3D graphics applications. Rather than pursue a domain-specific language solution, we developed Slang, which extends industry standard HLSL with a small set of well-understood programming language constructs that exist in other modern languages (generics with interface constraints, associated types, and interface/structure extensions, parameter blocks). We showed that this combination of features makes it possible to create extensible shader libraries that retain the critical performance benefits of modern 3D graphics implementations (shader code specialization and efficient parameter communication between the CPU and GPU). &nbsp;&nbsp;Slang has now been adopted as the shading language for NVIDIA&rsquo;s Falcor open source research rendering framework, used daily at NVIDIA.  We hope that Slang&rsquo;s key ideas will soon impact the future of industry standard shader programming languages like GLSL and HLSL.</p> <p dir="ltr"><span>In area of education, the PI developed a popular undergraduate parallel computing course that relies heavily on visual computing topics and consumer parallel computing devices as key examples to teach fundamental concepts of efficient parallel processing. Materials from this course have been reused in at least ten universities in the US, Europe, and China. &nbsp;All materials of this course (including lecture videos) are online and available to the public.  The project also supported the development of courses in the area of Visual Computing systems, which bring together students from systems and graphics/vision backgrounds to learn about systems design issues related to visual computing applications.</span></p> <p>&nbsp;</p><br> <p>            Last Modified: 07/02/2018<br>      Modified by: Kayvon&nbsp;Fatahalian</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[   Modern real-time graphics systems must simulate complex visual effects, and do so at high frame rates on high-resolution displays. Therefore, this project aimed to develop new graphics programming languages, compiler frameworks, and graphics techniques that enable rapid (and sometimes fully automatic) performance optimization when targeting modern parallel machines. Since modern graphics applications are complex code bases, our efforts also sought to simultaneously preserve or improve the productivity and extensibility of graphics programming platforms.  Several of the systems developed in this project have successfully been transferred into daily industry usage settings.     Rapid Optimization of 3D Rendering Systems: One major thrust of this project asked the question: to what extent can the process of optimizing complex real-time graphics systems be accelerated or automated by new graphics programming languages and compilers? In other words, can graphics systems self optimize? We conducted a number of projects that responded to this question:      Adaptive, multi-rate GPU shading:  We developed GPU graphics pipeline mechanisms for real-time multi-rate shading&mdash;a technique for reducing the cost of surface shading computations based on evaluating different components of the shading function at different spatial frequencies depending on need.            Automatic shader level-of-detail via approximate compilation:  We developed compilation techniques for automatically simplifying 3D graphics shader programs.  Our approximating compiler would accept a complex, but expensive to evaluate, shader program as input, then determine which instructions could be removed without significantly changing the visual output of the program for a given scene. This approach simplified shaders in only seconds or minutes, making it plausible for use in shader development workflows. Spire: a shading language for enabling rapid exploration of shader optimization choices: We developed Spire, a domain-specific language for graphics pipeline programming that provided abstractions for real-time 3D graphics developers to quickly explore the space of critical global program optimization decisions. This space included algorithmic approximations that span CPU/GPU logic, decisions about what values to precompute prior to rendering, and data structures needed to store intermediates during rendering.   Self-refining games: To automatically specialize the content of graphics applications, we explored the idea of self-refining games, which leverage massive scale precomputation to automatically refine the visual fidelity of their content in response to the actions of users.      Autoscheduling Halide:   While the examples above apply to 3D graphics applications, a second thrust of our work focused on achieving high performance in the domain of image processing. We developed an algorithm for automatically scheduling Halide image processing programs onto modern parallel machines and demonstrated that automatically scheduled Halide code was often performance-competitive with the hand-written output of professional programmers. (Halide is a programming language for image processing created at MIT and Google.)  The Halide autoscheduler is now part of the open source Halide programming system and maintained by full-time engineers at Google. It can be successfully run on image processing workloads typical of consumer computational photography applications (used in millions of smart phones and in datacenters today).   Slang: Language Mechanisms for Extensible Real-time Shading Systems  The final research thrust of this award addressed the challenge of simultaneously achieving high developer productivity and high performance when implementing the complex shading systems of modern 3D graphics applications. Rather than pursue a domain-specific language solution, we developed Slang, which extends industry standard HLSL with a small set of well-understood programming language constructs that exist in other modern languages (generics with interface constraints, associated types, and interface/structure extensions, parameter blocks). We showed that this combination of features makes it possible to create extensible shader libraries that retain the critical performance benefits of modern 3D graphics implementations (shader code specialization and efficient parameter communication between the CPU and GPU).   Slang has now been adopted as the shading language for NVIDIA?s Falcor open source research rendering framework, used daily at NVIDIA.  We hope that Slang?s key ideas will soon impact the future of industry standard shader programming languages like GLSL and HLSL. In area of education, the PI developed a popular undergraduate parallel computing course that relies heavily on visual computing topics and consumer parallel computing devices as key examples to teach fundamental concepts of efficient parallel processing. Materials from this course have been reused in at least ten universities in the US, Europe, and China.  All materials of this course (including lecture videos) are online and available to the public.  The project also supported the development of courses in the area of Visual Computing systems, which bring together students from systems and graphics/vision backgrounds to learn about systems design issues related to visual computing applications.          Last Modified: 07/02/2018       Submitted by: Kayvon Fatahalian]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
