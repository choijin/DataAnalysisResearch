<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF: Small: Local Computation Algorithms</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2012</AwardEffectiveDate>
<AwardExpirationDate>08/31/2014</AwardExpirationDate>
<AwardTotalIntnAmount>250000.00</AwardTotalIntnAmount>
<AwardAmount>250000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Balasubramanian Kalyanasundaram</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>The ubiquitousness of massive data sets presents&lt;br/&gt;great challenges.  The difficulty of dealing with massive data&lt;br/&gt;sets is especially formidable when attempting to&lt;br/&gt;solve computational problems in which both the inputs&lt;br/&gt;and the outputs to the computation are large.&lt;br/&gt;In such a situation, it would be useful if one could find&lt;br/&gt;faster ways of computing just the portion of the output that is required&lt;br/&gt;by the user.&lt;br/&gt;&lt;br/&gt;This project aims to study "local computation algorithms",&lt;br/&gt;namely algorithms that quickly compute only the portions of the&lt;br/&gt;output that are required by the user,&lt;br/&gt;without performing the full computation.&lt;br/&gt;In particular, local computation algorithms&lt;br/&gt;view only a miniscule portion of the input.&lt;br/&gt;The PI considers a broad based approach, studying the application of&lt;br/&gt;local computation algorithms to a range of problems and&lt;br/&gt;settings within algorithm design.&lt;br/&gt;The focus of this research is on the question of when local computations&lt;br/&gt;can be done in time that is sub-linear in the size of the input and output.&lt;br/&gt;The proposed research will  develop techniques for constructing&lt;br/&gt;such algorithms and for understanding when such algorithms are&lt;br/&gt;not possible.&lt;br/&gt;&lt;br/&gt;The project will leverage known results from sub-linear time&lt;br/&gt;algorithms, which for the most part have focused on the somewhat&lt;br/&gt;different setting of  computational&lt;br/&gt;problems in which the inputs are large but the outputs are small.&lt;br/&gt;In addition, the project will investigate well-studied&lt;br/&gt;classes of algorithmic techniques and focus on modifying them for&lt;br/&gt;use in this new setting.   Such classes include algorithmic techniques&lt;br/&gt;first developed for parallel and distributed algorithms, as well as the&lt;br/&gt;extensively used greedy method.&lt;br/&gt;Problems from combinatorial optimization, graph theory and compressibility&lt;br/&gt;of strings  will be studied.</AbstractNarration>
<MinAmdLetterDate>08/01/2012</MinAmdLetterDate>
<MaxAmdLetterDate>08/01/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1217423</AwardID>
<Investigator>
<FirstName>Ronitt</FirstName>
<LastName>Rubinfeld</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ronitt Rubinfeld</PI_FULL_NAME>
<EmailAddress>ronitt@csail.mit.edu</EmailAddress>
<PI_PHON>6172530884</PI_PHON>
<NSF_ID>000322655</NSF_ID>
<StartDate>08/01/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[NE18-901]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001425594</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>MASSACHUSETTS INSTITUTE OF TECHNOLOGY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001425594</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Massachusetts Institute of Technology]]></Name>
<CityName>Cambridge</CityName>
<StateCode>MA</StateCode>
<ZipCode>021394307</ZipCode>
<StreetAddress><![CDATA[77 Massachusetts Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7796</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7926</Code>
<Text>ALGORITHMS</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~250000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><pre>Classical models of algorithmic analysis assume that the algorithm reads an input,performs a computation and writes the answer to an output tape.&nbsp;&nbsp; <br />On massive data sets, such computations may not be feasible, as both the input and output may be too large for a single processor to process.&nbsp; <br />In such a situation, it would be useful if one could find faster ways of computing just the portion of the output that is required<br />by the user. <br /><br />In this project, we investigate the model of "local computation algorithms", which support queries such that after each query by the user to a specified location, the local computation algorithm quickly outputs the value of the output at that location (without knowledge of future requests). When more than one legal output exists for an input,&nbsp; <br />the local computation algorithm&nbsp; must answer queries in such a way that is consistent with a single legal output over time. For a given problem, the hope is that the query time and<br />space complexity of a local computation&nbsp; algorithm&nbsp; is proportional to the amount of the solution that is requested by the user. That is, the time and<br />space complexity should be sublinear in the size of the input and output to the problem, and should not require storing the history of all previous queries and answers.&nbsp;&nbsp; <br />It is furthermore desirable that the techniques are amenable to parallelization, that is, that different copies of the local computation algorithms can run, accessing the same<br />input, but without requiring coordinationg among their answers. Local computation algorithms satisfying these properties are useful for performing<br />cloud computations on large datasets.<br /><br />This research project develops standard techniques for constructing local computation algorithms.&nbsp; Much of the focus is on<br />combinatorial optimization problems such as algorithms for maintaining connectivity and low diameter of networks, and finding sparse connected subgraphs.&nbsp; In addition,<br />algorithms for locally decompressing data and correcting sample data are developed. <br /> </pre><br> <p>            Last Modified: 10/14/2014<br>      Modified by: Ronitt&nbsp;Rubinfeld</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Classical models of algorithmic analysis assume that the algorithm reads an input,performs a computation and writes the answer to an output tape.    On massive data sets, such computations may not be feasible, as both the input and output may be too large for a single processor to process.   In such a situation, it would be useful if one could find faster ways of computing just the portion of the output that is required by the user.   In this project, we investigate the model of "local computation algorithms", which support queries such that after each query by the user to a specified location, the local computation algorithm quickly outputs the value of the output at that location (without knowledge of future requests). When more than one legal output exists for an input,   the local computation algorithm  must answer queries in such a way that is consistent with a single legal output over time. For a given problem, the hope is that the query time and space complexity of a local computation  algorithm  is proportional to the amount of the solution that is requested by the user. That is, the time and space complexity should be sublinear in the size of the input and output to the problem, and should not require storing the history of all previous queries and answers.    It is furthermore desirable that the techniques are amenable to parallelization, that is, that different copies of the local computation algorithms can run, accessing the same input, but without requiring coordinationg among their answers. Local computation algorithms satisfying these properties are useful for performing cloud computations on large datasets.  This research project develops standard techniques for constructing local computation algorithms.  Much of the focus is on combinatorial optimization problems such as algorithms for maintaining connectivity and low diameter of networks, and finding sparse connected subgraphs.  In addition, algorithms for locally decompressing data and correcting sample data are developed.          Last Modified: 10/14/2014       Submitted by: Ronitt Rubinfeld]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
