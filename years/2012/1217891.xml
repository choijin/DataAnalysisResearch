<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Collaborative Research: Reusable Tools for Formal Modeling</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2012</AwardEffectiveDate>
<AwardExpirationDate>07/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>218710.00</AwardTotalIntnAmount>
<AwardAmount>218710</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Recent advances in program verification show that we are on the verge of being able to prove correctness of safety and security critical software systems. But the proofs only establish correctness with respect to a model of the underlying processor on which the code executes.  Unfortunately, the community lacks high-fidelity, carefully tested specifications of widely-used processors, such as Intel's x86 family of processors. This severely limits efforts in making software reliable and secure, from software assurance to malware analysis to sandboxing technologies. The goal of this project is to provide tools for building, reasoning about, and validating models of widely-used processors.  The proposed research will result in public specifications of common processors, which will benefit a wide range of software applications. It will help improve the dependability and security of critical software applications.&lt;br/&gt; &lt;br/&gt;The investigators' approach to building processor models is carefully designed to support reuse of components across different architectures and different applications.  In particular, they propose to formalize two domain-specific languages that will make it easy to specify decoders and instruction semantics.  The tools for these languages will include support for efficient execution so that the models can be tested against implementations.  To demonstrate the efficacy of these tools, the investigators will build and validate models of both the x86 and ARM families of processors.  They will also investigate applications of these models by building correctness proofs of verifiers for inlined reference monitors and by integrating them as the target languages of a verified compiler. The investigators plan to expend efforts on building a community of researchers for formal processor models and to involve this community to give feedback, improve, and use the models. The project will also provide excellent opportunities for training undergraduate students and for developing new curriculum materials on formal methods.</AbstractNarration>
<MinAmdLetterDate>07/10/2012</MinAmdLetterDate>
<MaxAmdLetterDate>07/10/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1217891</AwardID>
<Investigator>
<FirstName>J. Gregory</FirstName>
<LastName>Morrisett</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>J. Gregory Morrisett</PI_FULL_NAME>
<EmailAddress>greg.morrisett@cornell.edu</EmailAddress>
<PI_PHON>6174959526</PI_PHON>
<NSF_ID>000347145</NSF_ID>
<StartDate>07/10/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Harvard University</Name>
<CityName>Cambridge</CityName>
<ZipCode>021385369</ZipCode>
<PhoneNumber>6174955501</PhoneNumber>
<StreetAddress>1033 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[5th Floor]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>082359691</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PRESIDENT AND FELLOWS OF HARVARD COLLEGE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001963263</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Harvard University]]></Name>
<CityName>Cambridge</CityName>
<StateCode>MA</StateCode>
<ZipCode>021382933</ZipCode>
<StreetAddress><![CDATA[29 Oxford Street]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~218710</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Safety and security-critical software is incredibly hard to build without introducing bugs that can lead to failures or attacks. &nbsp;One promising approach to solving this problem is to build a formal proof (a mathematical audit trail) that the software does not have bugs, and which can be independently checked by a third-party.</p> <p>To realize this goal, we need formal models of the machines on which the software is running. &nbsp;The primary goal of this project is to provide a framework for specifying these models, and to automatically generate tools that can be used for building robust software that is provably correct. &nbsp;We used this framework to provide a model of the most widely used machine architecture (the Intel x86) and used this model to prove the correctness of some security-critical tools that Google uses to secure its Chrome web-browser. &nbsp;</p> <p>Of course, these proofs of correctness or security are only as good as the models. &nbsp;That is, a bug in the model could invalidate the entire proof. &nbsp;Thus, a big component of this project was validating the model against real machines. &nbsp;In turn, this required us to build efficient (but still proven correct) tools for executing the model so we could compare it to real machines. &nbsp;Along the way, we discovered new techniques for building efficient, but provably correct interpreters that should be usable in a much broader range of contexts. &nbsp;</p><br> <p>            Last Modified: 08/12/2015<br>      Modified by: J. Gregory&nbsp;Morrisett</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Safety and security-critical software is incredibly hard to build without introducing bugs that can lead to failures or attacks.  One promising approach to solving this problem is to build a formal proof (a mathematical audit trail) that the software does not have bugs, and which can be independently checked by a third-party.  To realize this goal, we need formal models of the machines on which the software is running.  The primary goal of this project is to provide a framework for specifying these models, and to automatically generate tools that can be used for building robust software that is provably correct.  We used this framework to provide a model of the most widely used machine architecture (the Intel x86) and used this model to prove the correctness of some security-critical tools that Google uses to secure its Chrome web-browser.    Of course, these proofs of correctness or security are only as good as the models.  That is, a bug in the model could invalidate the entire proof.  Thus, a big component of this project was validating the model against real machines.  In turn, this required us to build efficient (but still proven correct) tools for executing the model so we could compare it to real machines.  Along the way, we discovered new techniques for building efficient, but provably correct interpreters that should be usable in a much broader range of contexts.         Last Modified: 08/12/2015       Submitted by: J. Gregory Morrisett]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
