<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:  Large: Collaborative Research:  Science and Tools for Software Evolution</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2012</AwardEffectiveDate>
<AwardExpirationDate>06/30/2018</AwardExpirationDate>
<AwardTotalIntnAmount>365232.00</AwardTotalIntnAmount>
<AwardAmount>365232</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Successful software constantly evolves. Most programmers work on projects they did not start. Most companies spend more on maintaining old systems than on building new ones. This is good, because it shows that companies build software that is worth keeping and maintaining, but it also means that change is the heart of software development. Most programming tools treat change at a very low level: programmers make most changes with text editors, and tools tend to focus on changes to lines of text, and although programming is predominantly about change, contemporary tools do not provide direct support for understanding or facilitating change. This makes programming more expensive, time-consuming, and error-prone than it should be. This research project will develop a change-oriented programming environment (COPE) that supports change by putting transformations at the center of software development. COPE will enable both average and expert programmers to write, script, modify, and replay their own transformations. COPE will enable programmers to think about programs as compositions of transformations, and to automate as many of these transformations as possible. Characterizing software development in terms of transformations is an essential step to take software engineering from manual development to automated (or semi-automated) development of software.&lt;br/&gt;&lt;br/&gt;By enabling programmers to express their programming tasks as program transformations, COPE will This alter the way programmers think about, teach, create, reuse, and understand programs. Specifically, COPE considers five activities: (1) analyze what changes programmers typically make and how they perceive, recall, and communicate changes, (2) automate transformations to make it easier to apply and script changes, (3) develop tools that compose and manipulate transformations to make it easier to reuse them, (4) integrate transformations with version control to provide better ways for archiving and understanding changes, and (5) develop tools that infer higher-level transformations from lower-level changes. COPE will deliver a rich transformation-aware toolset that synergistically integrates all these activities. COPE aims to (a) change the way people program, (b) create a platform for research for future research, and (c) produce results that ultimately will become standard software development practice. The PIs will disseminate the results through presentations, books, publications, open-source code, industrial collaborations, and educational activities. A version of COPE will be used to revamp the software engineering curriculum at the University of Illinois and the University of Texas to emphasize the science of change in large code bases.</AbstractNarration>
<MinAmdLetterDate>06/27/2012</MinAmdLetterDate>
<MaxAmdLetterDate>08/27/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1212683</AwardID>
<Investigator>
<FirstName>Don</FirstName>
<LastName>Batory</LastName>
<PI_MID_INIT>S</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Don S Batory</PI_FULL_NAME>
<EmailAddress>batory@cs.utexas.edu</EmailAddress>
<PI_PHON>0000000055</PI_PHON>
<NSF_ID>000279420</NSF_ID>
<StartDate>06/27/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Texas at Austin</Name>
<CityName>Austin</CityName>
<ZipCode>787595316</ZipCode>
<PhoneNumber>5124716424</PhoneNumber>
<StreetAddress>3925 W Braker Lane, Ste 3.340</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>170230239</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF TEXAS AT AUSTIN</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042000273</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Texas at Austin]]></Name>
<CityName>Austin</CityName>
<StateCode>TX</StateCode>
<ZipCode>787137726</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>21</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX21</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7925</Code>
<Text>LARGE PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~91308</FUND_OBLG>
<FUND_OBLG>2013~91308</FUND_OBLG>
<FUND_OBLG>2014~182616</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>There are many repetitive refactoring tasks that require programming. Such programs, called <strong>scripts</strong>, are compound refactorings written as methods (typically with loops) invoking IDE primitive refactorings and other scripts to accomplish a task.&nbsp; Example: 18 out of 24 Gang-of-Four design patterns can be scripted as short methods, and there are many variations of each pattern and each variation can be scripted. Scripts should be invoked just as primitive refactorings in an IDE's interface. &nbsp;Scripting is surprisingly not supported by any major IDE today.&nbsp; A primary goal of the COPE project was to make program transformations (in our case, refactorings) first-class &ldquo;entities&rdquo; in IDEs. Our sub-project produced 3 significant results to make this so.</p> <p>First, a practical organization for a basis set of refactorings was developed.&nbsp; It used a DOM (Document Object Model) for ASTs (Abstract Syntax Trees) of Java programs.&nbsp; Not only can information be recovered about packages, their classes and interfaces, their methods, fields, etc. through AST reflection, OO refactorings become methods of AST DOMs for altering programs.</p> <p>In an ICSME 2015 paper, we presented an Eclipse plug-in to demonstrate the practicality of AST-DOMs.&nbsp; Leveraging existing Eclipse refactorings, we were able to script 18 of 24 Gang-of-Four design patterns. Each script was a Java method no more than 25 LOC which we showed to be simple enough for undergraduates to write.&nbsp; One script to add a visitor to a program with a hierarchy of 300 classes took 298 seconds to execute 554 refactorings, which we believe is a world record. &nbsp;We learned that the Eclipse refactoring engine is slow, extraordinarily buggy, and its refactorings were never designed to be scripted &ndash; we had to repair existing refactorings to make them usable.&nbsp; Our conclusion was that a new refactoring engine was needed to proceed.</p> <p>Second, we conceived a radically new way to implement refactoring engines.&nbsp; The standard way uses a program transformation system to manipulate ASTs.&nbsp; We used pretty-print methods and a non-persistent main-memory database to achieve the same effect.&nbsp; Our database encodes the basic elements and relationships of an AST-DOM.&nbsp; For every package, every class and interface, every method and field is a distinct tuple in our database.&nbsp; Primitive refactorings are simply database updates.&nbsp; For example, we store the name of a method in a tuple for that method in the database.&nbsp; Renaming a method merely updates the method&rsquo;s name field.&nbsp; To move a method from one class to another, we update the pointer of the method&rsquo;s tuple to reference the newly enclosing class.&nbsp; The AST <strong>never changes</strong>.&nbsp; When an AST is pretty-printed, it gets element names, locations, etc. from the database.</p> <p>In an ICSE 2016 paper, we presented this result.&nbsp; Our refactoring engine, called R3, ran 10x faster than Eclipse to accomplish the same tasks. R3 encoded the same precondition checks that Eclipse used. Our world-record 554 refactoring script took 2.2 seconds to execute (a 140x speed-up).&nbsp; Our scripts from our previous paper were unchanged.&nbsp; And R3&rsquo;s codebase was&nbsp; a mere 4K LOC Java total.&nbsp; Which means R3 ideas can be easily implemented for other&nbsp; OO&nbsp; languages and is tiny compared to its program transformation system counterpart (hundreds of thousands of lines).</p> <p>Third, until our work, there was no tool support for refactoring Java SPLs (Software Product Lines).&nbsp; The main reason is that conventional SPL tooling relies on C-preprocessors or their equivalent; refactorings require ASTs.&nbsp; We generalized R3 to support the refactoring of Java SPL codebases; our tool is called X15. In general, an SPL is a program family.&nbsp; A particular program is identified by a configuration &ndash; a list of features that uniquely identifies that program in the family. We used a Java custom annotation to encode a configuration file.&nbsp; Java custom annotations replaced preprocessor directives.Namely each package, class, interface, method, and field of the codebase was annotated by a boolean predicate of features to indicate when that element is to appear in a program.&nbsp; Configuration-dependent code blocks were wrapped by if-(feature-predicate) statements. Further, refactoring preconditions were modified to account for configuration-dependency of program elements and codeblocks, as a single SPL refactoring modifies a subfamily of SPL programs..</p> <p>In an SPLC 2017 paper, we presented X15.&nbsp; We showed that &nbsp;X15 is fast: even with the overhead required for SPL constraint checking. Our 554 refactoring example took 4.8 seconds.&nbsp; X15 is tiny about 10K lines of code. And all of our R3 scripts for non-SPL codebases could be used in an SPL context.&nbsp; In effect, refactorings are agnostic to the presence or absence of features.&nbsp; And finally, we have an algebraic proof of correctness for X15, using prior algebraic laws that were known to hold for SPL program construction.</p> <p>We believe our work makes a significant advance in practical tooling for OO refactorings on a broad scale.</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/29/2018<br>      Modified by: Don&nbsp;S&nbsp;Batory</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ There are many repetitive refactoring tasks that require programming. Such programs, called scripts, are compound refactorings written as methods (typically with loops) invoking IDE primitive refactorings and other scripts to accomplish a task.  Example: 18 out of 24 Gang-of-Four design patterns can be scripted as short methods, and there are many variations of each pattern and each variation can be scripted. Scripts should be invoked just as primitive refactorings in an IDE's interface.  Scripting is surprisingly not supported by any major IDE today.  A primary goal of the COPE project was to make program transformations (in our case, refactorings) first-class "entities" in IDEs. Our sub-project produced 3 significant results to make this so.  First, a practical organization for a basis set of refactorings was developed.  It used a DOM (Document Object Model) for ASTs (Abstract Syntax Trees) of Java programs.  Not only can information be recovered about packages, their classes and interfaces, their methods, fields, etc. through AST reflection, OO refactorings become methods of AST DOMs for altering programs.  In an ICSME 2015 paper, we presented an Eclipse plug-in to demonstrate the practicality of AST-DOMs.  Leveraging existing Eclipse refactorings, we were able to script 18 of 24 Gang-of-Four design patterns. Each script was a Java method no more than 25 LOC which we showed to be simple enough for undergraduates to write.  One script to add a visitor to a program with a hierarchy of 300 classes took 298 seconds to execute 554 refactorings, which we believe is a world record.  We learned that the Eclipse refactoring engine is slow, extraordinarily buggy, and its refactorings were never designed to be scripted &ndash; we had to repair existing refactorings to make them usable.  Our conclusion was that a new refactoring engine was needed to proceed.  Second, we conceived a radically new way to implement refactoring engines.  The standard way uses a program transformation system to manipulate ASTs.  We used pretty-print methods and a non-persistent main-memory database to achieve the same effect.  Our database encodes the basic elements and relationships of an AST-DOM.  For every package, every class and interface, every method and field is a distinct tuple in our database.  Primitive refactorings are simply database updates.  For example, we store the name of a method in a tuple for that method in the database.  Renaming a method merely updates the method?s name field.  To move a method from one class to another, we update the pointer of the method?s tuple to reference the newly enclosing class.  The AST never changes.  When an AST is pretty-printed, it gets element names, locations, etc. from the database.  In an ICSE 2016 paper, we presented this result.  Our refactoring engine, called R3, ran 10x faster than Eclipse to accomplish the same tasks. R3 encoded the same precondition checks that Eclipse used. Our world-record 554 refactoring script took 2.2 seconds to execute (a 140x speed-up).  Our scripts from our previous paper were unchanged.  And R3?s codebase was  a mere 4K LOC Java total.  Which means R3 ideas can be easily implemented for other  OO  languages and is tiny compared to its program transformation system counterpart (hundreds of thousands of lines).  Third, until our work, there was no tool support for refactoring Java SPLs (Software Product Lines).  The main reason is that conventional SPL tooling relies on C-preprocessors or their equivalent; refactorings require ASTs.  We generalized R3 to support the refactoring of Java SPL codebases; our tool is called X15. In general, an SPL is a program family.  A particular program is identified by a configuration &ndash; a list of features that uniquely identifies that program in the family. We used a Java custom annotation to encode a configuration file.  Java custom annotations replaced preprocessor directives.Namely each package, class, interface, method, and field of the codebase was annotated by a boolean predicate of features to indicate when that element is to appear in a program.  Configuration-dependent code blocks were wrapped by if-(feature-predicate) statements. Further, refactoring preconditions were modified to account for configuration-dependency of program elements and codeblocks, as a single SPL refactoring modifies a subfamily of SPL programs..  In an SPLC 2017 paper, we presented X15.  We showed that  X15 is fast: even with the overhead required for SPL constraint checking. Our 554 refactoring example took 4.8 seconds.  X15 is tiny about 10K lines of code. And all of our R3 scripts for non-SPL codebases could be used in an SPL context.  In effect, refactorings are agnostic to the presence or absence of features.  And finally, we have an algebraic proof of correctness for X15, using prior algebraic laws that were known to hold for SPL program construction.  We believe our work makes a significant advance in practical tooling for OO refactorings on a broad scale.             Last Modified: 09/29/2018       Submitted by: Don S Batory]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
