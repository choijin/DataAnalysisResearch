<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Solving the Search for Relevant Code in Large Repositories with Lightweight Specifications</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2012</AwardEffectiveDate>
<AwardExpirationDate>07/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>449033.00</AwardTotalIntnAmount>
<AwardAmount>449033</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Searching for relevant code is a common task among programmers, one that is becoming more crucial to their productivity as open code repositories grow in size and programmers have the  opportunity to reuse the resources therein. Yet, the code search tools for programmers to leverage  such massive repositories have barely evolved in the last decade. Programmers still search by specifying keywords, an approach that may perform very inconsistently as it depends on the programmer's ability to provide terms that match how the programs in the repository are implemented or documented. This is problematic because a slightly wrong keyword could miss relevant results and return mostly spurious results, reducing programmer's productivity.&lt;br/&gt;&lt;br/&gt;This research aims to address these limitations by exploring a code search that is novel in two aspects. First, it allows programmers to search for code by specifying desired code behavior in the form of inputs and outputs. This removes the need for the programmer to imagine how the solution to a problem may have been implemented, and instead the programmer can concentrate on defining what the software should do. Second, given the inputs and outputs describing the desired behavior and the set of programs in a code repository, both automatically encoded as constraints, the proposed approach employs a constraints solver to identify what programs in the repository could satisfy the programmers' specifications, effectively solving the search. This guarantees the search results behave as specified. Developing this approach requires tackling several fundamental challenges including the definition of mappings to automatically and efficiently encode programs as constraints so that solvers can find suitable solutions. Systematic strategies must also be developed to refine the programmers' specifications when they are too weak and return too many matches, and to relax the constraints in order to find partial matches when exact ones are not available. Techniques to support the composition of partial matches will also be necessary to scale the approach to larger and more diverse search queries. Last, infrastructure must be built and studies conducted to determine whether the proposed approach can be cost-effective in practice.  Use of these techniques will change the way programmers operate, directly impacting their productivity by enabling them to truly leverage existing code in increasingly rich code repositories.</AbstractNarration>
<MinAmdLetterDate>08/01/2012</MinAmdLetterDate>
<MaxAmdLetterDate>12/19/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1218265</AwardID>
<Investigator>
<FirstName>Sebastian</FirstName>
<LastName>Elbaum</LastName>
<PI_MID_INIT>G</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Sebastian G Elbaum</PI_FULL_NAME>
<EmailAddress>selbaum@virginia.edu</EmailAddress>
<PI_PHON>4342435213</PI_PHON>
<NSF_ID>000412723</NSF_ID>
<StartDate>08/01/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Nebraska-Lincoln</Name>
<CityName>Lincoln</CityName>
<ZipCode>685031435</ZipCode>
<PhoneNumber>4024723171</PhoneNumber>
<StreetAddress>151 Prem S. Paul Research Center</StreetAddress>
<StreetAddress2><![CDATA[2200 Vine St]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Nebraska</StateName>
<StateCode>NE</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NE01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>555456995</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>BOARD OF REGENTS OF THE UNIVERSITY OF NEBRASKA</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>068662618</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Nebraska-Lincoln]]></Name>
<CityName/>
<StateCode>NE</StateCode>
<ZipCode>685880115</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Nebraska</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NE01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~449033</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This project investigated and developed approaches that help software engineers find relevant code in a repository more cost-effectively. The primary outcomes were:</p> <p>&nbsp;1) A series of studies providing a greater understanding of how software developers use code search engines, how much they rely on them, and how they fit in their workflow. We found that <strong>code search is increasingly becoming an essential tool for engineers and is entrenched in their workflow</strong> as they attempt to accelerate the software development process by tapping into a growing number of code repositories with billions of lines of code. One of the studies was conducted with Google developers, through a collaboration facilitated by the project, showing the broader impact of the project in connecting with industry.</p> <p>2) A family of automated techniques that lay the foundations to <strong>enable software developers search for code by providing examples of the inputs and outputs the desired program should produce</strong> (see attached example). This constitutes a major shift from traditional code search which requires for programmers to use keywords, which are often ineffective to find desired programs as their implementation may not include the chosen keywords. The techniques developed delineate the principles for encoding program fragments from repositories as constraints, and then using constraint solvers to check whether those programs satisfy the provided input and output samples. &nbsp;The techniques also include operators to relax or refine the input and outputs to find approximate matches, and ranking schemes for the matching programs. The techniques were prototyped and integrated in a toolset.</p> <p>3) A series of studies showing the <strong>viability of the developed techniques on three programming languages, exploring their generality, utility, and trade-offs</strong>. The results indicated that the approach was effective at finding relevant code, could be used on its own or to filter the results from keyword-based search engines to increase their precision, and was adaptable to find approximate matches when exact matches did not already exist. These gains in precision and flexibility came at the cost of performance, for which underlying factors and mitigation strategies were identified.</p> <p>&nbsp;4) A series of <strong>techniques extensions to apply them to other software engineering sub-domains</strong>. Most notably, the proposed techniques have been successfully adapted and used to enable improvements in automated code repair, explored for impact analysis, and prototyped in the automatic synthesis of data wrangling programs. This showed another dimension of broader potential impact of the techniques created.</p> <p>5) A study showing the <strong>misalignments between the automated program analysis techniques proposed by researchers and their implementation as tools</strong>. These techniques often build on top of, and are compared against, existing tools that realize previously published techniques. The underlying assumption is that existing tools correctly represent the techniques they implement and the state of the art, which is often not the case. Our examination found that the strong research emphasis on introducing "new&rdquo; techniques may lead to missed opportunities for progress, an accretion of artifact complexity, and questionable research conclusions.</p> <p>6) A group of <strong>nine graduate and three undergraduate students received specialized training in software development techniques and tools associated with testing and analysis</strong>. Five of them attended a conference in their research area. One of the graduated students is now a faculty member at another university, and one of the undergraduate students joined graduate school to continue his career in this area.</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/15/2016<br>      Modified by: Sebastian&nbsp;G&nbsp;Elbaum</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Image         </div> <div class="galControls onePhoto" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation onePhoto" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2016/1218265/1218265_10196302_1473954900080_example--rgov-214x142.jpg" original="/por/images/Reports/POR/2016/1218265/1218265_10196302_1473954900080_example--rgov-800width.jpg" title="Syntactic vs Semantic Code Searches"><img src="/por/images/Reports/POR/2016/1218265/1218265_10196302_1473954900080_example--rgov-66x44.jpg" alt="Syntactic vs Semantic Code Searches"></a> <div class="imageCaptionContainer"> <div class="imageCaption">Syntactic vs Semantic Code Searches. Syntactic code searches require keywords. Semantic code searches requires an input and output, offering an alternative way of searching for code.</div> <div class="imageCredit">Sebastian Elbaum and Katie Stolee</div> <div class="imagePermisssions">Copyrighted</div> <div class="imageSubmitted">Sebastian&nbsp;G&nbsp;Elbaum</div> <div class="imageTitle">Syntactic vs Semantic Code Searches</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This project investigated and developed approaches that help software engineers find relevant code in a repository more cost-effectively. The primary outcomes were:   1) A series of studies providing a greater understanding of how software developers use code search engines, how much they rely on them, and how they fit in their workflow. We found that code search is increasingly becoming an essential tool for engineers and is entrenched in their workflow as they attempt to accelerate the software development process by tapping into a growing number of code repositories with billions of lines of code. One of the studies was conducted with Google developers, through a collaboration facilitated by the project, showing the broader impact of the project in connecting with industry.  2) A family of automated techniques that lay the foundations to enable software developers search for code by providing examples of the inputs and outputs the desired program should produce (see attached example). This constitutes a major shift from traditional code search which requires for programmers to use keywords, which are often ineffective to find desired programs as their implementation may not include the chosen keywords. The techniques developed delineate the principles for encoding program fragments from repositories as constraints, and then using constraint solvers to check whether those programs satisfy the provided input and output samples.  The techniques also include operators to relax or refine the input and outputs to find approximate matches, and ranking schemes for the matching programs. The techniques were prototyped and integrated in a toolset.  3) A series of studies showing the viability of the developed techniques on three programming languages, exploring their generality, utility, and trade-offs. The results indicated that the approach was effective at finding relevant code, could be used on its own or to filter the results from keyword-based search engines to increase their precision, and was adaptable to find approximate matches when exact matches did not already exist. These gains in precision and flexibility came at the cost of performance, for which underlying factors and mitigation strategies were identified.   4) A series of techniques extensions to apply them to other software engineering sub-domains. Most notably, the proposed techniques have been successfully adapted and used to enable improvements in automated code repair, explored for impact analysis, and prototyped in the automatic synthesis of data wrangling programs. This showed another dimension of broader potential impact of the techniques created.  5) A study showing the misalignments between the automated program analysis techniques proposed by researchers and their implementation as tools. These techniques often build on top of, and are compared against, existing tools that realize previously published techniques. The underlying assumption is that existing tools correctly represent the techniques they implement and the state of the art, which is often not the case. Our examination found that the strong research emphasis on introducing "new" techniques may lead to missed opportunities for progress, an accretion of artifact complexity, and questionable research conclusions.  6) A group of nine graduate and three undergraduate students received specialized training in software development techniques and tools associated with testing and analysis. Five of them attended a conference in their research area. One of the graduated students is now a faculty member at another university, and one of the undergraduate students joined graduate school to continue his career in this area.          Last Modified: 09/15/2016       Submitted by: Sebastian G Elbaum]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
