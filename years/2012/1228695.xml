<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Medium: Collaborative: Flexible and Practical Information Flow Assurance for Mobile Apps</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2012</AwardEffectiveDate>
<AwardExpirationDate>12/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>325690.00</AwardTotalIntnAmount>
<AwardAmount>333690</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This project is developing tools and techniques for cost-effective evaluation of the trustworthiness of mobile applications (apps).  The work focuses on enterprise scenarios, in which personnel at a business or government agency use mission-related apps and access enterprise networks.&lt;br/&gt;&lt;br/&gt;In such scenarios there are incentives and resources for much more substantive evaluations and controls on information flow than are currently found in commodity app marketplaces.  The project aims to advance the science needed for static techniques to be usable by professional development and evaluation teams and useful for achieving dramatically improved assurance.  The project's goals are to: (a) find flexible and expressive ways to specify information flow requirements for apps, (b) find effective ways to specify what is assumed about the Android platform, and (c) find practical static analysis and verification techniques to check security of apps with respect to given policies and the platform. Results include specification techniques and theory - models and algorithms.  These are applied in case studies with prototype tools that the project develops, to evaluate how well the goals are achieved.&lt;br/&gt;&lt;br/&gt;The project's techniques can be deployed by certification organizations to provide scientifically sound techniques for assurance, thus&lt;br/&gt;enabling the full benefits of highly-integrated mobile software in mission-critical situations.  Software designers will benefit from being able to precisely specify end-to-end requirements as well as component interfaces.  Software developers will benefit from reliable means to detect design flaws and bugs, malware in third-party software, and unintended functionality that exposes vulnerabilities.   Beyond the specific target of mobile software, the techniques will be of use in other settings, especially web applications, where it is crucial to reason about interfaces between mutually untrusting parties making heavy use of callbacks.  The project could help improve security in government agencies and private sector, indirectly benefitting national security and the general population.</AbstractNarration>
<MinAmdLetterDate>08/03/2012</MinAmdLetterDate>
<MaxAmdLetterDate>04/16/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1228695</AwardID>
<Investigator>
<FirstName>Gary</FirstName>
<LastName>Leavens</LastName>
<PI_MID_INIT>T</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Gary T Leavens</PI_FULL_NAME>
<EmailAddress>leavens@cs.ucf.edu</EmailAddress>
<PI_PHON>4078234758</PI_PHON>
<NSF_ID>000331890</NSF_ID>
<StartDate>08/03/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>The University of Central Florida Board of Trustees</Name>
<CityName>Orlando</CityName>
<ZipCode>328168005</ZipCode>
<PhoneNumber>4078230387</PhoneNumber>
<StreetAddress>4000 CNTRL FLORIDA BLVD</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Florida</StateName>
<StateCode>FL</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>FL07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>150805653</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CENTRAL FLORIDA BOARD OF TRUSTEES, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>159621697</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Central Florida]]></Name>
<CityName>Orlando</CityName>
<StateCode>FL</StateCode>
<ZipCode>328162362</ZipCode>
<StreetAddress><![CDATA[4000 Central Florida Blvd.]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Florida</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>FL07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1714</Code>
<Text>Special Projects - CNS</Text>
</ProgramElement>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9178</Code>
<Text>UNDERGRADUATE EDUCATION</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~325690</FUND_OBLG>
<FUND_OBLG>2015~8000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The major outcome for this work is an approach to the design of formal specification languages for specifying information flows in programs. This approach both separates the specification of policies from the program and makes auditing of policies easier. We call the overall approach &ldquo;Evidently&rdquo;. The particular specification language designed for Java we call the Evidently Policy Language for Java or EPL/J. Work is ongoing on the semantics of the Evidently approach and on the implementation of EPL/J.</p> <p>EPL/J is designed to describe policies about information flow (including implicit flows) and declassification (including conditional gradual release, as in the work of Banerjee and Naumann) in Java program in a way which is both expressive and which avoids scattering and tangling. Declassifications in the program should be guaranteed to follow the stated policy. Moreover, policy decisions about when, where, and how information may be declassified should not be scattered throughout the program and mixed together (tangled with) the program's code. The policy should be written separately from the code, which makes &nbsp;it possible for the policy to be reused for several programs. Reuse of polices is important for our context of Android applications, as an app store would set policies that should be followed by multiple applications. Moreover, security auditing should be easy to accomplish even when a program changes, in the sense that the effort needed for auditing should be independent of the size of a program to which the policy is applied and the number of changes made to the program during maintenance. Evidently eases security auditing by making it possible to audit the policy in isolation from the program.</p> <p>EPL/J can define security labels, models that connect the policy to the data locations in a program, and policies that express both normal flows and when declassifications may occur (using the idea of conditional gradual release). Declassifications may depend on program states as identified in the model. The model in an EPL/J policy is the only direct connection of the policy to the program, and can act to insulate the rest of the policy from program changes; thus if the program changes, at most the model will need to change.</p> <p>The semantics of the Evidently approach is being formulated based on traces of events that happen in a program, which will make the semantics independent of particular programming languages. Each language&rsquo;s own semantics would map actions in the program (such as assignments to variables and fields or method calls) to a generic notion of &ldquo;event&rdquo; in the semantics. The events will carry enough information to enable checking of policies. Dynamic checking of policies in an implementation will then consist of checking the events in the program&rsquo;s evolving trace. Static checking will involve approximating the set of traces that a program can produce at runtime, and then checking the policy against that approximation.</p> <p>The implementation of EPL/J is the project of a Master&rsquo;s student who has been paid by this grant. The implementation has allowed the project to fine tune the connections between the policy language and the programming language. In particular, namespace issues that connect the specified model to the program have been worked out.</p> <p>The project has also done several case studies of information flow security for Android apps, and these are being redone in EPL/J.</p> <p>&nbsp;</p><br> <p>            Last Modified: 01/14/2018<br>      Modified by: Gary&nbsp;T&nbsp;Leavens</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The major outcome for this work is an approach to the design of formal specification languages for specifying information flows in programs. This approach both separates the specification of policies from the program and makes auditing of policies easier. We call the overall approach "Evidently". The particular specification language designed for Java we call the Evidently Policy Language for Java or EPL/J. Work is ongoing on the semantics of the Evidently approach and on the implementation of EPL/J.  EPL/J is designed to describe policies about information flow (including implicit flows) and declassification (including conditional gradual release, as in the work of Banerjee and Naumann) in Java program in a way which is both expressive and which avoids scattering and tangling. Declassifications in the program should be guaranteed to follow the stated policy. Moreover, policy decisions about when, where, and how information may be declassified should not be scattered throughout the program and mixed together (tangled with) the program's code. The policy should be written separately from the code, which makes  it possible for the policy to be reused for several programs. Reuse of polices is important for our context of Android applications, as an app store would set policies that should be followed by multiple applications. Moreover, security auditing should be easy to accomplish even when a program changes, in the sense that the effort needed for auditing should be independent of the size of a program to which the policy is applied and the number of changes made to the program during maintenance. Evidently eases security auditing by making it possible to audit the policy in isolation from the program.  EPL/J can define security labels, models that connect the policy to the data locations in a program, and policies that express both normal flows and when declassifications may occur (using the idea of conditional gradual release). Declassifications may depend on program states as identified in the model. The model in an EPL/J policy is the only direct connection of the policy to the program, and can act to insulate the rest of the policy from program changes; thus if the program changes, at most the model will need to change.  The semantics of the Evidently approach is being formulated based on traces of events that happen in a program, which will make the semantics independent of particular programming languages. Each language?s own semantics would map actions in the program (such as assignments to variables and fields or method calls) to a generic notion of "event" in the semantics. The events will carry enough information to enable checking of policies. Dynamic checking of policies in an implementation will then consist of checking the events in the program?s evolving trace. Static checking will involve approximating the set of traces that a program can produce at runtime, and then checking the policy against that approximation.  The implementation of EPL/J is the project of a Master?s student who has been paid by this grant. The implementation has allowed the project to fine tune the connections between the policy language and the programming language. In particular, namespace issues that connect the specified model to the program have been worked out.  The project has also done several case studies of information flow security for Android apps, and these are being redone in EPL/J.          Last Modified: 01/14/2018       Submitted by: Gary T Leavens]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
