<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Small: New Foundations for Secure JavaScript</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2012</AwardEffectiveDate>
<AwardExpirationDate>08/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>JavaScript has transformed the way in which software systems are developed, deployed and extended. It is now used to build complex, security sensitive applications for communications, retail, and banking, and is even a primary building block of web browsers themselves. Unfortunately, the advent of JavaScript has also opened the door to new classes of security vulnerabilities, as applications manipulate security critical client information like browsing history, passwords, bank account numbers, social security numbers and so on. Worse, the absence of language-level isolation mechanisms makes it hard to establish confidentiality and integrity of key software components.&lt;br/&gt;&lt;br/&gt;We believe that the key to making the web more secure is to develop a practical, precise and expressive type system for JavaScript and to use it as a foundation for developing security policies, analyses and enforcement mechanisms for JavaScript browser extensions and applications. Thus, we propose to develop a type system for JavaScript that is expressive enough to support JavaScript's dynamic idioms, practical enough to require minimal programmer intervention and hence, be capable of highly automated analysis of large code bases, and easily extensible enough to allow developers to specify and enforce different kinds of fine-grained security policies.&lt;br/&gt;&lt;br/&gt;Our research will lead to the following contributions: End Users will be able to freely run extensions, plugins and rich browser applications from trusted sites, without having to suffer the plagues of code-injection, information exfiltration or the unpalatable cures of fully dynamic enforcement whose overhead can render sites unusable.  Developers will be able to fully enjoy the fruits of static verification, in a familiar package: namely types. Types will allow developers to specify at the right granularity, the permissions required for some functionality, and will prevent the inadvertent vulnerabilities that are introduced by overprovisioning, or under-sanitization of data.  Curators that aggregate third party applications (e.g. ``app stores" for various mobile platforms) will be able to use type-based certificates to quickly vet applications, thereby determining if an application is safe to host without compromising the reputation of the platform.</AbstractNarration>
<MinAmdLetterDate>09/04/2012</MinAmdLetterDate>
<MaxAmdLetterDate>09/04/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1223850</AwardID>
<Investigator>
<FirstName>Ranjit</FirstName>
<LastName>Jhala</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ranjit Jhala</PI_FULL_NAME>
<EmailAddress>jhala@cs.ucsd.edu</EmailAddress>
<PI_PHON>8585341420</PI_PHON>
<NSF_ID>000486287</NSF_ID>
<StartDate>09/04/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-San Diego</Name>
<CityName>La Jolla</CityName>
<ZipCode>920930934</ZipCode>
<PhoneNumber>8585344896</PhoneNumber>
<StreetAddress>Office of Contract &amp; Grant Admin</StreetAddress>
<StreetAddress2><![CDATA[9500 Gilman Drive, 0934]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>49</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA49</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>804355790</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CALIFORNIA, SAN DIEGO</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-San Diego]]></Name>
<CityName>La Jolla</CityName>
<StateCode>CA</StateCode>
<ZipCode>920930404</ZipCode>
<StreetAddress><![CDATA[9500 Gilman Drive]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>49</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA49</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~400000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><br /><br /><br /># Project Outcomes<br /><br />This project led to the invention of new algorithms and tools<br />for analyzing programs written in JavaScript, the language of<br />the web. Specifically, it led to to the development of the<br />open-source RefScript system, a _Refinement Type_ system for<br />for the _TypeScript_ dialect of JavaScript that is being developed<br />by Microsoft.<br /><br />In the project, we demonstrated how the RefScript can be used<br />to improve the quality of JavaScript programs in several ways.<br />First, the developer can use refinement types to completely<br />eliminate large and expensive classes of errors that can<br />either cause application code to crash or fail in unexpected<br />and hard to find ways, or worse, may be vulnerabilities that<br />can be exploited by an attacker.<br />Second, the developer can encode, within the program, detailed<br />constraints on _how_ the program should be used, via refined API<br />specifications, that then enable the construction and composition<br />of larger systems.<br /><br />We achieved this by developing and implementing several key ideas.<br /><br />## Aliased Refinement Types (VMCAI 2016)<br /><br />First, we developed the notion of _aliased refinement types_<br />a new approach to automate the verification of correctness<br />properties of pointer-based data structures. While there are<br />many techniques for checking that pointer-manipulating programs<br />adhere to their specifications, they often require that the<br />programmer annotate the behavior of each procedure,<br />for example, in the form of loop invariants and pre-<br />and post-conditions. We introduce a technique that<br />automates this step by factoring the analysis of data<br />structures into two orthogonal components:<br /><br />(1) Alias Types, which reason about the _shape_ of<br />&nbsp;&nbsp;&nbsp; pointer structures, and<br />(2) Refinement Types, which use simple predicates<br />&nbsp;&nbsp;&nbsp; from decidable theories to capture the semantic<br />&nbsp;&nbsp;&nbsp; properties of the structures.<br /><br />We empirically show, using a suite of data-structure<br />benchmarks, that our approach reduces the programmer<br />effort needed for verification by a factor of 4.<br /><br />## Trust, but Verify: Two-Phased Typing<br /><br />The second crucial challenge for analyzing _dynamic_<br />languages like JavaScript, is that programs can, while<br />running, have different _types_ depending on the the<br />_values_ of various run-time parameters. We carried<br />out a study that demonstrated that this form of<br />introspection, that we named "value-based<br />overloading" is ubiquitous in JavaScript libraries.<br />Value based overloading thwarts&nbsp; previous analysis<br />attempts as to establish basic types, the analysis<br />must reason precisely about values, but in the<br />presence of advanced language constructs (e.g.<br />higher-order functions and polymorphism, this<br />reasoning itself can require basic types.)<br /><br />We invented the framework of "two-phased typing" to cut<br />this knot. The first "trust" phase performs classical<br />type checking to assign basic types to various program<br />expressions. When the check inevitably runs into "errors"<br />it marks problematic expressions to explicate the trust<br />obligations that must be discharged by the second phase,<br />which uses refinement typing to establish correctness.<br /><br />## SSA-Refinement Typing<br /><br />Our third key contribution was to show how the above<br />can be scaled up to yield a lightweight refinement type<br />system for the TypeScript superset of JavaScript, yielding<br />RSC the _first static verifier_ for the language of the web.<br />To do so, we carefully formalized the interaction<br />between refinement types and mutability and show how<br />to recover sensitivity by translating input programs<br />to an equivalent SSA form. We then demonstrated how to<br />scale the formalism up to account for imperative and<br />dynamic features of TypeScript, including overloading,<br />type reflection, ad hoc type hierarchies and object<br />initialization.<br /><br />Finally, we evaluated RSC on a set of real-world benchmarks,<br />including parts of the Octane benchmarks, D3, Transducers,<br />and the TypeScript compiler. We showed how RSC successfully<br />establishes a number of value dependent properties, such<br />as the safety of array accesses and downcasts, while<br />incurring a modest overhead in type annotations and code<br />restructuring.<br /><br />## Overall Outcomes<br /><br />Consequently, this project has demonstrated comprehensively<br />the viability of building effective static verifiers, capable<br />of enforcing correctness and security properties, for a<br />modern, imperative, scripting language that powers the web.<br />The lead student on the project -- Panagiotis Vekris -- has<br />graduated and is now part of the "Flow" team at Facebook.<br />Other research groups have picked up on this foundational <br />work and are using it to build higher level secure web<br />frameworks for JavaScript.</p><br> <p>            Last Modified: 12/04/2017<br>      Modified by: Ranjit&nbsp;Jhala</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[    # Project Outcomes  This project led to the invention of new algorithms and tools for analyzing programs written in JavaScript, the language of the web. Specifically, it led to to the development of the open-source RefScript system, a _Refinement Type_ system for for the _TypeScript_ dialect of JavaScript that is being developed by Microsoft.  In the project, we demonstrated how the RefScript can be used to improve the quality of JavaScript programs in several ways. First, the developer can use refinement types to completely eliminate large and expensive classes of errors that can either cause application code to crash or fail in unexpected and hard to find ways, or worse, may be vulnerabilities that can be exploited by an attacker. Second, the developer can encode, within the program, detailed constraints on _how_ the program should be used, via refined API specifications, that then enable the construction and composition of larger systems.  We achieved this by developing and implementing several key ideas.  ## Aliased Refinement Types (VMCAI 2016)  First, we developed the notion of _aliased refinement types_ a new approach to automate the verification of correctness properties of pointer-based data structures. While there are many techniques for checking that pointer-manipulating programs adhere to their specifications, they often require that the programmer annotate the behavior of each procedure, for example, in the form of loop invariants and pre- and post-conditions. We introduce a technique that automates this step by factoring the analysis of data structures into two orthogonal components:  (1) Alias Types, which reason about the _shape_ of     pointer structures, and (2) Refinement Types, which use simple predicates     from decidable theories to capture the semantic     properties of the structures.  We empirically show, using a suite of data-structure benchmarks, that our approach reduces the programmer effort needed for verification by a factor of 4.  ## Trust, but Verify: Two-Phased Typing  The second crucial challenge for analyzing _dynamic_ languages like JavaScript, is that programs can, while running, have different _types_ depending on the the _values_ of various run-time parameters. We carried out a study that demonstrated that this form of introspection, that we named "value-based overloading" is ubiquitous in JavaScript libraries. Value based overloading thwarts  previous analysis attempts as to establish basic types, the analysis must reason precisely about values, but in the presence of advanced language constructs (e.g. higher-order functions and polymorphism, this reasoning itself can require basic types.)  We invented the framework of "two-phased typing" to cut this knot. The first "trust" phase performs classical type checking to assign basic types to various program expressions. When the check inevitably runs into "errors" it marks problematic expressions to explicate the trust obligations that must be discharged by the second phase, which uses refinement typing to establish correctness.  ## SSA-Refinement Typing  Our third key contribution was to show how the above can be scaled up to yield a lightweight refinement type system for the TypeScript superset of JavaScript, yielding RSC the _first static verifier_ for the language of the web. To do so, we carefully formalized the interaction between refinement types and mutability and show how to recover sensitivity by translating input programs to an equivalent SSA form. We then demonstrated how to scale the formalism up to account for imperative and dynamic features of TypeScript, including overloading, type reflection, ad hoc type hierarchies and object initialization.  Finally, we evaluated RSC on a set of real-world benchmarks, including parts of the Octane benchmarks, D3, Transducers, and the TypeScript compiler. We showed how RSC successfully establishes a number of value dependent properties, such as the safety of array accesses and downcasts, while incurring a modest overhead in type annotations and code restructuring.  ## Overall Outcomes  Consequently, this project has demonstrated comprehensively the viability of building effective static verifiers, capable of enforcing correctness and security properties, for a modern, imperative, scripting language that powers the web. The lead student on the project -- Panagiotis Vekris -- has graduated and is now part of the "Flow" team at Facebook. Other research groups have picked up on this foundational  work and are using it to build higher level secure web frameworks for JavaScript.       Last Modified: 12/04/2017       Submitted by: Ranjit Jhala]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
