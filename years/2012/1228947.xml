<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Medium: Collaborative: Foundations of Application-Sensitive Access Control Evaluation</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2012</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>653259.00</AwardTotalIntnAmount>
<AwardAmount>653259</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>nan zhang</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>Access control schemes are traditionally compared in terms of raw expressive power (i.e., the policies they can encode and how those policies can be changed); however, such comparisons ignore the needs of the application within which a scheme will be deployed.  For some applications, the most expressive scheme may be overly complex and not necessarily the best fit. To this end, this project investigates the suitability analysis problem: Given a system's access control workload, a set of candidate access control schemes, and a set of application-specific cost metrics, which scheme best meets the needs of the system?&lt;br/&gt;&lt;br/&gt;The goal is to create a suitability-analysis framework that is sufficiently rigorous to be useful to researchers and theoreticians, while remaining accessible to security practitioners. Such a framework will help formalize an access control scheme's application-specific strengths and limitations, enable researchers to precisely describe the scenarios for which a scheme is best suited, allow assessment of the novelty and utility of proposed schemes, and help analysts diagnose shortcomings in existing systems.  In particular, the project will develop (1) an application-specific, workload-based framework for analyzing the suitability of access control schemes that is sufficiently rich to compare logical, extensional, and hybrid schemes in both sequential and concurrent systems; (2) a cost analysis component that quantifies a scheme's suitability using custom metrics; and (3) tools that automate a range of suitability analysis tasks.  A real-world security workload, PKI-based authentication and authorization on the web, will be used to evaluate the results.</AbstractNarration>
<MinAmdLetterDate>08/17/2012</MinAmdLetterDate>
<MaxAmdLetterDate>04/24/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1228947</AwardID>
<Investigator>
<FirstName>Lenore</FirstName>
<LastName>Zuck</LastName>
<PI_MID_INIT>D</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Lenore D Zuck</PI_FULL_NAME>
<EmailAddress>lenore@cs.uic.edu</EmailAddress>
<PI_PHON>3123551339</PI_PHON>
<NSF_ID>000118794</NSF_ID>
<StartDate>04/24/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Lenore</FirstName>
<LastName>Zuck</LastName>
<PI_MID_INIT>D</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Lenore D Zuck</PI_FULL_NAME>
<EmailAddress>lenore@cs.uic.edu</EmailAddress>
<PI_PHON>3123551339</PI_PHON>
<NSF_ID>000118794</NSF_ID>
<StartDate>08/17/2012</StartDate>
<EndDate>04/24/2013</EndDate>
<RoleCode>Former Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Timothy</FirstName>
<LastName>Hinrichs</LastName>
<PI_MID_INIT>L</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Timothy L Hinrichs</PI_FULL_NAME>
<EmailAddress>hinrichs@uic.edu</EmailAddress>
<PI_PHON>3129962862</PI_PHON>
<NSF_ID>000582672</NSF_ID>
<StartDate>08/17/2012</StartDate>
<EndDate>04/24/2013</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Illinois at Chicago</Name>
<CityName>Chicago</CityName>
<ZipCode>606124305</ZipCode>
<PhoneNumber>3129962862</PhoneNumber>
<StreetAddress>809 S. Marshfield Avenue</StreetAddress>
<StreetAddress2><![CDATA[MB 502, M/C 551]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<StateCode>IL</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IL07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>098987217</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF ILLINOIS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041544081</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Illinois at Chicago]]></Name>
<CityName/>
<StateCode>IL</StateCode>
<ZipCode>606077053</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IL07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~653259</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span>1. We developed methodologies and tools to guarantee access control, from the server&rsquo;s end, on access request. &nbsp;The basic approach is for the server to create views that take into account the permissions of a user, and only allow for access to the view.</span></p> <p>2. We studied &nbsp;how to impose access control policies that are common to non-IT people, e.g., those that restrict the path that led to data. &nbsp;We studied some comparison between relational and graph-based data bases with respect to search efficiency.&nbsp;</p> <p>3. We abstracted the mobility aspects of the the IPv6 protocols and analyzed it using a combination of techniques, revealing that (as was shown in earlier works) forwarding cycles may exist, however that there are not a problem, that is, &nbsp;if the system stabilizes for long enough, all forwarding cycles disappear. In effect we obtained a new simulation-based proof methodology that combines model checking and process algebraic ideas, and allows showing one system simulates another at the limit, for which we can derive some (infinitary) properties. &nbsp;We used this method to verify some properties of other protocols (such as TOR). We further identified a class of systems that are behaviorally self-similar and exhibit resilience to adversarial behavior. The results of this line of work were published in TGC 2015, HVC 2015, and EXPRESS 2016. There are still some unpublished results (an exercise in formal verification of a simple protocol whose proof isn't.)</p> <p>&nbsp;</p> <p>4. Memory access errors such as buffer overruns are notorious security vulnerabilities. There has been considerable interest in having a compiler ensure the safety of compiled code either through static verification or through instrumented runtime checks. While certifying compilation has shown much promise, it has not been practical, leaving code instrumentation as the next best strategy for compilation.We term such compilers Memory Error SanitizationCompilers (MESCs). MESCs are available as part of GCC, LLVM and MSVC suites. Due to practical limitations, MESCs typically apply instrumentation even-handedly and indiscriminately to every memory access, and are consequently prohibitively expensive and practical to only small code bases. We developed a methodology that applies state-of-the-art static analysis techniques to eliminate unnecessary runtime checks, resulting in more efficient and scalable defenses. The methodology was implemented on LLVMs Safecode, Integer Overflow, and Address Sanitizer passes, using static analysis of Frama-C and Codesurfer. The benchmarks demonstrate an improvement in runtime performance that makes incorporation of runtime checks a viable option for defenses.</p> <p>5. Our novel idea to verify probability 1 properties of probabilistic parametrized system is to postpone the "de-probabilization" to as a late stage as possible. &nbsp;This is in contrast to the leading approaches that have been used before, where the probabilistic elements (coin flips) were replaced by deterministic and non-deterministic ones. E.g., several years ago we proposed to replace coin flips by non-determinism, and occasionally (infinitely many times), for a consecutive bounded coin flips, have the coin tosses predetermined. This was approach was termed "planner." Later works have used a "pattern" which is a variant on the planner. After the probabilistic selections are removed the system is purely non-deterministic and can be verified using a variety of methods. Yet, the planners/patterns are often elusive and some recent work attempt to derive them automatically. Our main observation is that they are not necessary. That is, if the goal is to verify a parameterized probabilistic system, then the planner approach is sound, however, they are not necessary. That is, that the original probabilistic parameterized systems can be abstracted directly into smaller probabilistic systems, &nbsp;and only then apply &nbsp;Markov-reasoning or any other tool to prove its correct &nbsp;(with probability 1)&nbsp;termination.&nbsp;</p> <p>We developed the theory of doing that using counter abstraction, which is a type of predicate abstraction that had been proven to be simple yet powerful in verification of parameterized systems. While developing the method we applied it on several very different examples (such as Ittai and Rodeh's leader election in a ring &nbsp;and self stabilization protocols) and it turned out to deal well even with systems that seem to be more suitable for regular model checking approach, which we found surprising. &nbsp;We were delighted (but not surprised!) to see that our method allowed for an easy automatic generation of a family of planners. Finally, it turned out that our method is also suitable to verify some properties that hold with a probability that depends on the system's parameter. E.g., Rabin's Choice Coordination protocol and P2P protocols for aggregation of values.&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 01/05/2017<br>      Modified by: Lenore&nbsp;D&nbsp;Zuck</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ 1. We developed methodologies and tools to guarantee access control, from the server?s end, on access request.  The basic approach is for the server to create views that take into account the permissions of a user, and only allow for access to the view.  2. We studied  how to impose access control policies that are common to non-IT people, e.g., those that restrict the path that led to data.  We studied some comparison between relational and graph-based data bases with respect to search efficiency.   3. We abstracted the mobility aspects of the the IPv6 protocols and analyzed it using a combination of techniques, revealing that (as was shown in earlier works) forwarding cycles may exist, however that there are not a problem, that is,  if the system stabilizes for long enough, all forwarding cycles disappear. In effect we obtained a new simulation-based proof methodology that combines model checking and process algebraic ideas, and allows showing one system simulates another at the limit, for which we can derive some (infinitary) properties.  We used this method to verify some properties of other protocols (such as TOR). We further identified a class of systems that are behaviorally self-similar and exhibit resilience to adversarial behavior. The results of this line of work were published in TGC 2015, HVC 2015, and EXPRESS 2016. There are still some unpublished results (an exercise in formal verification of a simple protocol whose proof isn't.)     4. Memory access errors such as buffer overruns are notorious security vulnerabilities. There has been considerable interest in having a compiler ensure the safety of compiled code either through static verification or through instrumented runtime checks. While certifying compilation has shown much promise, it has not been practical, leaving code instrumentation as the next best strategy for compilation.We term such compilers Memory Error SanitizationCompilers (MESCs). MESCs are available as part of GCC, LLVM and MSVC suites. Due to practical limitations, MESCs typically apply instrumentation even-handedly and indiscriminately to every memory access, and are consequently prohibitively expensive and practical to only small code bases. We developed a methodology that applies state-of-the-art static analysis techniques to eliminate unnecessary runtime checks, resulting in more efficient and scalable defenses. The methodology was implemented on LLVMs Safecode, Integer Overflow, and Address Sanitizer passes, using static analysis of Frama-C and Codesurfer. The benchmarks demonstrate an improvement in runtime performance that makes incorporation of runtime checks a viable option for defenses.  5. Our novel idea to verify probability 1 properties of probabilistic parametrized system is to postpone the "de-probabilization" to as a late stage as possible.  This is in contrast to the leading approaches that have been used before, where the probabilistic elements (coin flips) were replaced by deterministic and non-deterministic ones. E.g., several years ago we proposed to replace coin flips by non-determinism, and occasionally (infinitely many times), for a consecutive bounded coin flips, have the coin tosses predetermined. This was approach was termed "planner." Later works have used a "pattern" which is a variant on the planner. After the probabilistic selections are removed the system is purely non-deterministic and can be verified using a variety of methods. Yet, the planners/patterns are often elusive and some recent work attempt to derive them automatically. Our main observation is that they are not necessary. That is, if the goal is to verify a parameterized probabilistic system, then the planner approach is sound, however, they are not necessary. That is, that the original probabilistic parameterized systems can be abstracted directly into smaller probabilistic systems,  and only then apply  Markov-reasoning or any other tool to prove its correct  (with probability 1) termination.   We developed the theory of doing that using counter abstraction, which is a type of predicate abstraction that had been proven to be simple yet powerful in verification of parameterized systems. While developing the method we applied it on several very different examples (such as Ittai and Rodeh's leader election in a ring  and self stabilization protocols) and it turned out to deal well even with systems that seem to be more suitable for regular model checking approach, which we found surprising.  We were delighted (but not surprised!) to see that our method allowed for an easy automatic generation of a family of planners. Finally, it turned out that our method is also suitable to verify some properties that hold with a probability that depends on the system's parameter. E.g., Rabin's Choice Coordination protocol and P2P protocols for aggregation of values.              Last Modified: 01/05/2017       Submitted by: Lenore D Zuck]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
