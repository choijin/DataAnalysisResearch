<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Small: Rethinking the OS/Network Boundary</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2012</AwardEffectiveDate>
<AwardExpirationDate>08/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>494353.00</AwardTotalIntnAmount>
<AwardAmount>494353</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Operating systems and networks developed largely independently, due to&lt;br/&gt;the nature of their development -- operating systems were developed by&lt;br/&gt;groups within organizations/companies, while networking requiring&lt;br/&gt;interoperability was developed across organizations. As a result of&lt;br/&gt;this development history, the boundary between the networking&lt;br/&gt;subsystem and the rest of the operating system has remained largely&lt;br/&gt;opaque, with little information regarding the performance or progress&lt;br/&gt;of transfers being communicated to applications. This research&lt;br/&gt;addresses this limitation by exploring a richer boundary interface&lt;br/&gt;that allows programs to see the ongoing behavior of network transfers&lt;br/&gt;and to control their operation at a fine granularity. These interfaces&lt;br/&gt;would augment, rather than replace, the existing interfaces, so the&lt;br/&gt;portions of programs that are satisfied with the current interfaces&lt;br/&gt;could continue unmodified, and developers could change only the&lt;br/&gt;portions that can benefit from richer information.  This research is&lt;br/&gt;largely experimental in nature, and will combine the design and&lt;br/&gt;implementation of new interface abstractions along with the&lt;br/&gt;development of new or modified programs to take advantage of these&lt;br/&gt;interfaces. In addition to the design work associated with the&lt;br/&gt;interfaces, additional criteria for success include examining the&lt;br/&gt;performance and delay behavior of modified applications, and the&lt;br/&gt;effort needed to modify such applications. The expected results from&lt;br/&gt;this work include applications that can more precisely control their&lt;br/&gt;networking behavior, reducing memory and processor usage, improving&lt;br/&gt;energy efficiency, and improving delay behavior. High-performance or&lt;br/&gt;time-sensitive applications, such as networked video, should benefit&lt;br/&gt;from this research.</AbstractNarration>
<MinAmdLetterDate>08/16/2012</MinAmdLetterDate>
<MaxAmdLetterDate>08/16/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1217782</AwardID>
<Investigator>
<FirstName>Vivek</FirstName>
<LastName>Pai</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vivek Pai</PI_FULL_NAME>
<EmailAddress>vivek@cs.princeton.edu</EmailAddress>
<PI_PHON>6092582086</PI_PHON>
<NSF_ID>000122168</NSF_ID>
<StartDate>08/16/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Princeton University</Name>
<CityName>Princeton</CityName>
<ZipCode>085442020</ZipCode>
<PhoneNumber>6092583090</PhoneNumber>
<StreetAddress>Off. of Research &amp; Proj. Admin.</StreetAddress>
<StreetAddress2><![CDATA[P.O. Box 36]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ12</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>002484665</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF PRINCETON UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>002484665</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Princeton University]]></Name>
<CityName>Princeton</CityName>
<StateCode>NJ</StateCode>
<ZipCode>085442020</ZipCode>
<StreetAddress><![CDATA[4 New South Building]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ12</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1714</Code>
<Text>Special Projects - CNS</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~494353</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This research re-examined the boundary between the networking portion of the operating system and the core portion of the operating system. Programmers have historically used an interface that allowed them to send data over the network by having the operating system make a copy of the data the programmer presented. Once the programmer presented the data, the operating system would make every effort to deliver the data, even if delivering that data took longer than originally expected. Other mechanisms were used for applications like voice calls over the Internet, but this method of semi-guaranteed delivery is commonly used today for applications like video on demand. The problem with this approach is evident in symptoms such as buffering, in which case the video being sent is being received slower than expected, so the user's video software has to wait until enough data has arrived to ensure smooth playback.</p> <p>By re-examining the interface that programmers use to send this kind of data, this research was able to devise new support in the operating system so that programs could detect that data was being delivered more slowly than anticipated, and make corresponding changes. So, in the case of video delivery, the program could remove any data that was still waiting, and replace it with a lower-resolution version of the same content. Lower-resolution video will not have the same quality as the original video, but will require less bandwidth, so it may be possible to play it without buffering in situations where a higher-quality video would stall multiple times. Such lower-resolution video can be used until the bandwidth increases again, at which time the original-quality video can be resumed. In this manner, users can experience dramatically-reduced buffering while only viewing lower-quality video as needed.</p> <p>This research enables the easy migration of existing video systems to this kind of approach, since it can be done purely on the servers sending the video, instead of having to update the software of every user viewing the video. Additionally, this research applied similar techniques to other kinds of data, allowing similar benefits for still images and even other types of transfers, such as Web pages.</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/05/2016<br>      Modified by: Vivek&nbsp;S&nbsp;Pai</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This research re-examined the boundary between the networking portion of the operating system and the core portion of the operating system. Programmers have historically used an interface that allowed them to send data over the network by having the operating system make a copy of the data the programmer presented. Once the programmer presented the data, the operating system would make every effort to deliver the data, even if delivering that data took longer than originally expected. Other mechanisms were used for applications like voice calls over the Internet, but this method of semi-guaranteed delivery is commonly used today for applications like video on demand. The problem with this approach is evident in symptoms such as buffering, in which case the video being sent is being received slower than expected, so the user's video software has to wait until enough data has arrived to ensure smooth playback.  By re-examining the interface that programmers use to send this kind of data, this research was able to devise new support in the operating system so that programs could detect that data was being delivered more slowly than anticipated, and make corresponding changes. So, in the case of video delivery, the program could remove any data that was still waiting, and replace it with a lower-resolution version of the same content. Lower-resolution video will not have the same quality as the original video, but will require less bandwidth, so it may be possible to play it without buffering in situations where a higher-quality video would stall multiple times. Such lower-resolution video can be used until the bandwidth increases again, at which time the original-quality video can be resumed. In this manner, users can experience dramatically-reduced buffering while only viewing lower-quality video as needed.  This research enables the easy migration of existing video systems to this kind of approach, since it can be done purely on the servers sending the video, instead of having to update the software of every user viewing the video. Additionally, this research applied similar techniques to other kinds of data, allowing similar benefits for still images and even other types of transfers, such as Web pages.          Last Modified: 09/05/2016       Submitted by: Vivek S Pai]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
