<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CCF: SHF: Medium: Collaborative Research: A Static and Dynamic Verification Framework for Parallel Programming</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/15/2013</AwardEffectiveDate>
<AwardExpirationDate>12/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>398752.00</AwardTotalIntnAmount>
<AwardAmount>398752</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Human society is faced with an increasing number of problems including&lt;br/&gt;stubborn diseases and international security/climate threats. The&lt;br/&gt;computer simulations and advanced data management methods necessary to&lt;br/&gt;solving these societal problems can only be realized through increased&lt;br/&gt;use of parallel computing at all system scales, including desktops,&lt;br/&gt;servers and the cloud. Efficient large-scale parallel computing&lt;br/&gt;however requires advanced parallel programming methods. Such methods,&lt;br/&gt;unfortunately, have a greater proclivity for software bugs that&lt;br/&gt;increase cost through lost cycles on super-computers and these same&lt;br/&gt;bugs undermine confidence in simulation results.  This research&lt;br/&gt;addresses the challenge of developing parallel computing software by&lt;br/&gt;creating new scalable methods to support advanced parallel programming&lt;br/&gt;models that provide rigorous guarantees on program correctness. The&lt;br/&gt;societal impacts of this work stem from increasing reliability of&lt;br/&gt;software powering the national infrastructure, advanced educational&lt;br/&gt;methods to train future generations, and pedagogical material in the&lt;br/&gt;form of course notes and software for broad dissemination.  It also&lt;br/&gt;helps maintain the United States in a leadership situation with&lt;br/&gt;respect to the available talent pool in this area.&lt;br/&gt;&lt;br/&gt;Providing rigorous guarantees on correctness of existing parallel&lt;br/&gt;computing software requires that two classes of methods be developed,&lt;br/&gt;evaluated, and taught widely: scalable code-level (static) checking&lt;br/&gt;methods, and downstream detailed (dynamic) checking methods. This&lt;br/&gt;project develops these novel and much-needed correctness checking&lt;br/&gt;methods around the Habanero Java programming and compilation&lt;br/&gt;system. The research is to augment the system with correctness&lt;br/&gt;obligations emitted during compilation and checked at all later stages&lt;br/&gt;of translation and deployment.  A key highlight of the project's&lt;br/&gt;approach is that it allows some of the correctness obligations to be&lt;br/&gt;checked statically in the context of safe subsets of Habanero Java.&lt;br/&gt;Obligations that are not able to be statically checked, especially for&lt;br/&gt;larger subsets of the Habanero language, are marked for checking&lt;br/&gt;dynamically through novel active-testing methods. An Operational&lt;br/&gt;Semantics written in the Coq notation lends cohesion to the work by&lt;br/&gt;ensuring that the division of correctness checking between static and&lt;br/&gt;dynamic techniques is sound. In summary, this research helps advance&lt;br/&gt;the science of parallel programming in terms of rigorous correctness&lt;br/&gt;checking methods, while at the same time contributing to the broad&lt;br/&gt;practice of programming at all scales from desktop to cloud&lt;br/&gt;computing and high-end scientific simulations.</AbstractNarration>
<MinAmdLetterDate>04/11/2013</MinAmdLetterDate>
<MaxAmdLetterDate>05/01/2018</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1302524</AwardID>
<Investigator>
<FirstName>Eric</FirstName>
<LastName>Mercer</LastName>
<PI_MID_INIT>G</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Eric G Mercer</PI_FULL_NAME>
<EmailAddress>egm@cs.byu.edu</EmailAddress>
<PI_PHON>8014224628</PI_PHON>
<NSF_ID>000425557</NSF_ID>
<StartDate>04/11/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Brigham Young University</Name>
<CityName>Provo</CityName>
<ZipCode>846021231</ZipCode>
<PhoneNumber>8014223360</PhoneNumber>
<StreetAddress>A-285 ASB</StreetAddress>
<StreetAddress2><![CDATA[Campus Drive]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Utah</StateName>
<StateCode>UT</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>UT03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>009094012</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>BRIGHAM YOUNG UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001940170</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Brigham Young University]]></Name>
<CityName>Provo</CityName>
<StateCode>UT</StateCode>
<ZipCode>846021231</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Utah</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>UT03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~195423</FUND_OBLG>
<FUND_OBLG>2015~203329</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Task parallel programming models such as OpenMP, Cilk, X10, and Habanero help developers write idiomatic parallel programs that avoid common concurrency errors. The models provide a task abstraction for concurrency that is agnostic of the underlying runtime implementation to simplify programming. The models then structure how tasks are created and synchronized in a way that guarantees deadlock freedom, determinism, and that the program can be serialized by removing all task related keywords.&nbsp;</p> <p>These properties rely on the program being free of data-race. Data-race is where two tasks access the same memory and at least one access is a write.&nbsp; Data-race introduces non-determinism into the program and undermines the correctness guarantees provided by the task abstraction. It is also hard to detect statically or dynamically in a program.&nbsp;</p> <p>The primary outcomes for the research from this grant center around proving data-race freedom in idiomatic parallel programs. The research uses Habanero for the programming model and provides several artifacts for the Java implementation of Habanero to support data-race freedom verification.<br />The first outcome is a Habanero runtime for test, debug, and verification. Most data-race approaches focus on detection rather than verification and utilize a full production runtime; low overhead and minimal impact on runtime performance are the primary goals. Research in this grant rather focuses on proving data-race freedom and provides a runtime that is well suited for running standalone for test, in a debugger, or in a model checker for verification.</p> <p>The runtime leaves behind complex task implementations and the complicated ways to work steal, load balance, and schedule tasks. Performance is not the primary objective. Rather the objective is simplicity over performance so that practitioners are able to first test, debug, and understand the parallel program before deploying it on a full-scale production system. As such the Habanero Java verification runtime works seamlessly in the Java Pathfinder (JPF) model checker with no modification to JPF and uses a simple thread implementation for the task abstraction. It is small and simple enough to be reasonably argued by code inspection that is a faithful implementation of the Habanero model.</p> <p>The second outcome is a collection of data-race verification algorithms integrated into JPF for the Habanero model with a rich collection of common data-race benchmarks collected from recent and past publications, other benchmark suites, and corner cases that arise in algorithm development. The new algorithms in this research center around the computation graph that captures concurrency in the program execution as a partial order and blend concepts from existing algorithms that use partial orders and access sets to detect data-race. The algorithms are shown in results on the benchmark suite to be more efficient in time and space in proving data-race freedom. These are available, with the Habanero runtime, at https://bitbucket.org/byu-vv/jpf-hj/src/master/ and https://bitbucket.org/byu-vv/jpf-hj/src/master/.</p> <p>The third outcome is a much deeper understanding of data race detection using partial orders and that in idiomatic parallel programs using access sets.&nbsp; This research blends ideas from both approaches and shows where one approach is preferred over the other based not just on program structure but the number of shared objects. It further takes the partial order approaches and weakens those relations to the point where they become unsound for general concurrency but still absolutely sound for idiomatic programs due to how they limit synchronization between tasks.&nbsp; The weakest partial order in this research is the does-not-commute partial order, and that is proven to be sound in idiomatic parallel programs with mutual exclusion. This result includes a mechanical proof in Coq of the soundness and an implementation in JPF showing a significant reduction in the number of schedules needed to prove data-race freedom in Habanero programs.</p> <p>The broader impact of the research from this grant is the accessibility of the tools to a larger community of practitioners and researchers.&nbsp; The JPF extension includes the implementation of several state-of-art data-race detection algorithms as well as the algorithms in this research. It also includes in one place a rich set of benchmarks that are now characterized over these several algorithms. These are all freely available for download. The distribution also includes a build system to simplify not just the build but test automation, regression, and experiments on the benchmarks. This single source of algorithms and benchmarks built on the open source JPF model checker with the Habanero verification runtime enables practitioners to build better systems and researchers to better characterize new contributions and applications.</p> <p><br />Finally the research in this grant has involved a diverse set of students giving them opportunity to research problems that are hard to solve and may not even have workable solutions. These students have untold impact as they go forward and grow the reach of concurrent systems and shape the future of concurrent programming models in systems and society.</p><br> <p>            Last Modified: 05/17/2019<br>      Modified by: Eric&nbsp;G&nbsp;Mercer</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Task parallel programming models such as OpenMP, Cilk, X10, and Habanero help developers write idiomatic parallel programs that avoid common concurrency errors. The models provide a task abstraction for concurrency that is agnostic of the underlying runtime implementation to simplify programming. The models then structure how tasks are created and synchronized in a way that guarantees deadlock freedom, determinism, and that the program can be serialized by removing all task related keywords.   These properties rely on the program being free of data-race. Data-race is where two tasks access the same memory and at least one access is a write.  Data-race introduces non-determinism into the program and undermines the correctness guarantees provided by the task abstraction. It is also hard to detect statically or dynamically in a program.   The primary outcomes for the research from this grant center around proving data-race freedom in idiomatic parallel programs. The research uses Habanero for the programming model and provides several artifacts for the Java implementation of Habanero to support data-race freedom verification. The first outcome is a Habanero runtime for test, debug, and verification. Most data-race approaches focus on detection rather than verification and utilize a full production runtime; low overhead and minimal impact on runtime performance are the primary goals. Research in this grant rather focuses on proving data-race freedom and provides a runtime that is well suited for running standalone for test, in a debugger, or in a model checker for verification.  The runtime leaves behind complex task implementations and the complicated ways to work steal, load balance, and schedule tasks. Performance is not the primary objective. Rather the objective is simplicity over performance so that practitioners are able to first test, debug, and understand the parallel program before deploying it on a full-scale production system. As such the Habanero Java verification runtime works seamlessly in the Java Pathfinder (JPF) model checker with no modification to JPF and uses a simple thread implementation for the task abstraction. It is small and simple enough to be reasonably argued by code inspection that is a faithful implementation of the Habanero model.  The second outcome is a collection of data-race verification algorithms integrated into JPF for the Habanero model with a rich collection of common data-race benchmarks collected from recent and past publications, other benchmark suites, and corner cases that arise in algorithm development. The new algorithms in this research center around the computation graph that captures concurrency in the program execution as a partial order and blend concepts from existing algorithms that use partial orders and access sets to detect data-race. The algorithms are shown in results on the benchmark suite to be more efficient in time and space in proving data-race freedom. These are available, with the Habanero runtime, at https://bitbucket.org/byu-vv/jpf-hj/src/master/ and https://bitbucket.org/byu-vv/jpf-hj/src/master/.  The third outcome is a much deeper understanding of data race detection using partial orders and that in idiomatic parallel programs using access sets.  This research blends ideas from both approaches and shows where one approach is preferred over the other based not just on program structure but the number of shared objects. It further takes the partial order approaches and weakens those relations to the point where they become unsound for general concurrency but still absolutely sound for idiomatic programs due to how they limit synchronization between tasks.  The weakest partial order in this research is the does-not-commute partial order, and that is proven to be sound in idiomatic parallel programs with mutual exclusion. This result includes a mechanical proof in Coq of the soundness and an implementation in JPF showing a significant reduction in the number of schedules needed to prove data-race freedom in Habanero programs.  The broader impact of the research from this grant is the accessibility of the tools to a larger community of practitioners and researchers.  The JPF extension includes the implementation of several state-of-art data-race detection algorithms as well as the algorithms in this research. It also includes in one place a rich set of benchmarks that are now characterized over these several algorithms. These are all freely available for download. The distribution also includes a build system to simplify not just the build but test automation, regression, and experiments on the benchmarks. This single source of algorithms and benchmarks built on the open source JPF model checker with the Habanero verification runtime enables practitioners to build better systems and researchers to better characterize new contributions and applications.   Finally the research in this grant has involved a diverse set of students giving them opportunity to research problems that are hard to solve and may not even have workable solutions. These students have untold impact as they go forward and grow the reach of concurrent systems and shape the future of concurrent programming models in systems and society.       Last Modified: 05/17/2019       Submitted by: Eric G Mercer]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
