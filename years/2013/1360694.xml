<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER:  Bridging the Gap Between Prototyping and Production</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2013</AwardEffectiveDate>
<AwardExpirationDate>02/29/2016</AwardExpirationDate>
<AwardTotalIntnAmount>407022.00</AwardTotalIntnAmount>
<AwardAmount>407022</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Modern software engineering methods improve programmer productivity by taking an incremental approach to software development. Software engineers rapidly develop prototypes and then iteratively refine the prototypes into production systems.  However, today's programming systems do not support a smooth transition from prototyping to production. On one hand, scripting languages and interactive environments support prototyping while on the other hand conventional programming languages and optimizing compilers support the development of reusable and efficient production codes. Neither support both prototyping and production, so developers use a mixture of programming systems.  This practice incurs many costs such as the impedance mismatch of inter-language data transfers and the time to translate programs between languages.&lt;br/&gt;&lt;br/&gt;The goal of this research is to discover the scientific principles necessary for a single programming system to effectively support the incremental refinement of prototypes into production software. To accomplish this research objective, classic conflicts between flexibility and safety and between abstraction and performance need to be resolved. To achieve both flexibility and safety, the research will investigate ways to combine dynamic and static type checking, using an approach called gradual typing. To achieve both abstraction and performance, the research will develop a domain-specific compiler for linear algebra and show how show how high-level abstractions can provide greater opportunities for compiler optimization than conventional abstractions such as loops and scalar operations. The broader impacts of the project arise from improvements to programmer productivity and software quality.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>09/26/2013</MinAmdLetterDate>
<MaxAmdLetterDate>09/26/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1360694</AwardID>
<Investigator>
<FirstName>Jeremy</FirstName>
<LastName>Siek</LastName>
<PI_MID_INIT>G</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Jeremy G Siek</PI_FULL_NAME>
<EmailAddress>jsiek@indiana.edu</EmailAddress>
<PI_PHON>3037480532</PI_PHON>
<NSF_ID>000086759</NSF_ID>
<StartDate>09/26/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Indiana University</Name>
<CityName>Bloomington</CityName>
<ZipCode>474013654</ZipCode>
<PhoneNumber>3172783473</PhoneNumber>
<StreetAddress>509 E 3RD ST</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN09</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>006046700</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF INDIANA UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>006046700</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Indiana University]]></Name>
<CityName>Bloomington</CityName>
<StateCode>IN</StateCode>
<ZipCode>474013654</ZipCode>
<StreetAddress><![CDATA[509 E 3RD ST]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN09</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>K606</Code>
<Text/>
</ProgramElement>
<ProgramElement>
<Code>L513</Code>
<Text/>
</ProgramElement>
<ProgramElement>
<Code>M531</Code>
<Text/>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>7798</Code>
<Text>SOFTWARE &amp; HARDWARE FOUNDATION</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~2489</FUND_OBLG>
<FUND_OBLG>2012~210376</FUND_OBLG>
<FUND_OBLG>2013~194157</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Incremental development is an essential feature of modern software<br />engineering and greatly improves programmer productivity. Software<br />teams rapidly develop prototypes and then iteratively refine the<br />prototypes into production systems. However, today&rsquo;s programming<br />systems do not support a smooth transition from prototyping to<br />production. On one hand, dynamic languages such as MATLAB and Python<br />support prototyping while on the other hand static languages such as<br />C++ and Java support the development of reusable and efficient<br />production codes. Neither support both prototyping and production, so<br />developers use a mixture of programming systems. This practice incurs<br />many costs such as the impedance mismatches of inter-language data<br />transfers and the time to translate programs between languages.<br /><br />The goal of the project "CAREER: Bridging the Gap Between Prototyping<br />and Production" was to make progress towards having a single<br />programming system that would support a gradual transition from<br />prototyping to production. To accomplish the research objective, the<br />long-standing conflicts between flexibility and safety and between<br />abstraction and performance need to be resolved.&nbsp; Regarding flexibilty<br />versus safety, the project investigated the idea of gradual typing,<br />which combines both static and dynamic type checking within the same<br />language. Regarding abstraction and performance, the project<br />investigated the compilation of a high-level language for matrix<br />algebra into high-performance code. We discuss the scientific<br />accomplishments on these two lines of research in the following<br />paragraphs.&nbsp; But to summarize the outputs of the project, we published<br />18 papers including 9 at high-impact conferences and journals. We<br />graduated 2 Ph.D. students and 2 M.S. students and 3 more<br />Ph.D. students are in progress. The project also produced two software<br />artifacts that have been released to the public, a gradually typed<br />version of the Python programming language, and the Build-to-Order<br />Basic Linear Algebra Subroutines, about which we will say more below.<br /><br />The project made significant discoveries regarding both the theory and<br />practice of gradual typing. On the theory side, we discovered how to<br />integrate gradual typing with parametric polymorphism (aka. generics)<br />in a way that preserves "parametricity", which is import for reasoning<br />about the correctness of polymorphic procedures.&nbsp; We solved the space<br />complexity problem that arises from the use of proxies to ensure the<br />safety of statically typed code that interacts with dynamically typed<br />code. We also solved problems regarding runtime overhead in statically<br />typed code (not just in partially typed or dynamically typed<br />code). Finally, we developed formal criteria to better characterize<br />when a language design satisfies the intent of gradual typing.<br /><br />Regarding the practice of gradual typing, we designed and implemented<br />a gradually typed variant of Python, named Reticulated Python.&nbsp; We<br />encountered a number of challenges along the way and invented<br />solutions to them, including "transient casts", which guarantee the<br />safety of statically typed code without using proxies, thereby<br />avoiding interoperability problems that we encountered regarding plain<br />Python code and with code written in C (parts of the Python standard<br />library, and many extensions). Another significant challenge to<br />gradual typing is that the performance of partially typed code can<br />degrade significantly. To solve this problem, we have initiated two<br />projects. We are investigating whether just-in-time compilation can<br />improve performance by implementing the Racket language using the<br />RPython framework. In the second project, we are building a native<br />code ahead-of-time compiler that implements the theoretical advances<br />mentioned above.&nbsp; So far, both the just-in-time and ahead-of-time<br />compilers are showing promise and delivering good performance on<br />benchmark programs.<br /><br />The second line of research in this project was in the compilation of<br />a language for matrix algebra into high-performance parallel code.<br />The goal of our compiler was to produce the best-possible code for a<br />particular combination of matrix operations. For example, it compiles<br />the input program<br />&nbsp;&nbsp;&nbsp; y := b * A' * (A * x)<br />into low-level C code that is organized to make best use of multiple<br />processors and the multiple levels of cache memory within a computer.<br />The code transformations to accomplish this are well known: loop<br />fusion, array contraction, and data parallel loops.&nbsp; However, the the<br />techniques are not beneficial in every situation, so the challenge is<br />finding the the best combination of transformations for a given input<br />program and target computer architecture. Thus, the essense of the<br />problem is mathematical optimization and search. We evaluated a wide<br />variety of search techniques, including genetic algorithms and<br />hill-climbing, and we developed a new heuristic/greedy search<br />algorithm.&nbsp; We found that the best approach was a hybrid that started<br />with our greedy search and then finished with a genetic search.&nbsp; With<br />this approach we were able to generate code for a wide range of<br />real-world matrix computations that was just as efficient as code<br />produced by a human expert and that out-performed the best<br />general-purpose loop-optimizing compilers.</p><br> <p>            Last Modified: 11/17/2016<br>      Modified by: Jeremy&nbsp;G&nbsp;Siek</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Incremental development is an essential feature of modern software engineering and greatly improves programmer productivity. Software teams rapidly develop prototypes and then iteratively refine the prototypes into production systems. However, today?s programming systems do not support a smooth transition from prototyping to production. On one hand, dynamic languages such as MATLAB and Python support prototyping while on the other hand static languages such as C++ and Java support the development of reusable and efficient production codes. Neither support both prototyping and production, so developers use a mixture of programming systems. This practice incurs many costs such as the impedance mismatches of inter-language data transfers and the time to translate programs between languages.  The goal of the project "CAREER: Bridging the Gap Between Prototyping and Production" was to make progress towards having a single programming system that would support a gradual transition from prototyping to production. To accomplish the research objective, the long-standing conflicts between flexibility and safety and between abstraction and performance need to be resolved.  Regarding flexibilty versus safety, the project investigated the idea of gradual typing, which combines both static and dynamic type checking within the same language. Regarding abstraction and performance, the project investigated the compilation of a high-level language for matrix algebra into high-performance code. We discuss the scientific accomplishments on these two lines of research in the following paragraphs.  But to summarize the outputs of the project, we published 18 papers including 9 at high-impact conferences and journals. We graduated 2 Ph.D. students and 2 M.S. students and 3 more Ph.D. students are in progress. The project also produced two software artifacts that have been released to the public, a gradually typed version of the Python programming language, and the Build-to-Order Basic Linear Algebra Subroutines, about which we will say more below.  The project made significant discoveries regarding both the theory and practice of gradual typing. On the theory side, we discovered how to integrate gradual typing with parametric polymorphism (aka. generics) in a way that preserves "parametricity", which is import for reasoning about the correctness of polymorphic procedures.  We solved the space complexity problem that arises from the use of proxies to ensure the safety of statically typed code that interacts with dynamically typed code. We also solved problems regarding runtime overhead in statically typed code (not just in partially typed or dynamically typed code). Finally, we developed formal criteria to better characterize when a language design satisfies the intent of gradual typing.  Regarding the practice of gradual typing, we designed and implemented a gradually typed variant of Python, named Reticulated Python.  We encountered a number of challenges along the way and invented solutions to them, including "transient casts", which guarantee the safety of statically typed code without using proxies, thereby avoiding interoperability problems that we encountered regarding plain Python code and with code written in C (parts of the Python standard library, and many extensions). Another significant challenge to gradual typing is that the performance of partially typed code can degrade significantly. To solve this problem, we have initiated two projects. We are investigating whether just-in-time compilation can improve performance by implementing the Racket language using the RPython framework. In the second project, we are building a native code ahead-of-time compiler that implements the theoretical advances mentioned above.  So far, both the just-in-time and ahead-of-time compilers are showing promise and delivering good performance on benchmark programs.  The second line of research in this project was in the compilation of a language for matrix algebra into high-performance parallel code. The goal of our compiler was to produce the best-possible code for a particular combination of matrix operations. For example, it compiles the input program     y := b * A' * (A * x) into low-level C code that is organized to make best use of multiple processors and the multiple levels of cache memory within a computer. The code transformations to accomplish this are well known: loop fusion, array contraction, and data parallel loops.  However, the the techniques are not beneficial in every situation, so the challenge is finding the the best combination of transformations for a given input program and target computer architecture. Thus, the essense of the problem is mathematical optimization and search. We evaluated a wide variety of search techniques, including genetic algorithms and hill-climbing, and we developed a new heuristic/greedy search algorithm.  We found that the best approach was a hybrid that started with our greedy search and then finished with a genetic search.  With this approach we were able to generate code for a wide range of real-world matrix computations that was just as efficient as code produced by a human expert and that out-performed the best general-purpose loop-optimizing compilers.       Last Modified: 11/17/2016       Submitted by: Jeremy G Siek]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
