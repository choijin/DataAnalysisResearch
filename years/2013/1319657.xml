<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Small: Scripting at the Speed of C</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2013</AwardEffectiveDate>
<AwardExpirationDate>06/30/2018</AwardExpirationDate>
<AwardTotalIntnAmount>475000.00</AwardTotalIntnAmount>
<AwardAmount>475000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Software developers are increasingly using dynamic scripting languages not only for quickly prototyping or as "glue"code, but also to write large applications. Programmers like scripting languages because they have the flexibility of simply using a variable when needed, without having to declare it. This results in fewer lines of code and allows for faster code development. Unfortunately the same features that make dynamic scripting languages more productive, make them hard to generate efficient code for.&lt;br/&gt;&lt;br/&gt;This project is working on a hardware-software solution to enable programs written using dynamic scripting languages to run as fast as statically typed languages, such as C, C++ or Java. To that end, this project is working on the design of new program transformations that can generate highly efficient code by taking advantage of innovative hardware support that detects if the assumptions done when generating the code are correct. Additionally, novel hardware provides to the compiler information that enables even more aggressive optimizations. Hardware and software designs are driven by the results obtained from a study that analyzes the main sources of overhead of scripting languages. The research in this project will result in higher programmer productivity and will enable the use of scripting languages in domains where they are not used today.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>06/25/2013</MinAmdLetterDate>
<MaxAmdLetterDate>06/25/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1319657</AwardID>
<Investigator>
<FirstName>Maria</FirstName>
<LastName>Garzaran</LastName>
<PI_MID_INIT>J</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Maria J Garzaran</PI_FULL_NAME>
<EmailAddress>garzaran@cs.uiuc.edu</EmailAddress>
<PI_PHON>2172448878</PI_PHON>
<NSF_ID>000297030</NSF_ID>
<StartDate>06/25/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Daniel</FirstName>
<LastName>Ahn</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Daniel Ahn</PI_FULL_NAME>
<EmailAddress>wahn@pitt.edu</EmailAddress>
<PI_PHON>4126248419</PI_PHON>
<NSF_ID>000635693</NSF_ID>
<StartDate>06/25/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Illinois at Urbana-Champaign</Name>
<CityName>Champaign</CityName>
<ZipCode>618207406</ZipCode>
<PhoneNumber>2173332187</PhoneNumber>
<StreetAddress>1901 South First Street</StreetAddress>
<StreetAddress2><![CDATA[Suite A]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<StateCode>IL</StateCode>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IL13</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>041544081</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF ILLINOIS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041544081</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Illinois at Urbana-Champaign]]></Name>
<CityName/>
<StateCode>IL</StateCode>
<ZipCode>618207473</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IL13</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9102</Code>
<Text>WOMEN, MINORITY, DISABLED, NEC</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~475000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software developers are increasingly using dynamic scripting languages,&nbsp;such as JavaScript, Perl, Python, Ruby or PHP. However, C programs still&nbsp;run significantly faster than them. This project&rsquo;s goal is to investigate&nbsp;techniques to enable programs written using dynamic scripting languages&nbsp;to run as fast as languages such as C, C++ or Java. To accomplish this,we carefully characterized the performance bottlenecks of these types oflanguages, and then devised novel hardware-software techniques to speedthem up.&nbsp;</p> <p>The outcomes of this work have been several new ideas that we have&nbsp;published and discussed with Intel, and the support of two graduate&nbsp;research assistants for several years.</p> <p>One of the outcomes of this work is an understanding of why currentcompiler optimizations for JavaScript do not work well for websiteworkloads. The reason is that it is hard to predict what data typeeach access requires. The compiler can hardly anticipate the type&nbsp;of an object at a site of the code where the object is read or written.&nbsp;We have discovered that this is due to two unexpected sources: prototypes&nbsp;and method bindings. These are constructs that obfuscate the operationof the compiler. As a result, we restructure the Google JavaScriptcompiler. Our results show large improvements for these dynamic workloads:&nbsp;on average, we reduce the execution time of a benchmark suite by 36%,&nbsp;and the dynamic instruction count by 49%.</p> <p>Another outcome has been a new approach to reuse the state of JavaScript&nbsp;programs across program invocations. In current systems, it takes toolong to start a JavaScript program. Consequently, we proposethat, after a program terminates, it saves some state that will be used&nbsp;the next time that the program is invoked. Specifically, we propose to&nbsp;save some initial compilation of important parts of the program (i.e.,&nbsp;selective compilation), and have some state of the program warmed-upbefore the program starts. The result shows that, under certain&nbsp;conditions, our enhancements reduce execution time by 42%, and dynamic&nbsp;instruction count by 40%.</p> <p>A third outcome is a new idea to speed-up JavaScript programsby enabling processors to predict the outcome of the branches inthe code better. We find that, every time there is a load or a storeto an object in the program, the compiler inserts a call toa dispatcher subroutine. The dispatcher has many comparisons to&nbsp;different types and then a jump to a subroutine that performs the&nbsp;load or store. This dispatcher has poor branch prediction. Hence, wemodify the instruction that calls the dispatcher so that, under typical&nbsp;conditions, it skips most of the instructions. This is possible thanksto a new hardware table that predicts past types seen in thiscode location.&nbsp;</p> <p>The final idea is to speed-up JavaScript execution by optimizingtheir operation of their compilers. Specifically, popular compilersare organized in multiple tiers, with higher tiers using profiling&nbsp;information to generate high-performance code. In such tiers,checks are inserted to detect incorrect assumptions and, when a check&nbsp;fails, execution transfers to a lower tier. The points of potential&nbsp;transfer between tiers are full of checks. To minimize the overhead,&nbsp;we extend the compiler to emit code that places a hardware transactionaround these checks. Then, we can optimize and sometimes eliminate&nbsp;the checks away inside a transaction, improving the performance by 10-20%.</p> <p>Under this project, we have trained graduate and undergraduate students&nbsp;in the Computer Science Department of the University of Illinois. They&nbsp;have been exposed to research in compilers and computer architecture. They&nbsp;have also collaborated with many researchers from multiple companies and&nbsp;universities.</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/25/2018<br>      Modified by: Maria&nbsp;J&nbsp;Garzaran</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Image         </div> <div class="galControls onePhoto" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation onePhoto" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2018/1319657/1319657_10254059_1537850091011_struct2--rgov-214x142.jpg" original="/por/images/Reports/POR/2018/1319657/1319657_10254059_1537850091011_struct2--rgov-800width.jpg" title="structure"><img src="/por/images/Reports/POR/2018/1319657/1319657_10254059_1537850091011_struct2--rgov-66x44.jpg" alt="structure"></a> <div class="imageCaptionContainer"> <div class="imageCaption">Example of object structures and links between them in JavaScript</div> <div class="imageCredit">Wonsun Ahn</div> <div class="imagePermisssions">Copyright owner is an institution with an existing agreement allowing use by NSF</div> <div class="imageSubmitted">Maria&nbsp;J&nbsp;Garzaran</div> <div class="imageTitle">structure</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Software developers are increasingly using dynamic scripting languages, such as JavaScript, Perl, Python, Ruby or PHP. However, C programs still run significantly faster than them. This project?s goal is to investigate techniques to enable programs written using dynamic scripting languages to run as fast as languages such as C, C++ or Java. To accomplish this,we carefully characterized the performance bottlenecks of these types oflanguages, and then devised novel hardware-software techniques to speedthem up.   The outcomes of this work have been several new ideas that we have published and discussed with Intel, and the support of two graduate research assistants for several years.  One of the outcomes of this work is an understanding of why currentcompiler optimizations for JavaScript do not work well for websiteworkloads. The reason is that it is hard to predict what data typeeach access requires. The compiler can hardly anticipate the type of an object at a site of the code where the object is read or written. We have discovered that this is due to two unexpected sources: prototypes and method bindings. These are constructs that obfuscate the operationof the compiler. As a result, we restructure the Google JavaScriptcompiler. Our results show large improvements for these dynamic workloads: on average, we reduce the execution time of a benchmark suite by 36%, and the dynamic instruction count by 49%.  Another outcome has been a new approach to reuse the state of JavaScript programs across program invocations. In current systems, it takes toolong to start a JavaScript program. Consequently, we proposethat, after a program terminates, it saves some state that will be used the next time that the program is invoked. Specifically, we propose to save some initial compilation of important parts of the program (i.e., selective compilation), and have some state of the program warmed-upbefore the program starts. The result shows that, under certain conditions, our enhancements reduce execution time by 42%, and dynamic instruction count by 40%.  A third outcome is a new idea to speed-up JavaScript programsby enabling processors to predict the outcome of the branches inthe code better. We find that, every time there is a load or a storeto an object in the program, the compiler inserts a call toa dispatcher subroutine. The dispatcher has many comparisons to different types and then a jump to a subroutine that performs the load or store. This dispatcher has poor branch prediction. Hence, wemodify the instruction that calls the dispatcher so that, under typical conditions, it skips most of the instructions. This is possible thanksto a new hardware table that predicts past types seen in thiscode location.   The final idea is to speed-up JavaScript execution by optimizingtheir operation of their compilers. Specifically, popular compilersare organized in multiple tiers, with higher tiers using profiling information to generate high-performance code. In such tiers,checks are inserted to detect incorrect assumptions and, when a check fails, execution transfers to a lower tier. The points of potential transfer between tiers are full of checks. To minimize the overhead, we extend the compiler to emit code that places a hardware transactionaround these checks. Then, we can optimize and sometimes eliminate the checks away inside a transaction, improving the performance by 10-20%.  Under this project, we have trained graduate and undergraduate students in the Computer Science Department of the University of Illinois. They have been exposed to research in compilers and computer architecture. They have also collaborated with many researchers from multiple companies and universities.          Last Modified: 09/25/2018       Submitted by: Maria J Garzaran]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
