<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Network Flow Approach to Functional Verification of Arithmetic Circuits</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>350000.00</AwardTotalIntnAmount>
<AwardAmount>374000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>With the ever-increasing size and complexity of microelectronic systems, hardware verification has become a dominating factor of the overall design flow. One promising approach is formal functional verification of arithmetic circuits, which attempts to prove correctness of the design with respect to its intended arithmetic function. This problem is particularly challenging since Boolean techniques, traditionally used in verification of control logic, are not scalable to complex arithmetic designs. Efficient solutions to this problem will contribute to the development of state-of-the-art tools for circuit verification, increase design productivity, and lower the design development cost and consumer prices. &lt;br/&gt;&lt;br/&gt;The goal of this project is to develop efficient solution to verification of arithmetic circuits without resorting to expensive Boolean techniques. It will be accomplished by modeling the problem as a Network Flow problem, in which the circuit is represented as a network of standard arithmetic components. The computation performed by the circuit is modeled as a flow of binary data and represented as an algebraic, pseudo-Boolean expression. Functional correctness of the circuit is proved by transforming the algebraic flow expression at the primary inputs into an expression at the primary outputs and checking if it matches the binary encoding of the output. The method also offers a way to extract the arithmetic function implemented by the circuit and identify bugs in the design. The technique are applicable to complex arithmetic circuits, such as newly developed adders, large multipliers, arithmetic logic units, and other components of combinational and sequential data paths implementing complex instructions.</AbstractNarration>
<MinAmdLetterDate>08/21/2013</MinAmdLetterDate>
<MaxAmdLetterDate>01/14/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1319496</AwardID>
<Investigator>
<FirstName>Maciej</FirstName>
<LastName>Ciesielski</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Maciej Ciesielski</PI_FULL_NAME>
<EmailAddress>ciesiel@ecs.umass.edu</EmailAddress>
<PI_PHON>4135450401</PI_PHON>
<NSF_ID>000209810</NSF_ID>
<StartDate>08/21/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Massachusetts Amherst</Name>
<CityName>Hadley</CityName>
<ZipCode>010359450</ZipCode>
<PhoneNumber>4135450698</PhoneNumber>
<StreetAddress>Research Administration Building</StreetAddress>
<StreetAddress2><![CDATA[100 Venture Way, Suite 201]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>153926712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF MASSACHUSETTS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>079520631</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Massachusetts Amherst]]></Name>
<CityName>Amherst</CityName>
<StateCode>MA</StateCode>
<ZipCode>010039284</ZipCode>
<StreetAddress><![CDATA[151 Holdsworth Way]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~350000</FUND_OBLG>
<FUND_OBLG>2014~8000</FUND_OBLG>
<FUND_OBLG>2015~16000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The goal of the project was to develop an efficient method for functional verification of arithmetic circuits, that is circuits that compute arithmetic function. Verification of such circuits is of great importance due to a growing use of arithmetic modules in embedded systems, signal processing, and multi-media applications. Of particular interest are circuits that compute arithmetic functions in integer domain, used heavily in cryptography applications. They include complex adders, large multipliers, fused add-multiply units and other components of arithmetic datapaths. The goal of functional verification is to verify if the circuit performs the intended arithmetic function, or detect the source of error.&nbsp; In general, complex arithmetic circuits are difficult to verify using Boolean methods, developed for logic circuits, as they operate on a bit-level circuit representation. Arithmetic circuits transformed into a bit-level form make the verification problem too complex for traditional Boolean algorithms. <br /><br />The verification method developed in this project departs from bit-level representation and instead represents the design in an algebraic domain. In this <br />representation both the specification and the circuit components (one-bit adders and logic gates) are represented as polynomial expressions. The computation performed by an arithmetic circuit is then viewed as a flow of binary data, from the inputs to the outputs, in the network composed of one-bit adders and logic gates. In this context the proof of functional correctness is achieved by transforming the polynomial specification at the inputs into a polynomial at the primary outputs, using algebraic models of the circuit components. If the resulting expression matches the binary encoding of the outputs the circuit is correct; otherwise the circuit implementation is incorrect. The proof can also be done in the opposite direction, by transforming the expression at the primary outputs into a unique expression at the primary inputs, using algebraic models of circuit's components. The resulting expression is checked if it matches the specification polynomial, if the specification is known; otherwise the method can be used as function extraction, to determine the arithmetic function implemented by the function. <br /><br />The function extraction technique based on backward rewriting has been implemented as a computer program and tested on a large number of standard <br />and nonstandard arithmetic circuits, both original and synthesized. The results demonstrate scalability of the method to large arithmetic circuits, such as multipliers, multiply-accumulate, and other elements of arithmetic datapaths with up to 512-bit operands containing over two million gates. The results are <br />superior compared to the state-of-the-art formal verification solvers by several orders of magnitude of CPU time. The project has been described in peer-reviewedd journal publications and presented in a number of international conferences and published in the conference proceedings. The software implementing this method has been made available in public domain</p><br> <p>            Last Modified: 11/02/2017<br>      Modified by: Maciej&nbsp;Ciesielski</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The goal of the project was to develop an efficient method for functional verification of arithmetic circuits, that is circuits that compute arithmetic function. Verification of such circuits is of great importance due to a growing use of arithmetic modules in embedded systems, signal processing, and multi-media applications. Of particular interest are circuits that compute arithmetic functions in integer domain, used heavily in cryptography applications. They include complex adders, large multipliers, fused add-multiply units and other components of arithmetic datapaths. The goal of functional verification is to verify if the circuit performs the intended arithmetic function, or detect the source of error.  In general, complex arithmetic circuits are difficult to verify using Boolean methods, developed for logic circuits, as they operate on a bit-level circuit representation. Arithmetic circuits transformed into a bit-level form make the verification problem too complex for traditional Boolean algorithms.   The verification method developed in this project departs from bit-level representation and instead represents the design in an algebraic domain. In this  representation both the specification and the circuit components (one-bit adders and logic gates) are represented as polynomial expressions. The computation performed by an arithmetic circuit is then viewed as a flow of binary data, from the inputs to the outputs, in the network composed of one-bit adders and logic gates. In this context the proof of functional correctness is achieved by transforming the polynomial specification at the inputs into a polynomial at the primary outputs, using algebraic models of the circuit components. If the resulting expression matches the binary encoding of the outputs the circuit is correct; otherwise the circuit implementation is incorrect. The proof can also be done in the opposite direction, by transforming the expression at the primary outputs into a unique expression at the primary inputs, using algebraic models of circuit's components. The resulting expression is checked if it matches the specification polynomial, if the specification is known; otherwise the method can be used as function extraction, to determine the arithmetic function implemented by the function.   The function extraction technique based on backward rewriting has been implemented as a computer program and tested on a large number of standard  and nonstandard arithmetic circuits, both original and synthesized. The results demonstrate scalability of the method to large arithmetic circuits, such as multipliers, multiply-accumulate, and other elements of arithmetic datapaths with up to 512-bit operands containing over two million gates. The results are  superior compared to the state-of-the-art formal verification solvers by several orders of magnitude of CPU time. The project has been described in peer-reviewedd journal publications and presented in a number of international conferences and published in the conference proceedings. The software implementing this method has been made available in public domain       Last Modified: 11/02/2017       Submitted by: Maciej Ciesielski]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
