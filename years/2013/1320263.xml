<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Light-weight Architectural Schemes for Resilient  High-performance Microprocessors</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2013</AwardEffectiveDate>
<AwardExpirationDate>06/30/2017</AwardExpirationDate>
<AwardTotalIntnAmount>492844.00</AwardTotalIntnAmount>
<AwardAmount>492844</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>tao li</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>In future technology generations, smaller and more transistors  &lt;br/&gt;operating at low supply voltages and high clock speeds will be  &lt;br/&gt;increasingly susceptible to many different resiliency problems, such  &lt;br/&gt;as soft errors, wear-out issues, hard errors, and off- and on-chip bus  &lt;br/&gt;bit errors. These errors may cause silent data corruption, application  &lt;br/&gt;aborts, or system crashes in high-performance microprocessors and  &lt;br/&gt;computer systems. Previous techniques for addressing these errors  &lt;br/&gt;incur significant performance and power overheads despite  &lt;br/&gt;optimizations, and often require invasive changes that incur high  &lt;br/&gt;implementation complexity.&lt;br/&gt;&lt;br/&gt;In this research project, the investigators propose a novel,  &lt;br/&gt;light-weight, yet highly-effective architectural approach to processor  &lt;br/&gt;reliability that incurs much lower overheads than existing approaches  &lt;br/&gt;by leveraging key architectural observations about the problems.&lt;br/&gt;&lt;br/&gt;This project's innovative approach for the detection of soft errors,  &lt;br/&gt;wear-out, and hard errors is based on detecting execution anomalies  &lt;br/&gt;that are triggered by errors, without using redundant execution. By  &lt;br/&gt;exploiting the notion of value locality, this project generalizes  &lt;br/&gt;anomalies to include unexpected values as well as conditions (e.g.,  &lt;br/&gt;memory access exceptions) and provides significant coverage which  &lt;br/&gt;includes the most problematic cases of silent data corruption. For  &lt;br/&gt;recovery from soft errors, the project's investigators propose a  &lt;br/&gt;retry-based scheme that avoids adding any hardware overhead to achieve  &lt;br/&gt;recovery by using existing spare speculative resources in the  &lt;br/&gt;processor. For off-chip bus bit errors, the investigators propose a  &lt;br/&gt;novel bit interleaving scheme that reduces the chances of multiple  &lt;br/&gt;bits in a single error correcting code (ECC)-protected data unit being &lt;br/&gt;corrupted undetectably or uncorrectably. Like the other schemes, this&lt;br/&gt;interleaving imposes minimal power, performance, and complexity overhead.&lt;br/&gt;&lt;br/&gt;This project targets achieving reliability while keeping power,  &lt;br/&gt;performance, and hardware overheads low, an important goal for the  &lt;br/&gt;U.S. microprocessor and computer hardware industry.  The project's  &lt;br/&gt;investigators are committed to releasing the research artifacts as  &lt;br/&gt;open-source software to be used by the research community. The  &lt;br/&gt;graduate students working on this project will be trained in  &lt;br/&gt;architecture and reliability issues and will be well-positioned to  &lt;br/&gt;join the U.S. computer hardware industry. This project will also  &lt;br/&gt;support educational activities such as homework and term projects in  &lt;br/&gt;undergraduate and graduate courses as well as outreach activities of  &lt;br/&gt;various centers at Purdue with which the investigators are involved.  &lt;br/&gt;With a woman as one of the investigators, the project will act as a  &lt;br/&gt;basis for encouraging women to join graduate programs in electrical  &lt;br/&gt;and computer engineering.</AbstractNarration>
<MinAmdLetterDate>06/27/2013</MinAmdLetterDate>
<MaxAmdLetterDate>06/27/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1320263</AwardID>
<Investigator>
<FirstName>Irith</FirstName>
<LastName>Pomeranz</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Irith Pomeranz</PI_FULL_NAME>
<EmailAddress>pomeranz@ecn.purdue.edu</EmailAddress>
<PI_PHON>7654943357</PI_PHON>
<NSF_ID>000387349</NSF_ID>
<StartDate>06/27/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>T.</FirstName>
<LastName>Vijaykumar</LastName>
<PI_MID_INIT>N</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>T. N Vijaykumar</PI_FULL_NAME>
<EmailAddress>vijay@ecn.purdue.edu</EmailAddress>
<PI_PHON>7654940592</PI_PHON>
<NSF_ID>000337724</NSF_ID>
<StartDate>06/27/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Purdue University</Name>
<CityName>West Lafayette</CityName>
<ZipCode>479072114</ZipCode>
<PhoneNumber>7654941055</PhoneNumber>
<StreetAddress>Young Hall</StreetAddress>
<StreetAddress2><![CDATA[155 S Grant Street]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>072051394</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PURDUE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>072051394</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Purdue University]]></Name>
<CityName/>
<StateCode>IN</StateCode>
<ZipCode>479072017</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7941</Code>
<Text>COMPUTER ARCHITECTURE</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7941</Code>
<Text>COMPUTER ARCHITECTURE</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~492844</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Soft error susceptibility is a growing concern with continued CMOS scaling in modern, high-performance, general-purpose microprocessors. Smaller transistors and lower voltages achieve by contiued scaling&nbsp; exacerbate the soft error problem. Previous work explores full- and partial-redundancy schemes in hardware and software for soft-fault tolerance. However, full-redundancy schemes incur high performance and energy overheads whereas partial-redundancy schemes achieve low coverage.</p> <p>Value locality is well-known where values generated&nbsp; in a computation fall within small neighborhoods in the value space, rather than be&nbsp; spread arbitrarily &nbsp; over the entire value space. Previous value-locality efforts have attempted to improve performance by&nbsp; exploiting&nbsp; value localityto predict values faster than they can be&nbsp; computed due to inherent long latencies such as cache misses. This project&nbsp; exploits  value locaity to detect soft errors which  would usually perturb a value  making it fall outside value locality  neighborhoods. Such detection does not require redundancy and therefore can avoid the corresponding overheads. To this end, the authors&nbsp;  employ hardware filters that capture value locality  neighborhoods by  capturing which bit positions are unchanging &nbsp;0's or  1's and which  positions change so that a new value matching in the  unchanging  positions does not flag an error and does otherwise. Upon  detection, the authors&nbsp;  leverage modern processor pipeline's in-built abiltiy to  roll-back  computation to try to correct the error. Because the  roll-back (i.e.,  redundant execution) occurs only when an error is  flagged or on a false  postiive (which are about 2% of all  instructions), the proposed&nbsp; method acheives  lower power and performance  overheads than previous full-redundancy  approaches.</p> <p>In contrast to value prediction for performance where the prediciton has to exactly match the actual value, exploiting value locality to detect soft errors has to&nbsp; be accurate enough to detect value perturbation without &nbsp; prediction the value with 100% accuracy.&nbsp; An initial study, called Perturbation Based Fault Screening (PBFS), explored exploiting value locality to provide hints<br />of soft faults whenever a value falls outside its neighborhood.&nbsp; However, PBFS achieves low coverage; straightforwardly improving the coverage results in high false-positive rates, and performance and energy overheads.</p> <p>The authors propose FaultHound, a value-locality-based soft-fault tolerance scheme, which employs five novel mechanisms to address PBFS&rsquo;s limitations: (1) a scheme to cluster the filters via an inverted organization of the filter tables to reinforce learning and reduce the false-positive rates; (2) a learning scheme for ignoring the delinquent bit positions that raise repeated false alarms, to reduce further the false- positive rate; (3) a light-weight predecessor replay scheme instead of a full rollback to reduce the performance and energy penalty of the remaining false positives; (4) a simple scheme to distinguish rename faults, which require rollback instead of replay for recovery, from false positives to avoid unnecessary rollback penalty; and (5) a detection scheme, which avoids rollback, for the load-store queue which is not covered by the&nbsp; replay. Using simulations, the authors&nbsp; show that while PBFS achieves either low coverage (30%), or high false-positive rates (8%) with high performance overheads (97%), FaultHound achieves higher coverage (75%) and lower false-positive rates (3%) with lower performance and energy overheads (10% and 25%). Further, full-redundancy schemes scaled to achieve equal coverage of 75% result in&nbsp;  13% performance loss and 57% energy overheads. These results are for a  broad range of benchmarks which include commercial workloads (TPC-C-ilke online transaction processing, SPECjbb, and apache webserver), SPECint,  SPECFP, and SPLASH.</p> <p>Considering all the three metrics of coverage, performance and energy overheads, FaultHound performs better than previous redundancy-based and value-locality-based schemes which perform well against only one or two of these metrics. Because of this attractive combination of features, FaultHound will likely be important in the path of continued CMOS&nbsp; scaling in modern microprocessors.</p><br> <p>            Last Modified: 09/28/2017<br>      Modified by: T.&nbsp;N&nbsp;Vijaykumar</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Soft error susceptibility is a growing concern with continued CMOS scaling in modern, high-performance, general-purpose microprocessors. Smaller transistors and lower voltages achieve by contiued scaling  exacerbate the soft error problem. Previous work explores full- and partial-redundancy schemes in hardware and software for soft-fault tolerance. However, full-redundancy schemes incur high performance and energy overheads whereas partial-redundancy schemes achieve low coverage.  Value locality is well-known where values generated  in a computation fall within small neighborhoods in the value space, rather than be  spread arbitrarily   over the entire value space. Previous value-locality efforts have attempted to improve performance by  exploiting  value localityto predict values faster than they can be  computed due to inherent long latencies such as cache misses. This project  exploits  value locaity to detect soft errors which  would usually perturb a value  making it fall outside value locality  neighborhoods. Such detection does not require redundancy and therefore can avoid the corresponding overheads. To this end, the authors   employ hardware filters that capture value locality  neighborhoods by  capturing which bit positions are unchanging  0's or  1's and which  positions change so that a new value matching in the  unchanging  positions does not flag an error and does otherwise. Upon  detection, the authors   leverage modern processor pipeline's in-built abiltiy to  roll-back  computation to try to correct the error. Because the  roll-back (i.e.,  redundant execution) occurs only when an error is  flagged or on a false  postiive (which are about 2% of all  instructions), the proposed  method acheives  lower power and performance  overheads than previous full-redundancy  approaches.  In contrast to value prediction for performance where the prediciton has to exactly match the actual value, exploiting value locality to detect soft errors has to  be accurate enough to detect value perturbation without   prediction the value with 100% accuracy.  An initial study, called Perturbation Based Fault Screening (PBFS), explored exploiting value locality to provide hints of soft faults whenever a value falls outside its neighborhood.  However, PBFS achieves low coverage; straightforwardly improving the coverage results in high false-positive rates, and performance and energy overheads.  The authors propose FaultHound, a value-locality-based soft-fault tolerance scheme, which employs five novel mechanisms to address PBFS?s limitations: (1) a scheme to cluster the filters via an inverted organization of the filter tables to reinforce learning and reduce the false-positive rates; (2) a learning scheme for ignoring the delinquent bit positions that raise repeated false alarms, to reduce further the false- positive rate; (3) a light-weight predecessor replay scheme instead of a full rollback to reduce the performance and energy penalty of the remaining false positives; (4) a simple scheme to distinguish rename faults, which require rollback instead of replay for recovery, from false positives to avoid unnecessary rollback penalty; and (5) a detection scheme, which avoids rollback, for the load-store queue which is not covered by the  replay. Using simulations, the authors  show that while PBFS achieves either low coverage (30%), or high false-positive rates (8%) with high performance overheads (97%), FaultHound achieves higher coverage (75%) and lower false-positive rates (3%) with lower performance and energy overheads (10% and 25%). Further, full-redundancy schemes scaled to achieve equal coverage of 75% result in   13% performance loss and 57% energy overheads. These results are for a  broad range of benchmarks which include commercial workloads (TPC-C-ilke online transaction processing, SPECjbb, and apache webserver), SPECint,  SPECFP, and SPLASH.  Considering all the three metrics of coverage, performance and energy overheads, FaultHound performs better than previous redundancy-based and value-locality-based schemes which perform well against only one or two of these metrics. Because of this attractive combination of features, FaultHound will likely be important in the path of continued CMOS  scaling in modern microprocessors.       Last Modified: 09/28/2017       Submitted by: T. N Vijaykumar]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
