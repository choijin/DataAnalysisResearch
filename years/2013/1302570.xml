<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CCF: SHF: Medium: Collaborative: A Static and Dynamic  Verification Framework for Parallel Programming</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/15/2013</AwardEffectiveDate>
<AwardExpirationDate>03/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Human society is faced with an increasing number of problems including&lt;br/&gt;stubborn diseases and international security/climate threats. The&lt;br/&gt;computer simulations and advanced data management methods necessary to&lt;br/&gt;solving these societal problems can only be realized through increased&lt;br/&gt;use of parallel computing at all system scales, including desktops,&lt;br/&gt;servers and the cloud. Efficient large-scale parallel computing&lt;br/&gt;however requires advanced parallel programming methods. Such methods,&lt;br/&gt;unfortunately, have a greater proclivity for software bugs that&lt;br/&gt;increase cost through lost cycles on super-computers and these same&lt;br/&gt;bugs undermine confidence in simulation results.  This research&lt;br/&gt;addresses the challenge of developing parallel computing software by&lt;br/&gt;creating new scalable methods to support advanced parallel programming&lt;br/&gt;models that provide rigorous guarantees on program correctness. The&lt;br/&gt;societal impacts of this work stem from increasing reliability of&lt;br/&gt;software powering the national infrastructure, advanced educational&lt;br/&gt;methods to train future generations, and pedagogical material in the&lt;br/&gt;form of course notes and software for broad dissemination.  It also&lt;br/&gt;helps maintain the United States in a leadership situation with&lt;br/&gt;respect to the available talent pool in this area.&lt;br/&gt;&lt;br/&gt;Providing rigorous guarantees on correctness of existing parallel&lt;br/&gt;computing software requires that two classes of methods be developed,&lt;br/&gt;evaluated, and taught widely: scalable code-level (static) checking&lt;br/&gt;methods, and downstream detailed (dynamic) checking methods. This&lt;br/&gt;project develops these novel and much-needed correctness checking&lt;br/&gt;methods around the Habanero Java programming and compilation&lt;br/&gt;system. The research is to augment the system with correctness&lt;br/&gt;obligations emitted during compilation and checked at all later stages&lt;br/&gt;of translation and deployment.  A key highlight of the project's&lt;br/&gt;approach is that it allows some of the correctness obligations to be&lt;br/&gt;checked statically in the context of safe subsets of Habanero Java.&lt;br/&gt;Obligations that are not able to be statically checked, especially for&lt;br/&gt;larger subsets of the Habanero language, are marked for checking&lt;br/&gt;dynamically through novel active-testing methods. An Operational&lt;br/&gt;Semantics written in the Coq notation lends cohesion to the work by&lt;br/&gt;ensuring that the division of correctness checking between static and&lt;br/&gt;dynamic techniques is sound. In summary, this research helps advance&lt;br/&gt;the science of parallel programming in terms of rigorous correctness&lt;br/&gt;checking methods, while at the same time contributing to the broad&lt;br/&gt;practice of programming at all scales from desktop to cloud&lt;br/&gt;computing and high-end scientific simulations.</AbstractNarration>
<MinAmdLetterDate>04/11/2013</MinAmdLetterDate>
<MaxAmdLetterDate>09/17/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1302570</AwardID>
<Investigator>
<FirstName>Vivek</FirstName>
<LastName>Sarkar</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vivek Sarkar</PI_FULL_NAME>
<EmailAddress>vsarkar@rice.edu</EmailAddress>
<PI_PHON>7133485304</PI_PHON>
<NSF_ID>000334688</NSF_ID>
<StartDate>04/11/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>William Marsh Rice University</Name>
<CityName>Houston</CityName>
<ZipCode>770051827</ZipCode>
<PhoneNumber>7133484820</PhoneNumber>
<StreetAddress>6100 MAIN ST</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>050299031</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>WILLIAM MARSH RICE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>050299031</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[William Marsh Rice University]]></Name>
<CityName/>
<StateCode>TX</StateCode>
<ZipCode>770051827</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~200000</FUND_OBLG>
<FUND_OBLG>2015~200000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>INTELLECTUAL MERIT:</p> <ul> <li>Development of the first known determinacy race detector for non-strict computation graphs, that can be constructed by task-parallel programs using futures [RV 2016[.&nbsp;The space and time complexity of our algorithm are similar to those of previous algorithms, when using fully/terminally strict computation graphs. In the presence of point-to-point synchronization using futures, the complexity of the algorithm increases by a factor determined by the number of future task creation and get operations as well as the number of non-tree edges in the computation graph.&nbsp;</li> <li>Another result related to futures was the introduction of the Known Joins (KJ) property for parallel programs with futures [OOPSLA 2017], and its relationship to the Deadlock Freedom (DF) and the Data-Race Freedom (DRF) properties. This work offers two key theoretical results: 1) DRF implies KJ, and 2) KJ implies DF.</li> <li>Development of a novel approach for using futures to automatically parallelize the execution of pure method calls in a sequential program [OOPSLA 2016].&nbsp;&nbsp;Our approach is built on three new techniques to address the challenge of automatic parallelization via future synthesis: candidate future synthesis, parallelism benefit analysis, and threshold expression synthesis.&nbsp;</li> <li>Extension of Java Pathfinder to support verification of parallel Habanero Java programs [SIGSOFT Software Engineering Notes, 2015], by building on past work in PI Sarkar's group on a gradual type approach for permission regions.</li> <li>Formalization of phasers, and of May-Happen-In-Parallel and Happens&ndash;Before relations for phaser operations [PLACES 2016, JLAMP 2017].&nbsp;&nbsp;This work characterizes scheduling constraints on phaser operations, by relating the execution state of two tasks that operate on the same phaser.&nbsp;&nbsp;Our formalization and proofs are fully mechanized using the Coq proof assistant.</li> <li>Development of a new high-level construct for mutual exclusion called "object-based isolation" [Euro-Par 15], which guarantees deadlock freedom and livelock freedom.&nbsp;&nbsp;This construct delivers much of the functionality of software transactions, with much lower runtime overhead.&nbsp;&nbsp;In exchange for this efficiency, the programmer or compiler needs to provide information of the objects being accessed (and whether in read/write mode) in isolated regions.</li> <li>Development of the selectors model [AGERE! 2014], which extends the actor model to support multiple mailboxes, and&nbsp;&nbsp;their implementations in the Habanero-Java library.&nbsp;&nbsp;These extensions expanded the set of coordination platforms that can be expressed in the pure actor model.&nbsp;&nbsp;The selectors implementation in HJlib was further extended to distributed platforms both on server platforms [PPPJ'16], and on mobile devices [ManLang'17].</li> <li>Extension of work-stealing scheduling runtime systems to support general blocking operations via a cooperative runtime system [ECOOP 2014], along with support for GPU devices [LCPC 2013].&nbsp;&nbsp;A key consequence of this result is the avoidance of deadlock and/or of large overheads when general blocking operations are performed within large numbers of tasks.&nbsp;&nbsp;</li> <li>Extensions of work-stealing runtime systems to support task priorities [Euro-Par 15] and task cancellation [ECOOP 2015].&nbsp;&nbsp;Task priorities were demonstrated for various benchmarks including those for which priority scheduling can be used to reduce the total amount of work performed by an algorithm. Task cancellation involved the development of a new "Eureka" programming model for speculative task parallelism that is well suited for search and optimization problems with safe semantic guarantees.</li> <li>Creation of the concept of "elastic tasks"&nbsp;&nbsp;[Euro-Par 15], a new high-level parallel programming primitive that can be used to unify task parallelism and SPMD parallelism in a common adaptive scheduling framework. Elastic tasks are internally parallel tasks and can run on a single worker or can elastically expand to run on multiple workers.&nbsp;&nbsp;Our work includes theoretical results on how long an elastic task should wait for available workers, while still bounding the worst-case idle time in doing so.</li> </ul> <p>&nbsp;</p> <p>BROADER IMPACT:</p> <ul> <li>The development of the Habanero-Java library (HJlib), and its use in research and teaching [PPPJ 2014].&nbsp;&nbsp;HJlib has been used for research, and for teaching in on-campus courses at Rice University and other institutions (Brigham Young University, Washington University).&nbsp;&nbsp;In addition, a subset of HJlib was released as an open source project called PCDP (for "Parallel, Concurrent and Distributed Programming").&nbsp;&nbsp;PCDP is used in a new 3-course online specialization on Coursera, which was launched in July 2017, and which has already attracted more than 2,000 paid learners worldwide since its release.</li> <li>This research has served as a vital training ground in Parallel Software for multiple members of the Habanero group who were exposed to this research and use Habanero-Java in their research.&nbsp;&nbsp;&nbsp;Multiple PhD students were able to obtain research internships and post-PhD jobs based on their training from this project and related activities in Sarkar's lab.&nbsp;And over a dozen undergraduate students at Rice University conducted research in PI Sarkar&rsquo;s lab during this project after taking his sophomore-level undergraduate course on &ldquo;Fundamentals of Parallel Programming&rdquo; (COMP 322).&nbsp;</li> </ul><br> <p>            Last Modified: 05/20/2018<br>      Modified by: Vivek&nbsp;Sarkar</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ INTELLECTUAL MERIT:  Development of the first known determinacy race detector for non-strict computation graphs, that can be constructed by task-parallel programs using futures [RV 2016[. The space and time complexity of our algorithm are similar to those of previous algorithms, when using fully/terminally strict computation graphs. In the presence of point-to-point synchronization using futures, the complexity of the algorithm increases by a factor determined by the number of future task creation and get operations as well as the number of non-tree edges in the computation graph.  Another result related to futures was the introduction of the Known Joins (KJ) property for parallel programs with futures [OOPSLA 2017], and its relationship to the Deadlock Freedom (DF) and the Data-Race Freedom (DRF) properties. This work offers two key theoretical results: 1) DRF implies KJ, and 2) KJ implies DF. Development of a novel approach for using futures to automatically parallelize the execution of pure method calls in a sequential program [OOPSLA 2016].  Our approach is built on three new techniques to address the challenge of automatic parallelization via future synthesis: candidate future synthesis, parallelism benefit analysis, and threshold expression synthesis.  Extension of Java Pathfinder to support verification of parallel Habanero Java programs [SIGSOFT Software Engineering Notes, 2015], by building on past work in PI Sarkar's group on a gradual type approach for permission regions. Formalization of phasers, and of May-Happen-In-Parallel and Happens&ndash;Before relations for phaser operations [PLACES 2016, JLAMP 2017].  This work characterizes scheduling constraints on phaser operations, by relating the execution state of two tasks that operate on the same phaser.  Our formalization and proofs are fully mechanized using the Coq proof assistant. Development of a new high-level construct for mutual exclusion called "object-based isolation" [Euro-Par 15], which guarantees deadlock freedom and livelock freedom.  This construct delivers much of the functionality of software transactions, with much lower runtime overhead.  In exchange for this efficiency, the programmer or compiler needs to provide information of the objects being accessed (and whether in read/write mode) in isolated regions. Development of the selectors model [AGERE! 2014], which extends the actor model to support multiple mailboxes, and  their implementations in the Habanero-Java library.  These extensions expanded the set of coordination platforms that can be expressed in the pure actor model.  The selectors implementation in HJlib was further extended to distributed platforms both on server platforms [PPPJ'16], and on mobile devices [ManLang'17]. Extension of work-stealing scheduling runtime systems to support general blocking operations via a cooperative runtime system [ECOOP 2014], along with support for GPU devices [LCPC 2013].  A key consequence of this result is the avoidance of deadlock and/or of large overheads when general blocking operations are performed within large numbers of tasks.   Extensions of work-stealing runtime systems to support task priorities [Euro-Par 15] and task cancellation [ECOOP 2015].  Task priorities were demonstrated for various benchmarks including those for which priority scheduling can be used to reduce the total amount of work performed by an algorithm. Task cancellation involved the development of a new "Eureka" programming model for speculative task parallelism that is well suited for search and optimization problems with safe semantic guarantees. Creation of the concept of "elastic tasks"  [Euro-Par 15], a new high-level parallel programming primitive that can be used to unify task parallelism and SPMD parallelism in a common adaptive scheduling framework. Elastic tasks are internally parallel tasks and can run on a single worker or can elastically expand to run on multiple workers.  Our work includes theoretical results on how long an elastic task should wait for available workers, while still bounding the worst-case idle time in doing so.      BROADER IMPACT:  The development of the Habanero-Java library (HJlib), and its use in research and teaching [PPPJ 2014].  HJlib has been used for research, and for teaching in on-campus courses at Rice University and other institutions (Brigham Young University, Washington University).  In addition, a subset of HJlib was released as an open source project called PCDP (for "Parallel, Concurrent and Distributed Programming").  PCDP is used in a new 3-course online specialization on Coursera, which was launched in July 2017, and which has already attracted more than 2,000 paid learners worldwide since its release. This research has served as a vital training ground in Parallel Software for multiple members of the Habanero group who were exposed to this research and use Habanero-Java in their research.   Multiple PhD students were able to obtain research internships and post-PhD jobs based on their training from this project and related activities in Sarkar's lab. And over a dozen undergraduate students at Rice University conducted research in PI Sarkar?s lab during this project after taking his sophomore-level undergraduate course on "Fundamentals of Parallel Programming" (COMP 322).         Last Modified: 05/20/2018       Submitted by: Vivek Sarkar]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
