<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Medium: Collaborative Research: The Commutativity Rule for Scalable Systems Software</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2013</AwardEffectiveDate>
<AwardExpirationDate>09/30/2016</AwardExpirationDate>
<AwardTotalIntnAmount>299995.00</AwardTotalIntnAmount>
<AwardAmount>299995</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>After decades of reliable improvement, processor speeds have&lt;br/&gt;flattened; for the foreseeable future, computers will add processing&lt;br/&gt;power by adding more processors, rather than faster ones. This is a&lt;br/&gt;tremendous challenge for software designers. It's far too easy for&lt;br/&gt;software using multiple processors to burn up a growing fraction of&lt;br/&gt;available processing power on coordination overheads like locking,&lt;br/&gt;rather than actual work. That is, it's far too easy for software to&lt;br/&gt;not scale: to get slower as processors are added. And an important&lt;br/&gt;reason for this is simply that scalability is poorly understood. Some&lt;br/&gt;programs don't scale because they're badly written, but others don't&lt;br/&gt;scale because their goals are fundamentally impossible to accomplish&lt;br/&gt;in a scalable way. Programmers lack effective tools for high-level&lt;br/&gt;reasoning about software scalability limitations, and thus waste&lt;br/&gt;effort on both impossible and uninteresting tasks.&lt;br/&gt;&lt;br/&gt;We will produce the first well-grounded and formal reasoning procedure&lt;br/&gt;for scalability that is flexible enough to apply to an entire&lt;br/&gt;operating system. Our scalability rule links commutativity and&lt;br/&gt;scalability. We characterize software interfaces as more or less&lt;br/&gt;inherently scalable depending on the contexts in which those&lt;br/&gt;interfaces commute: the more commutative an interface (that is, the&lt;br/&gt;more often the order of its function calls doesn't matter), the more&lt;br/&gt;scalable an implementation can be. We prove that a scalable&lt;br/&gt;implementation exists for any commutative context. This idea can&lt;br/&gt;already guide software designers in developing easily-scalable&lt;br/&gt;interfaces, but we will also provide a set of automated tools for&lt;br/&gt;measuring interface commutativity and for finding implementation&lt;br/&gt;scalability bottlenecks, and evaluate our ideas in a highly-scalable&lt;br/&gt;operating system. The resulting tools and ideas could make scalable&lt;br/&gt;software far easier to design and program, and thus help software&lt;br/&gt;designers provide the software performance on which so much of our&lt;br/&gt;economy depends.</AbstractNarration>
<MinAmdLetterDate>09/09/2013</MinAmdLetterDate>
<MaxAmdLetterDate>09/09/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1301934</AwardID>
<Investigator>
<FirstName>M. Frans</FirstName>
<LastName>Kaashoek</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>M. Frans Kaashoek</PI_FULL_NAME>
<EmailAddress>kaashoek@lcs.mit.edu</EmailAddress>
<PI_PHON>6172537149</PI_PHON>
<NSF_ID>000098539</NSF_ID>
<StartDate>09/09/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Robert</FirstName>
<LastName>Morris</LastName>
<PI_MID_INIT>T</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Robert T Morris</PI_FULL_NAME>
<EmailAddress>rtm@csail.mit.edu</EmailAddress>
<PI_PHON>6172535983</PI_PHON>
<NSF_ID>000471357</NSF_ID>
<StartDate>09/09/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Nickolai</FirstName>
<LastName>Zeldovich</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Nickolai Zeldovich</PI_FULL_NAME>
<EmailAddress>nickolai@csail.mit.edu</EmailAddress>
<PI_PHON>6172536005</PI_PHON>
<NSF_ID>000520788</NSF_ID>
<StartDate>09/09/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[NE18-901]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001425594</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>MASSACHUSETTS INSTITUTE OF TECHNOLOGY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001425594</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Massachusetts Institute of Technology]]></Name>
<CityName/>
<StateCode>MA</StateCode>
<ZipCode>021394301</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~299995</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>After decades of reliable improvement, processor speeds have flattened; for the foreseeable future, computers will add processing power by adding more processors, rather than faster ones. This is a tremendous challenge for software designers. It's far too easy for software using multiple processors to burn up a growing fraction of available processing power on coordination overheads like locking, rather than actual work. That is, it's far too easy for software to not scale: to get slower as processors are added. And an important reason for this is simply that scalability is poorly understood. Some programs don't scale because they're badly written, but others don't scale because their goals are fundamentally impossible to accomplish in a scalable way. Programmers lack effective tools for high-level reasoning about software scalability limitations, and thus waste effort on both impossible and uninteresting tasks.</p> <p><br />What opportunities for multicore scalability are latent in software interfaces, such as system call APIs? Can scalability challenges and opportunities be identified even before any implementation exists, simply by considering interface specifications? &nbsp;To answer these questions, this project introduces the scalable commutativity rule: "Whenever interface operations commute, they can be implemented in a way that scales." &nbsp;This rule is useful throughout the development process for scalable multicore software, from the interface design through implementation, testing, and evaluation.</p> <p><br />This project formalizes the scalable commutativity rule. This requires defining a novel form of commutativity, SIM commutativity, that lets the rule apply even to complex and highly stateful software interfaces.</p> <p><br />This project also introduces a software development, called Commuter, based on the rule. &nbsp;Commuter accepts high-level interface models, generates tests of interface operations that commute and hence could scale, and uses these tests to systematically evaluates the scalability of implementations. &nbsp;Using Commuter the project highlights Linux kernel problems previously observed to limit application scalability and identifies previously unknown bottlenecks that maybe triggered by future workloads or hardware.</p> <p><br />Finally, the project applies the scalable commutativity rule and Commuter to the design and implementation of sv6, a new POSIX-like operating system. &nbsp;sv6's novel file and virtual memory system designs enable it to scale for almost all test cases. &nbsp;These results translate to linear scalability on an 80-core x86 machine for applications built on sv6's commutative operations. &nbsp;sv6 also provides disk performance that matches or exceeds that of Linux ext4.</p><br> <p>            Last Modified: 04/25/2017<br>      Modified by: M. Frans&nbsp;Kaashoek</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Image         </div> <div class="galControls onePhoto" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation onePhoto" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2017/1301934/1301934_10277307_1492983559271_heatmap--rgov-214x142.jpg" original="/por/images/Reports/POR/2017/1301934/1301934_10277307_1492983559271_heatmap--rgov-800width.jpg" title="Heatmap"><img src="/por/images/Reports/POR/2017/1301934/1301934_10277307_1492983559271_heatmap--rgov-66x44.jpg" alt="Heatmap"></a> <div class="imageCaptionContainer"> <div class="imageCaption">A heatmap generated by Commuter for  Linux system call pairs.  Green indicates good scalability and red indicates poor scalabillty.</div> <div class="imageCredit">Austin Clements</div> <div class="imagePermisssions">Creative Commons</div> <div class="imageSubmitted">M. Frans&nbsp;Kaashoek</div> <div class="imageTitle">Heatmap</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ After decades of reliable improvement, processor speeds have flattened; for the foreseeable future, computers will add processing power by adding more processors, rather than faster ones. This is a tremendous challenge for software designers. It's far too easy for software using multiple processors to burn up a growing fraction of available processing power on coordination overheads like locking, rather than actual work. That is, it's far too easy for software to not scale: to get slower as processors are added. And an important reason for this is simply that scalability is poorly understood. Some programs don't scale because they're badly written, but others don't scale because their goals are fundamentally impossible to accomplish in a scalable way. Programmers lack effective tools for high-level reasoning about software scalability limitations, and thus waste effort on both impossible and uninteresting tasks.   What opportunities for multicore scalability are latent in software interfaces, such as system call APIs? Can scalability challenges and opportunities be identified even before any implementation exists, simply by considering interface specifications?  To answer these questions, this project introduces the scalable commutativity rule: "Whenever interface operations commute, they can be implemented in a way that scales."  This rule is useful throughout the development process for scalable multicore software, from the interface design through implementation, testing, and evaluation.   This project formalizes the scalable commutativity rule. This requires defining a novel form of commutativity, SIM commutativity, that lets the rule apply even to complex and highly stateful software interfaces.   This project also introduces a software development, called Commuter, based on the rule.  Commuter accepts high-level interface models, generates tests of interface operations that commute and hence could scale, and uses these tests to systematically evaluates the scalability of implementations.  Using Commuter the project highlights Linux kernel problems previously observed to limit application scalability and identifies previously unknown bottlenecks that maybe triggered by future workloads or hardware.   Finally, the project applies the scalable commutativity rule and Commuter to the design and implementation of sv6, a new POSIX-like operating system.  sv6's novel file and virtual memory system designs enable it to scale for almost all test cases.  These results translate to linear scalability on an 80-core x86 machine for applications built on sv6's commutative operations.  sv6 also provides disk performance that matches or exceeds that of Linux ext4.       Last Modified: 04/25/2017       Submitted by: M. Frans Kaashoek]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
