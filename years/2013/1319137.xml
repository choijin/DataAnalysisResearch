<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Small: A platform for enhancing security of binary code</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>499957.00</AwardTotalIntnAmount>
<AwardAmount>499957</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Cyberattacks are enabled by software vulnerabilities that allow attackers to plant software exploits. As old vulnerabilities are found and fixed, attackers continue to find new ones. As a result, software vendors, system administrators and security professionals have come to rely increasingly on techniques that insert additional code into software for detecting and/or blocking cyber attacks in progress. This process, called software instrumentation, can be applied to the broadest range of software if it operates on binary format in which most software is distributed, rather than on source code. Moreover, binary based techniques are more general: unlike source-codebased techniques, they are not limited to a particular programming language.&lt;br/&gt;&lt;br/&gt;One of the major challenges in binary instrumentation is the complexity of modern instruction sets. Accurate instrumentation requires the semantics of all instructions to be captured, since all of the analyses and transformations performed by the instrumentor are based on this semantics. Clearly, this is a daunting task even for a single architecture: the Intel manual describing the x86 instruction set runs to over 1500 pages describing over 1100 instructions. When this task is multiplied across different architectures such as ARM, PowerPC, SPARC, MIPS, etc, the effort involved becomes impractically large. This project will develop a novel approach that avoids the need for modeling instruction sets by leveraging knowledge embedded in retargetable code generators in today's compilers such as GCC. This approach not only simplifies the development of instrumentation, but also makes it applicable to all architectures for which a code generator is available. Using this approach, this project will develop a platform to support efficient, architecture-neutral static instrumentation of commercial off-the-shelf (COTS) binaries. Based on this platform, this project will develop several effective instrumentations for hardening software against common vulnerabilities.</AbstractNarration>
<MinAmdLetterDate>07/19/2013</MinAmdLetterDate>
<MaxAmdLetterDate>07/19/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1319137</AwardID>
<Investigator>
<FirstName>Ramasubramanian</FirstName>
<LastName>Sekar</LastName>
<PI_MID_INIT>C</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ramasubramanian C Sekar</PI_FULL_NAME>
<EmailAddress>sekar@cs.sunysb.edu</EmailAddress>
<PI_PHON>6316325758</PI_PHON>
<NSF_ID>000181956</NSF_ID>
<StartDate>07/19/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>SUNY at Stony Brook</Name>
<CityName>Stony Brook</CityName>
<ZipCode>117940001</ZipCode>
<PhoneNumber>6316329949</PhoneNumber>
<StreetAddress>WEST 5510 FRK MEL LIB</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>804878247</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>RESEARCH FOUNDATION FOR THE STATE UNIVERSITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>020657151</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[SUNY at Stony Brook]]></Name>
<CityName>Stony Brook</CityName>
<StateCode>NY</StateCode>
<ZipCode>117943366</ZipCode>
<StreetAddress><![CDATA[Department of Computer Science]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~499957</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>In this project, we proposed to perform research on three major fronts:</p> <ul> <li>extracting precise semantics of computer instructions that works on many different processor types</li> <li>robust techniques that can transform COTS binaries to introduce additional security checks, and</li> <li>applications of the above two techniques to achieve specific security objectives on arbitrary applications provided in the form of binary code.</li> </ul> <p>We have been very successful on all these fronts. Altogether, this project has contributed to over 30 refereed publications that have been cited nearly a thousand times on Google scholar.</p> <p>We developed two novel approaches for processor-independent instruction semantics extraction. Both approaches relied on the observation made in the proposal that instruction semantics for numerous processors is already encoded into the implementation of today's compilers. Our first approach was based on a novel learning algorithm that relied on the GCC compiler to generate its training input. Specifically, we used GCC to compile numerous software packages and generate RTL (the intermediate code used by GCC) and corresponding processor instructions. Our algorithm was exceptionally effective, achieving 99.5% coverage across all of the binary packages on default distributions of Ubuntu Linux operating system. Increasing the coverage to 100% required manual modeling of a handful of instructions. We achieved nearly identical results for Intel and ARM processors, and further demonstrated our results on AVR, the processor used in the popular Arduino microcontroller platform.</p> <p>We also developed a second novel approach that was based on symbolic execution of GCC's code generator. We developed a new symbolic execution engine for this problem. Because our engine was customized for this problem, it was able to perform all-paths symbolic execution of GCC's entire x86 code generator, which ensured that the semantics we extracted was complete with respect to the instructions used by GCC. We also proved the soundness of our approach. We have released these systems as open-source packages, available from our laboratory web site: <span style="white-space: pre;"> </span>http://seclab.cs.sunysb.edu/seclab/download.html</p> <p>We also developed a robust static binary instrumentation approach. Our paper describing this approach won the "Best paper award" at USENIX Security symposium, the leading forum for papers on computer system security. We showed that our approach scales to very large and complex binaries, and supports COTS binaries and dynamic libraries. Subsequently, we showed that our approach can achieve efficient instrumentation, while competing approaches, all of which rely on runtime transformation of binaries, typically slow down programs several-fold, with the slowdown approaching or exceeding an order of magnitude in some cases. Our system has been released as a open-source package.</p> <p>We have developed several new binary analysis and security-enhancing instrumentations using our approach. This includes:</p> <ul> <li>A robust implementation of shadow stacks, a defense against the most common type of exploit prevalent today, called ROP exploit. Previous approaches suffered from false positives (which lead to application termination) on complex binaries. In contrast, by using the detailed instruction semantics we extracted using our approach, we were able to develop a highly precise analysis that was able to avoid these false positives.</li> <li>A robust implementation of control-flow integrity, another important defense measure against common exploits. Unlike previous approaches, ours works on COTS binaries, and on large and complex code. Its performance overhead was modest, at about 15%.</li> <li>A principled approach for defeating real-world control-flow hijack attacks by blocking all attempts to inject or load any new code that isn't previously authorized. Our approach provides a strong guarantee against such attacks.</li> <li>A novel binary code analysis for accurate identification of functions in COTS binaries. Our approach achieved better than a 4-fold reduction the best error rates achieved by previous techniques.</li> <li>A new defense against disclosure-guided code reuse attacks, such as just-in-time ROP attacks.Unlike previous approaches that required source code access, our approach works on COTS binaries.</li> </ul> <p>Each of the three major fronts mentioned earlier led to one PhD dissertation. In addition, the dissertation of 4 other PhD students were partly supported by this project. A total of four open-source software releases have resulted from this project.</p> <p>The results achieved in this project formed the basis of a new project that is currently funded by ONR. The goal of this large 5-year project is to develop novel binary analysis and instrumentation techniques for hardening binary code, reducing its attack surface by removing unnecessary code and restricting the use remaining code, and improve performance through "debloating," i.e., the removal of unneeded libraries and unneeded indirection.</p><br> <p>            Last Modified: 12/28/2018<br>      Modified by: R&nbsp;C&nbsp;Sekar</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ In this project, we proposed to perform research on three major fronts:  extracting precise semantics of computer instructions that works on many different processor types robust techniques that can transform COTS binaries to introduce additional security checks, and applications of the above two techniques to achieve specific security objectives on arbitrary applications provided in the form of binary code.   We have been very successful on all these fronts. Altogether, this project has contributed to over 30 refereed publications that have been cited nearly a thousand times on Google scholar.  We developed two novel approaches for processor-independent instruction semantics extraction. Both approaches relied on the observation made in the proposal that instruction semantics for numerous processors is already encoded into the implementation of today's compilers. Our first approach was based on a novel learning algorithm that relied on the GCC compiler to generate its training input. Specifically, we used GCC to compile numerous software packages and generate RTL (the intermediate code used by GCC) and corresponding processor instructions. Our algorithm was exceptionally effective, achieving 99.5% coverage across all of the binary packages on default distributions of Ubuntu Linux operating system. Increasing the coverage to 100% required manual modeling of a handful of instructions. We achieved nearly identical results for Intel and ARM processors, and further demonstrated our results on AVR, the processor used in the popular Arduino microcontroller platform.  We also developed a second novel approach that was based on symbolic execution of GCC's code generator. We developed a new symbolic execution engine for this problem. Because our engine was customized for this problem, it was able to perform all-paths symbolic execution of GCC's entire x86 code generator, which ensured that the semantics we extracted was complete with respect to the instructions used by GCC. We also proved the soundness of our approach. We have released these systems as open-source packages, available from our laboratory web site:  http://seclab.cs.sunysb.edu/seclab/download.html  We also developed a robust static binary instrumentation approach. Our paper describing this approach won the "Best paper award" at USENIX Security symposium, the leading forum for papers on computer system security. We showed that our approach scales to very large and complex binaries, and supports COTS binaries and dynamic libraries. Subsequently, we showed that our approach can achieve efficient instrumentation, while competing approaches, all of which rely on runtime transformation of binaries, typically slow down programs several-fold, with the slowdown approaching or exceeding an order of magnitude in some cases. Our system has been released as a open-source package.  We have developed several new binary analysis and security-enhancing instrumentations using our approach. This includes:  A robust implementation of shadow stacks, a defense against the most common type of exploit prevalent today, called ROP exploit. Previous approaches suffered from false positives (which lead to application termination) on complex binaries. In contrast, by using the detailed instruction semantics we extracted using our approach, we were able to develop a highly precise analysis that was able to avoid these false positives. A robust implementation of control-flow integrity, another important defense measure against common exploits. Unlike previous approaches, ours works on COTS binaries, and on large and complex code. Its performance overhead was modest, at about 15%. A principled approach for defeating real-world control-flow hijack attacks by blocking all attempts to inject or load any new code that isn't previously authorized. Our approach provides a strong guarantee against such attacks. A novel binary code analysis for accurate identification of functions in COTS binaries. Our approach achieved better than a 4-fold reduction the best error rates achieved by previous techniques. A new defense against disclosure-guided code reuse attacks, such as just-in-time ROP attacks.Unlike previous approaches that required source code access, our approach works on COTS binaries.   Each of the three major fronts mentioned earlier led to one PhD dissertation. In addition, the dissertation of 4 other PhD students were partly supported by this project. A total of four open-source software releases have resulted from this project.  The results achieved in this project formed the basis of a new project that is currently funded by ONR. The goal of this large 5-year project is to develop novel binary analysis and instrumentation techniques for hardening binary code, reducing its attack surface by removing unnecessary code and restricting the use remaining code, and improve performance through "debloating," i.e., the removal of unneeded libraries and unneeded indirection.       Last Modified: 12/28/2018       Submitted by: R C Sekar]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
