<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>XPS: CLCCA: Scalable Parallelism for Irregular and Graph Applications</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/15/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>749645.00</AwardTotalIntnAmount>
<AwardAmount>749645</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Irregular applications are increasing in importance to the computing industry.  For a long time they have underpinned computations of interest to the national security arm of the federal government. But now, they  underpin such questions as ad placement in social networks, and analysis of complex data-sets in medicine and science. For example, developing custom drug therapies involves analysis of how cellular pathways, known drug/patient outcomes, and a particular patient's DNA interact.  These complex big-data problems require new computational models in order to execute effectively on commodity hardware.  The defining characteristic of these applications is poor locality and massive available parallelism.  The key idea is use the available concurrency to tolerate memory latency, instead of relying on locality.  Using a highly optimized runtime system, tuned for use on commodity processors and networking hardware it has been shown that scalable performance on these applications can exceed custom supercomputer-class hardware.&lt;br/&gt;&lt;br/&gt;The research currently being undertaken is to continue exploring and developing this latency tolerant scale-out runtime system.  The proposed research directions include exploring ways to mitigate latency for disk (SSD) access, in order to tackle petabyte-scale problems on small clusters of commodity hardware.  In addition the research will examine programmable router hardware in order to scale network aggregation into the thousand-node-plus cluster range.  Finally the research effort will focus on enhanced language semantics and compiler techniques that make it easier to implement the types of analyses and graph algorithms of interest to the scientific, business, medical, and government communities.</AbstractNarration>
<MinAmdLetterDate>09/06/2013</MinAmdLetterDate>
<MaxAmdLetterDate>09/06/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1335466</AwardID>
<Investigator>
<FirstName>Mark</FirstName>
<LastName>Oskin</LastName>
<PI_MID_INIT>H</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Mark H Oskin</PI_FULL_NAME>
<EmailAddress>oskin@cs.washington.edu</EmailAddress>
<PI_PHON>2066852237</PI_PHON>
<NSF_ID>000461512</NSF_ID>
<StartDate>09/06/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Luis</FirstName>
<LastName>Ceze</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Luis Ceze</PI_FULL_NAME>
<EmailAddress>luisceze@cs.washington.edu</EmailAddress>
<PI_PHON>2065431896</PI_PHON>
<NSF_ID>000083036</NSF_ID>
<StartDate>09/06/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Simon</FirstName>
<LastName>Kahan</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME>Dr.</PI_SUFX_NAME>
<PI_FULL_NAME>Simon Kahan</PI_FULL_NAME>
<EmailAddress>skahan@cs.washington.edu</EmailAddress>
<PI_PHON>2066853853</PI_PHON>
<NSF_ID>000582921</NSF_ID>
<StartDate>09/06/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Washington</Name>
<CityName>Seattle</CityName>
<ZipCode>981950001</ZipCode>
<PhoneNumber>2065434043</PhoneNumber>
<StreetAddress>4333 Brooklyn Ave NE</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Washington</StateName>
<StateCode>WA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>WA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>605799469</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF WASHINGTON</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042803536</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Washington]]></Name>
<CityName>Seattle</CityName>
<StateCode>WA</StateCode>
<ZipCode>981952350</ZipCode>
<StreetAddress><![CDATA[185 Stevens Way]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Washington</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>WA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8283</Code>
<Text>Exploiting Parallel&amp;Scalabilty</Text>
</ProgramElement>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~749645</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span style="text-decoration: underline;"><strong>Overview</strong></span></p> <p>&nbsp;</p> <p>The goals of this project are to make applications that exhibit irregular parallelism and poor locality scale to large multinode clusters.&nbsp; Furthermore, these applications should be easy to write and tune.&nbsp; The infrastructure developed should be open-sourced and widely distributed and supported.&nbsp; The team has spent extensive amounts of time building and tuning the core infrastructure (Grappa). We have built a compiler that takes SQL-like queries and compiles them to execute on an in-memory database built on top of Grappa.&nbsp; The core runtime is now open sourced (BSD license).&nbsp; We also built a benchmark suite for graph analytics (GraphBench).&nbsp; The students and PIs actively promoted the effort through talks and site visits.&nbsp; We have been busy exploring new software and hardware options for distributed fine-grained threading on heterogeneous platforms.&nbsp; The core infrastructure we worked on (Grappa) has been released as open-source. The main project was published at USENIX ATC and won Best Paper.&nbsp; We also published work on high-performance distributed data storage.&nbsp; Our work demonstrates that Grappa is faster and more flexible than competing infrastructures such as GraphLab and Spark.</p> <p>&nbsp;</p> <p>&nbsp;</p> <p><span style="text-decoration: underline;"><strong>Websites</strong></span></p> <p>&nbsp;</p> <p>GraphBench (http://graphbench.org):&nbsp; GraphBench is not a traditional plug-and-play benchmark suite with a do-everything run script.&nbsp; Instead we provide components you can use to assemble your own evaluation strategy.&nbsp; We believe this is the right strategy given the diversity of graph frameworks out there.</p> <p><br />Grappa -- Scaling Data-Intensive Applications on Commodity Clusters (http://grappa.io).&nbsp; Grappa makes an entire cluster look like a single, powerful, shared-memory machine.&nbsp; By leveraging the massive amount of concurrency in large-scale data-intensive applications, Grappa can provide this useful abstraction with high performance.&nbsp; Unlike classic distributed shared memory (DSM) systems, Grappa does not require spatial locality or data reuse to perform well.</p> <p>&nbsp;</p> <p>&nbsp;</p> <p><strong>Impacts</strong></p> <p>&nbsp;</p> <p>The cluster we built for research is freely shared among any researchers that need access to a small HPC cluster.&nbsp; Efficiently computing on large graphs is a large unsolved problem in our field.&nbsp; If we can efficiently answer questions such as betweenness centrality, connected components, etc., then many interesting questions in biology, social networks, and defense become tractable. This is why we do this work.&nbsp; We have been moving "up the stack" in the programming language and "down the stack" into architecture.&nbsp; We found that developers do not want to write in C++ anymore and would prefer Python or SQL.&nbsp; Our recent efforts have been focused on making Grappa-like technology available in these languages.&nbsp; We have also been looking at heterogeneous fine-grained threading and what (if any) architecture changes are necessary.&nbsp; Our goal is a unified address space system for fine-grained threading applications that works across CPUs, GPUs, and smart-discs.</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 11/28/2017<br>      Modified by: Mark&nbsp;H&nbsp;Oskin</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Overview     The goals of this project are to make applications that exhibit irregular parallelism and poor locality scale to large multinode clusters.  Furthermore, these applications should be easy to write and tune.  The infrastructure developed should be open-sourced and widely distributed and supported.  The team has spent extensive amounts of time building and tuning the core infrastructure (Grappa). We have built a compiler that takes SQL-like queries and compiles them to execute on an in-memory database built on top of Grappa.  The core runtime is now open sourced (BSD license).  We also built a benchmark suite for graph analytics (GraphBench).  The students and PIs actively promoted the effort through talks and site visits.  We have been busy exploring new software and hardware options for distributed fine-grained threading on heterogeneous platforms.  The core infrastructure we worked on (Grappa) has been released as open-source. The main project was published at USENIX ATC and won Best Paper.  We also published work on high-performance distributed data storage.  Our work demonstrates that Grappa is faster and more flexible than competing infrastructures such as GraphLab and Spark.        Websites     GraphBench (http://graphbench.org):  GraphBench is not a traditional plug-and-play benchmark suite with a do-everything run script.  Instead we provide components you can use to assemble your own evaluation strategy.  We believe this is the right strategy given the diversity of graph frameworks out there.   Grappa -- Scaling Data-Intensive Applications on Commodity Clusters (http://grappa.io).  Grappa makes an entire cluster look like a single, powerful, shared-memory machine.  By leveraging the massive amount of concurrency in large-scale data-intensive applications, Grappa can provide this useful abstraction with high performance.  Unlike classic distributed shared memory (DSM) systems, Grappa does not require spatial locality or data reuse to perform well.        Impacts     The cluster we built for research is freely shared among any researchers that need access to a small HPC cluster.  Efficiently computing on large graphs is a large unsolved problem in our field.  If we can efficiently answer questions such as betweenness centrality, connected components, etc., then many interesting questions in biology, social networks, and defense become tractable. This is why we do this work.  We have been moving "up the stack" in the programming language and "down the stack" into architecture.  We found that developers do not want to write in C++ anymore and would prefer Python or SQL.  Our recent efforts have been focused on making Grappa-like technology available in these languages.  We have also been looking at heterogeneous fine-grained threading and what (if any) architecture changes are necessary.  Our goal is a unified address space system for fine-grained threading applications that works across CPUs, GPUs, and smart-discs.             Last Modified: 11/28/2017       Submitted by: Mark H Oskin]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
