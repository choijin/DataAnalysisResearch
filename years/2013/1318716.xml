<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>Computation with Finitely Presented Groups</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/15/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>269538.00</AwardTotalIntnAmount>
<AwardAmount>269538</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>03040000</Code>
<Directorate>
<Abbreviation>MPS</Abbreviation>
<LongName>Direct For Mathematical &amp; Physical Scien</LongName>
</Directorate>
<Division>
<Abbreviation>DMS</Abbreviation>
<LongName>Division Of Mathematical Sciences</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Rosemary Renaut</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>Intractable computational problems, in particular recursively unsolvable problems, occur naturally in combinatorial group theory and have been studied in that context for over a hundred years. This project is devoted to finding better algorithms and partial algorithms for these problems, both for well-known ones and also for new ones which have arisen, for example, in group-based cryptography. Using techniques developed in their previous work, the investigators will perform computer experiments to discover and test new computational procedures and also to gather information on the distribution of hard instances in specific problems.  &lt;br/&gt;&lt;br/&gt;An algorithm for a computational problem may be useful even though it sometimes fails, if its failures are rare. A well known example is the simplex algorithm for linear optimization. This algorithm (which is used hundreds or thousands of times every day) can take a very long time for certain carefully constructed cases but never does so in practice. In other words the difficult cases are extremely rare. Although there are many other algorithms which behave the same way, this phenomenon is not well understood. The broader significance of this project is that it seeks a better understanding through investigation of an appropriate class of computational problems.</AbstractNarration>
<MinAmdLetterDate>09/08/2013</MinAmdLetterDate>
<MaxAmdLetterDate>09/08/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.049</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1318716</AwardID>
<Investigator>
<FirstName>Robert</FirstName>
<LastName>Gilman</LastName>
<PI_MID_INIT>H</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Robert H Gilman</PI_FULL_NAME>
<EmailAddress>rgilman@stevens.edu</EmailAddress>
<PI_PHON>2012165440</PI_PHON>
<NSF_ID>000171265</NSF_ID>
<StartDate>09/08/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Mark</FirstName>
<LastName>Sapir</LastName>
<PI_MID_INIT>V</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Mark V Sapir</PI_FULL_NAME>
<EmailAddress>m.sapir@vanderbilt.edu</EmailAddress>
<PI_PHON>6153226657</PI_PHON>
<NSF_ID>000488882</NSF_ID>
<StartDate>09/08/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Alexei</FirstName>
<LastName>Miasnikov</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Alexei Miasnikov</PI_FULL_NAME>
<EmailAddress>amiasnik@stevens.edu</EmailAddress>
<PI_PHON>2012168598</PI_PHON>
<NSF_ID>000502684</NSF_ID>
<StartDate>09/08/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Alexander</FirstName>
<LastName>Ushakov</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Alexander Ushakov</PI_FULL_NAME>
<EmailAddress>sasha.ushakov@gmail.com</EmailAddress>
<PI_PHON>2012168597</PI_PHON>
<NSF_ID>000519184</NSF_ID>
<StartDate>09/08/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Alexey</FirstName>
<LastName>Myasnikov</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Alexey Myasnikov</PI_FULL_NAME>
<EmailAddress>amyasnik@stevens.edu</EmailAddress>
<PI_PHON>2012168599</PI_PHON>
<NSF_ID>000593294</NSF_ID>
<StartDate>09/08/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Stevens Institute of Technology</Name>
<CityName>HOBOKEN</CityName>
<ZipCode>070305991</ZipCode>
<PhoneNumber>2012168762</PhoneNumber>
<StreetAddress>CASTLE POINT ON HUDSON</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>08</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ08</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>064271570</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>STEVENS INSTITUTE OF TECHNOLOGY (INC)</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>064271570</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Stevens Institute of Technology]]></Name>
<CityName>Hoboken</CityName>
<StateCode>NJ</StateCode>
<ZipCode>070305991</ZipCode>
<StreetAddress><![CDATA[Castle Point on Hudson]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>08</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ08</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1271</Code>
<Text>COMPUTATIONAL MATHEMATICS</Text>
</ProgramElement>
<ProgramReference>
<Code>9263</Code>
<Text>COMPUTATIONAL SCIENCE &amp; ENGING</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~269538</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><strong>Project Outcomes for DMS-1318716 </strong><br /><strong>Computation with Finitely Presented Groups </strong><br />&nbsp;<br />The goal of this project was to study computational problems about finitely presented groups (which we will refer to as groups from now on). An example of such a problem is to decide if a group is finite or infinite. It is known that this problem, along with most other computational problems about groups, is uncomputable. Any algorithm or computer program to solve the problem must fail for infinitely many groups. Because of this phenomenon special techniques are needed to analyze the efficiency of algorithms for groups.&nbsp; <br />&nbsp;<br /><strong>The Finiteness Problem for Finitely Presented Groups </strong><br />&nbsp;<br />A finite presentation has the following form.&nbsp; <br />&nbsp;<br />(1)&nbsp;&nbsp;&nbsp;<em> G = &lt; a, b | abAB, aaa &gt;</em> <br />&nbsp;<br />This presentation says that <em>G</em> is composed of elements which are named by words in the letters <em>a</em> and <em>b</em> and <em>A</em> and <em>B</em>. By "word" we mean any sequence of letters. For example aaAbaBA is a word. <br />&nbsp;<br />The words <em>abAB </em>and <strong>aaa</strong> in (1) are called the relators of the presentation (1). The trivial relators <em>Aa</em>, <em>aA, bB</em> and <em>Bb</em> are always included implicitly. <br />&nbsp;<br />Clearly there are infinitely many words, so there are infinitely many names. However G might not be infinite, because different words can name the same group element.&nbsp; <br />&nbsp;<br />When does this happen? The rule is that if you insert a relator anywhere into a word (including at either end of the word), then the new word names the same group element as the original word does.&nbsp; <br />&nbsp;<br />Example 1.&nbsp; <em>aaAbaBA, aaAaaabaBA </em>and <em>aaAbabABaBA</em> all name the same group element. <br />&nbsp;<br />Of course this procedure works in the other direction too. If you delete a relator from a word, then the new word names the same group element as the original word does. <br />&nbsp;<br />The bottom line is that two words name the same group element if and only if you can change one word into the other by a chain of insertions and deletions of relators. Using <em>~</em> to denote the transition from one word to the next we have&nbsp; <br />&nbsp;<br />Example 2. <em>BA ~ BAabAB ~ BbAB ~ AB </em><br />&nbsp;<br />So <em>BA</em> and<em> AB</em> (and <em>BAabAB</em> and <em>BbAB</em> as well) name the same group element.&nbsp; <br />&nbsp;<br /><em>G </em>will be infinite if and only if there are infinitely many words, no two of which can be changed into each other by insertions and deletions of relators. As we noted above the problem of checking this condition for presentations is uncomputable. However one may still ask if there is an algorithm which works almost all the time. Questions like this were the starting point for our project.&nbsp; <br />&nbsp;<br /><strong>Results of the Project </strong><br />&nbsp;<br />There are lots of computational problems about groups. We studied many during the course of this project, including a number of new ones. Some of these problems were used for doctoral dissertations.</p> <p>We published our results in research journals, and presented them at conferences. Our work attracted the interest of other researchers. <br />&nbsp;<br />What about the broader impact of our work? This is a tricky question, because mathematical research which looks useless outside its ambient discipline can be useful in surprising ways later. In any case we suggest a potential application of our work to public key cryptography.&nbsp; <br />&nbsp;<br /><strong>Public Key Cryptography </strong><br />&nbsp;<br />You use public key cryptography whenever you withdraw money from an ATM or order online from Amazon. Public key cryptosystems protect your bank account and credit card information from eavesdroppers. However, there is no proof that these cryptosystems work.&nbsp; <br />&nbsp;<br />Public key systems depend on practical computational problems. In order for a system to be both secure and useful it must be possible to efficiently pick out hard instances of the computational problem for that system.&nbsp; <br />&nbsp;<br />For the well known RSA public key system the computational problem is factoring specially chosen integers. The integers, which are hundreds of digits long, each factor in just one way as products of two smaller integers (both greater than 1); but if you just know just the big integer it is supposed to&nbsp; be impossible to find its two factors in any reasonable amount of time.&nbsp; <br />&nbsp;<br />The situation is similar for all public key systems. Selection of hard instances is done by various heuristic methods which seem to work, but there is no proof. <br />&nbsp;<br />One of the results of our project is what seems to be the first known example of a practical computational problem for which provably hard instances can be picked out efficiently [1]. This problem is not suitable for public key cryptography. Indeed it is very unlikely that one can prove the same result for a problem which is suitable. Nevertheless our work does suggest a new line of inquiry into a foundational problem of public key cryptography. <br />&nbsp;<br />[1] R. Gilman, A finitely presented group whose word problem has sampleable hard instances, arXiv:0707.1364 [cs.CC]. <br />&nbsp;<br />&nbsp;<br />&nbsp;<br />&nbsp; <br /></p><br> <p>            Last Modified: 10/10/2016<br>      Modified by: Robert&nbsp;H&nbsp;Gilman</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Project Outcomes for DMS-1318716  Computation with Finitely Presented Groups    The goal of this project was to study computational problems about finitely presented groups (which we will refer to as groups from now on). An example of such a problem is to decide if a group is finite or infinite. It is known that this problem, along with most other computational problems about groups, is uncomputable. Any algorithm or computer program to solve the problem must fail for infinitely many groups. Because of this phenomenon special techniques are needed to analyze the efficiency of algorithms for groups.     The Finiteness Problem for Finitely Presented Groups    A finite presentation has the following form.     (1)    G = &lt; a, b | abAB, aaa &gt;    This presentation says that G is composed of elements which are named by words in the letters a and b and A and B. By "word" we mean any sequence of letters. For example aaAbaBA is a word.    The words abAB and aaa in (1) are called the relators of the presentation (1). The trivial relators Aa, aA, bB and Bb are always included implicitly.    Clearly there are infinitely many words, so there are infinitely many names. However G might not be infinite, because different words can name the same group element.     When does this happen? The rule is that if you insert a relator anywhere into a word (including at either end of the word), then the new word names the same group element as the original word does.     Example 1.  aaAbaBA, aaAaaabaBA and aaAbabABaBA all name the same group element.    Of course this procedure works in the other direction too. If you delete a relator from a word, then the new word names the same group element as the original word does.    The bottom line is that two words name the same group element if and only if you can change one word into the other by a chain of insertions and deletions of relators. Using ~ to denote the transition from one word to the next we have     Example 2. BA ~ BAabAB ~ BbAB ~ AB    So BA and AB (and BAabAB and BbAB as well) name the same group element.     G will be infinite if and only if there are infinitely many words, no two of which can be changed into each other by insertions and deletions of relators. As we noted above the problem of checking this condition for presentations is uncomputable. However one may still ask if there is an algorithm which works almost all the time. Questions like this were the starting point for our project.     Results of the Project    There are lots of computational problems about groups. We studied many during the course of this project, including a number of new ones. Some of these problems were used for doctoral dissertations.  We published our results in research journals, and presented them at conferences. Our work attracted the interest of other researchers.    What about the broader impact of our work? This is a tricky question, because mathematical research which looks useless outside its ambient discipline can be useful in surprising ways later. In any case we suggest a potential application of our work to public key cryptography.     Public Key Cryptography    You use public key cryptography whenever you withdraw money from an ATM or order online from Amazon. Public key cryptosystems protect your bank account and credit card information from eavesdroppers. However, there is no proof that these cryptosystems work.     Public key systems depend on practical computational problems. In order for a system to be both secure and useful it must be possible to efficiently pick out hard instances of the computational problem for that system.     For the well known RSA public key system the computational problem is factoring specially chosen integers. The integers, which are hundreds of digits long, each factor in just one way as products of two smaller integers (both greater than 1); but if you just know just the big integer it is supposed to  be impossible to find its two factors in any reasonable amount of time.     The situation is similar for all public key systems. Selection of hard instances is done by various heuristic methods which seem to work, but there is no proof.    One of the results of our project is what seems to be the first known example of a practical computational problem for which provably hard instances can be picked out efficiently [1]. This problem is not suitable for public key cryptography. Indeed it is very unlikely that one can prove the same result for a problem which is suitable. Nevertheless our work does suggest a new line of inquiry into a foundational problem of public key cryptography.    [1] R. Gilman, A finitely presented group whose word problem has sampleable hard instances, arXiv:0707.1364 [cs.CC].                  Last Modified: 10/10/2016       Submitted by: Robert H Gilman]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
