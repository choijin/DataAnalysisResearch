<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Contracts for Message-Passing Parallel Programs</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>449999.00</AwardTotalIntnAmount>
<AwardAmount>463999</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Software plays an increasingly important role in science and engineering. The design of aircraft, sky scrapers, and automobiles; climate modeling and weather prediction; and the development of new pharmaceuticals, are just a few of the many endeavors that use computer programs to simulate natural phenomena. Yet studies have shown that many of these programs are ridden with defects ("bugs") that may lead to incorrect results. The same is true in other software domains, but the problems with scientific software are particularly acute for several reasons. Most significantly, much scientific software is "message-passing" parallel software---designed to execute on "supercomputers" which are networks of many thousands of processors. While there are many methods to help develop verifiably correct sequential programs, few of these have been extended to parallel programs. The "Design by Contract" methodology --- which works by decomposing a program into parts that can be specified and verified independently --- is one such approach, and has been successfully applied to sequential programs in a variety of domains. Professor Siegel's project is extending that methodology to apply to message-passing parallel programs, enabling the development of much more reliable scientific and engineering applications.&lt;br/&gt;&lt;br/&gt;The approach generalizes and extends existing contract specification and verification mechanisms in various ways. As in the sequential case, a procedural decomposition is used, but each procedure can be executed by multiple processes that are not necessarily running in lockstep. The contract pre-conditions and post-conditions are interpreted as "collective assertions". These are expressions that can refer to the state of multiple processes and have a special semantics: to evaluate such an expression a snapshot of the local state of each process is taken as it passes through the assertion location; once a snapshot has been obtained from each process they are composed to form a global state in which the expression is evaluated. Contracts must also refer to the state of the message buffers, for example, to express that there are no unreceived messages from one process to another. Symbolic execution and model checking techniques are used to verify a procedure satisfies its contract. These ideas are being realized as an extension to the Toolkit for Accurate Scientific Software (TASS), and applied to programs written in C with the widely-used Message Passing Interface.</AbstractNarration>
<MinAmdLetterDate>08/09/2013</MinAmdLetterDate>
<MaxAmdLetterDate>05/15/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1319571</AwardID>
<Investigator>
<FirstName>Stephen</FirstName>
<LastName>Siegel</LastName>
<PI_MID_INIT>F</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephen F Siegel</PI_FULL_NAME>
<EmailAddress>siegel@udel.edu</EmailAddress>
<PI_PHON>3028310083</PI_PHON>
<NSF_ID>000264334</NSF_ID>
<StartDate>08/09/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Delaware</Name>
<CityName>Newark</CityName>
<ZipCode>197160099</ZipCode>
<PhoneNumber>3028312136</PhoneNumber>
<StreetAddress>210 Hullihen Hall</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Delaware</StateName>
<StateCode>DE</StateCode>
<CONGRESSDISTRICT>00</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>DE00</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>059007500</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF DELAWARE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>059007500</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Delaware]]></Name>
<CityName>Newark</CityName>
<StateCode>DE</StateCode>
<ZipCode>197162553</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Delaware</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>00</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>DE00</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~449999</FUND_OBLG>
<FUND_OBLG>2014~14000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Programming is hard business. Even the best programmers occasionally make mistakes which result in defects -- or "bugs" -- in their programs. &nbsp; Despite a tremendous amount of effort and research directed at preventing, detecting, and correcting such defects, defective programs are ubiquitous.</p> <p>The problems are compounded in the case of parallel programs, which are designed to execute using multiple processors. These kinds of programs are used to solve the most computationally demanding tasks, including many problems in science and engineering. Climate and ocean modeling, weather prediction, and the design of aircraft, automobiles, and buildings all rely heavily on the power of parallel computers. Defects in the programs used in those areas can result in incorrect scientific conclusions, defective products, or even loss of life. Tools to help get these programs right are therefore of paramount importance to society.</p> <p>This project developed new techniques for ensuring correctness of programs, especially scientific and parallel programs.</p> <p>One of the important contributions of the project was the development of a new contract language for message-passing parallel programs. Contract languages for sequential programs, such as the ANSI C Specification Language (ACSL), have been around for years. They provide an effective way to precisely specify the intended behavior of individual program elements, such as procedures.</p> <p>The new contract language extends ACSL with primitives for specifying the behavior of parallel programs that use the Message Passing Interface (MPI). This extended ACSL allows the programmer-user to express the relation between the pre-state and the post-state of a collective-style procedure from a "global view". It also includes primitives for expressing synchronization constraints, such as "process i will not exit until project j has entered" the procedure.</p> <p>The project has also resulted in a tool to verify that MPI programs adhere to their contracts. Implemented in the CIVL symbolic execution framework, the tool takes a C/MPI program annotated with procedure contracts and loop invariants, and translates it into the CIVL intermediate language. The post-translation CIVL program has assertions which are violated only if the original program had contract violations. The CIVL verifier can be used to verify absence of these assertion violations within a bounded region of the parameter space. With appropriate loop invariants, bounds on many parameters, such as array lengths, can be removed, though the tool still requires relatively small bounds on the number of processes.</p> <p>The work also resulted in a large number of improvements to the CIVL verifier, making it a much more effective tool for verifying both sequential and parallel C programs. The project investigators, their collaborators, and others have applied CIVL to a number of non-trivial problems in computational science. These include verifying the functional correctness of an implementation of Strassen's matrix multiplication algorithm, a conjugate gradient solver, an MPI-based solver of the one-dimensional wave equation, and a tensor transposition code.</p><br> <p>            Last Modified: 12/26/2018<br>      Modified by: Stephen&nbsp;F&nbsp;Siegel</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Image         </div> <div class="galControls onePhoto" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation onePhoto" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2018/1319571/1319571_10265708_1545840096250_ghost_exchange_contract--rgov-214x142.jpg" original="/por/images/Reports/POR/2018/1319571/1319571_10265708_1545840096250_ghost_exchange_contract--rgov-800width.jpg" title="Contract for an MPI Ghost Exchange"><img src="/por/images/Reports/POR/2018/1319571/1319571_10265708_1545840096250_ghost_exchange_contract--rgov-66x44.jpg" alt="Contract for an MPI Ghost Exchange"></a> <div class="imageCaptionContainer"> <div class="imageCaption">A code contract for a C/MPI function that performs a one-dimensional ghost cell exchange.  The contract is expressed in an extension to the ACSL contract language which supports the Message Passing Interface.</div> <div class="imageCredit">Ziqing Luo and Stephen Siegel</div> <div class="imageSubmitted">Stephen&nbsp;F&nbsp;Siegel</div> <div class="imageTitle">Contract for an MPI Ghost Exchange</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Programming is hard business. Even the best programmers occasionally make mistakes which result in defects -- or "bugs" -- in their programs.   Despite a tremendous amount of effort and research directed at preventing, detecting, and correcting such defects, defective programs are ubiquitous.  The problems are compounded in the case of parallel programs, which are designed to execute using multiple processors. These kinds of programs are used to solve the most computationally demanding tasks, including many problems in science and engineering. Climate and ocean modeling, weather prediction, and the design of aircraft, automobiles, and buildings all rely heavily on the power of parallel computers. Defects in the programs used in those areas can result in incorrect scientific conclusions, defective products, or even loss of life. Tools to help get these programs right are therefore of paramount importance to society.  This project developed new techniques for ensuring correctness of programs, especially scientific and parallel programs.  One of the important contributions of the project was the development of a new contract language for message-passing parallel programs. Contract languages for sequential programs, such as the ANSI C Specification Language (ACSL), have been around for years. They provide an effective way to precisely specify the intended behavior of individual program elements, such as procedures.  The new contract language extends ACSL with primitives for specifying the behavior of parallel programs that use the Message Passing Interface (MPI). This extended ACSL allows the programmer-user to express the relation between the pre-state and the post-state of a collective-style procedure from a "global view". It also includes primitives for expressing synchronization constraints, such as "process i will not exit until project j has entered" the procedure.  The project has also resulted in a tool to verify that MPI programs adhere to their contracts. Implemented in the CIVL symbolic execution framework, the tool takes a C/MPI program annotated with procedure contracts and loop invariants, and translates it into the CIVL intermediate language. The post-translation CIVL program has assertions which are violated only if the original program had contract violations. The CIVL verifier can be used to verify absence of these assertion violations within a bounded region of the parameter space. With appropriate loop invariants, bounds on many parameters, such as array lengths, can be removed, though the tool still requires relatively small bounds on the number of processes.  The work also resulted in a large number of improvements to the CIVL verifier, making it a much more effective tool for verifying both sequential and parallel C programs. The project investigators, their collaborators, and others have applied CIVL to a number of non-trivial problems in computational science. These include verifying the functional correctness of an implementation of Strassen's matrix multiplication algorithm, a conjugate gradient solver, an MPI-based solver of the one-dimensional wave equation, and a tensor transposition code.       Last Modified: 12/26/2018       Submitted by: Stephen F Siegel]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
