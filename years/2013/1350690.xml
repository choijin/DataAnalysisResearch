<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Static Analysis for Dynamic Languages</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/01/2014</AwardEffectiveDate>
<AwardExpirationDate>03/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>512864.00</AwardTotalIntnAmount>
<AwardAmount>512864</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Dynamic languages such as JavaScript, Python, and Ruby are ubiquitous; they are employed in critical infrastructure on clients, servers, and desktops, from browsers to the operating systems. The security, maintainability, correctness, and performance of programs written in these languages is becoming increasingly important. Static analysis is a valuable tool to help achieve these goals. However, static analysis of dynamic languages is a significant challenge due to their inherent dynamism, complicated semantics, and obscure corner cases, all of which conspire to make most static analyses incorrect, intractable, or both. The objective of this research is to extend the state of the art in terms of correctness, precision, and performance for static analysis of dynamic languages.&lt;br/&gt;&lt;br/&gt;The intellectual merits of this research involve novel contributions in three areas: (1) ensuring the correctness of a static analysis via analysis testing, enabling high correctness assurance with low cost; (2) exploring the tradeoffs between analysis performance and precision by a novel framework for tunable analysis sensitivity, enabling empirical investigation into the most productive forms of static analysis for dynamic languages; and (3) refinement and parallelization strategies to help optimize analysis performance and precision, combatting the challenges of dynamic languages outlined above. Beyond the technical contributions, the broader impacts of this research are in education, the research community, and in industry. The insights and artifacts resulting from this research will be used to create novel curricula for both undergraduate and graduate courses. All of the research artifacts will be made publicly available under an open license, and the PI will use his connections to industrial research labs to facilitate technology transfer to industry.</AbstractNarration>
<MinAmdLetterDate>03/14/2014</MinAmdLetterDate>
<MaxAmdLetterDate>05/07/2018</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1350690</AwardID>
<Investigator>
<FirstName>Ben</FirstName>
<LastName>Hardekopf</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ben Hardekopf</PI_FULL_NAME>
<EmailAddress>benh@cs.ucsb.edu</EmailAddress>
<PI_PHON>8056175129</PI_PHON>
<NSF_ID>000549385</NSF_ID>
<StartDate>03/14/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Santa Barbara</Name>
<CityName>Santa Barbara</CityName>
<ZipCode>931062050</ZipCode>
<PhoneNumber>8058934188</PhoneNumber>
<StreetAddress>Office of Research</StreetAddress>
<StreetAddress2><![CDATA[Rm 3227 Cheadle Hall]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>24</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA24</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>094878394</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CALIFORNIA, SANTA BARBARA</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Santa Barbara]]></Name>
<CityName/>
<StateCode>CA</StateCode>
<ZipCode>931065110</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>24</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA24</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0117</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0118</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~193311</FUND_OBLG>
<FUND_OBLG>2016~102492</FUND_OBLG>
<FUND_OBLG>2017~106129</FUND_OBLG>
<FUND_OBLG>2018~110932</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Non-statically typed programming languages permeate the world, from web browser addons/extensions and server-side applications written in JavaScript (dynamically typed, responsible for dealing with online financial transactions, medical records, shopping, entertainment, etc) to the underlying binary executables that interface with a processor's Instruction Set Architecture (completely untyped, responsible for the lowest levels of software execution). Statically typed programming languages offer guarantees about a program's behavior that we know must hold without even executing the program in question; these guarantees offer assurances about correctness and security and also provide a good platform for static analyses that seek to offer even stronger guarantees and assurances. However, non-statically typed languages have no such guarantees or assurances; the only way to detect incorrectness or insecurity is to execute the program and see if anything goes wrong (in the hopes that if something does go wrong it will be detectable, which is not always true). Static analyses of such programs are exceptionally complicated and difficult, and thus deriving such guarantees and assurances is a hard problem whose solution can have a strong impact on the world of computing.</p> <p><br />The goal of this project was to improve the above situation, that is, to develop techniques to improve static analysis of non-statically typed languages in terms of analysis correctness, precision, and performance. A primary thrust of this work was analysis correctness, because while static analysis is already complicated and difficult, and even more so without being able to rely on static types, attempts to improve precision and performance invariably make the analysis even more complicated and fragile and correctness even harder to achieve. Other related threads include software fuzzing (which we originally investigated to support analysis testing, but which we then extended to general fuzzing techniques) and developing a brand-new processor ISA (with the intention of circumventing the problems with binary static analysis on existing untyped ISAs by creating one designed from scratch to support analysis).</p> <p><br />To improve the correctness of static analyses of non-statically typed languages, we focused on analysis testing. That is, once the analysis is implemented how can we convince ourselves that we're getting correct answers? This area is vitally important, but woefully under-studied. We developed a novel testing methodology that uses Constraint Logic Programming to automatically generate many thousands of random but syntactically valid programs with which we can test whether the static analysis correctly predicts their behaviors. An interesting point we discovered is that random syntactically valid programs in such languages usually only do trivial things (e.g., throw an exception and exit). In order to generate interesting, non-trivial programs we had to develop our own type system that guarantees that the generated programs do "interesting things" and adapt our CLP technique to obey that type system.</p> <p><br />The above work naturally led to the area of software fuzzing: randomly generating inputs to test a software system. We extended our fuzzing work to start testing Satisfiability Modulo Theories (SMT) solvers. SMT solvers are, essentially, a form of static analysis and also form the foundation of many static analyses, thus testing them for correctness is important. We developed a novel technique for generating SMT formulae with a priori known satisfiability (i.e., we can generate many formulae that are known to be satisfiable and many that are known to be unsatisfiable); this allows us to test the SMT solver to determine if it arrives at the correct answer. This work led to uncovering a fixing many bugs in existing industry-quality solvers such as Microsoft's Z3.</p> <p><br />Our fuzzing work led us to the realization that existing state of the art methods for comparing the relative qualityu of competing fuzzers are severely lacking. These existing methods can lead to misleading or even incorrect results, thus retarding progress in this field. We have developed a new methodology for fuzzer comparison and have empirically demonstrated that it is superior to all existing methodologies.</p> <p><br />Our final thrust was dealing with verifying software binaries. Verifying binaries in existing untyped ISAs such as ARM, x86, etc is extremely difficult because the lack of types amke it hard to determine even trivial properties of the software. Rather than attempt to overcome this problem directly, we instead approached it from a different direction: what if we designed a typed ISA specifically created to enable binary verification and enforce that only verified binaries can be executed? We designed and implemented exactly such an ISA, called Zarf, along with an accompanying compiler, and both formally proved and empirically demonstrated that it enables guaranteed execution of verified binaries.</p><br> <p>            Last Modified: 07/30/2019<br>      Modified by: Ben&nbsp;Hardekopf</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Non-statically typed programming languages permeate the world, from web browser addons/extensions and server-side applications written in JavaScript (dynamically typed, responsible for dealing with online financial transactions, medical records, shopping, entertainment, etc) to the underlying binary executables that interface with a processor's Instruction Set Architecture (completely untyped, responsible for the lowest levels of software execution). Statically typed programming languages offer guarantees about a program's behavior that we know must hold without even executing the program in question; these guarantees offer assurances about correctness and security and also provide a good platform for static analyses that seek to offer even stronger guarantees and assurances. However, non-statically typed languages have no such guarantees or assurances; the only way to detect incorrectness or insecurity is to execute the program and see if anything goes wrong (in the hopes that if something does go wrong it will be detectable, which is not always true). Static analyses of such programs are exceptionally complicated and difficult, and thus deriving such guarantees and assurances is a hard problem whose solution can have a strong impact on the world of computing.   The goal of this project was to improve the above situation, that is, to develop techniques to improve static analysis of non-statically typed languages in terms of analysis correctness, precision, and performance. A primary thrust of this work was analysis correctness, because while static analysis is already complicated and difficult, and even more so without being able to rely on static types, attempts to improve precision and performance invariably make the analysis even more complicated and fragile and correctness even harder to achieve. Other related threads include software fuzzing (which we originally investigated to support analysis testing, but which we then extended to general fuzzing techniques) and developing a brand-new processor ISA (with the intention of circumventing the problems with binary static analysis on existing untyped ISAs by creating one designed from scratch to support analysis).   To improve the correctness of static analyses of non-statically typed languages, we focused on analysis testing. That is, once the analysis is implemented how can we convince ourselves that we're getting correct answers? This area is vitally important, but woefully under-studied. We developed a novel testing methodology that uses Constraint Logic Programming to automatically generate many thousands of random but syntactically valid programs with which we can test whether the static analysis correctly predicts their behaviors. An interesting point we discovered is that random syntactically valid programs in such languages usually only do trivial things (e.g., throw an exception and exit). In order to generate interesting, non-trivial programs we had to develop our own type system that guarantees that the generated programs do "interesting things" and adapt our CLP technique to obey that type system.   The above work naturally led to the area of software fuzzing: randomly generating inputs to test a software system. We extended our fuzzing work to start testing Satisfiability Modulo Theories (SMT) solvers. SMT solvers are, essentially, a form of static analysis and also form the foundation of many static analyses, thus testing them for correctness is important. We developed a novel technique for generating SMT formulae with a priori known satisfiability (i.e., we can generate many formulae that are known to be satisfiable and many that are known to be unsatisfiable); this allows us to test the SMT solver to determine if it arrives at the correct answer. This work led to uncovering a fixing many bugs in existing industry-quality solvers such as Microsoft's Z3.   Our fuzzing work led us to the realization that existing state of the art methods for comparing the relative qualityu of competing fuzzers are severely lacking. These existing methods can lead to misleading or even incorrect results, thus retarding progress in this field. We have developed a new methodology for fuzzer comparison and have empirically demonstrated that it is superior to all existing methodologies.   Our final thrust was dealing with verifying software binaries. Verifying binaries in existing untyped ISAs such as ARM, x86, etc is extremely difficult because the lack of types amke it hard to determine even trivial properties of the software. Rather than attempt to overcome this problem directly, we instead approached it from a different direction: what if we designed a typed ISA specifically created to enable binary verification and enforce that only verified binaries can be executed? We designed and implemented exactly such an ISA, called Zarf, along with an accompanying compiler, and both formally proved and empirically demonstrated that it enables guaranteed execution of verified binaries.       Last Modified: 07/30/2019       Submitted by: Ben Hardekopf]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
