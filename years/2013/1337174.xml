<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>XPS: CLCCA: Improving Parallel Program Reliability Through Novel Approaches to Precise Dynamic Data Race Detection</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>700000.00</AwardTotalIntnAmount>
<AwardAmount>700000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Yuanyuan Yang</SignBlockName>
<PO_EMAI>yyang@nsf.gov</PO_EMAI>
<PO_PHON>7032928067</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The ubiquity of multi-core processors in everything from servers to&lt;br/&gt;smartphones has demanded a similar prevalence of multi-threaded&lt;br/&gt;programs to take advantage of multiple cores. Unfortunately, writing&lt;br/&gt;multi-threaded code is still in the Wild West era of error-prone manual&lt;br/&gt;synchronization, unchecked concurrency bugs, and undefined semantics.&lt;br/&gt;One common symptom of an error in a multi-threaded program is a data&lt;br/&gt;race. Data races arise when a program performs concurrent updates to&lt;br/&gt;some location without synchronization. Automatically detecting data&lt;br/&gt;races during program execution enforces strong safety properties for&lt;br/&gt;multi-threaded programs. While techniques for data race detection exist&lt;br/&gt;they slow program execution too much to be viable for always-on&lt;br/&gt;enforcement.&lt;br/&gt;&lt;br/&gt;To make always-on detection of data races practical, the project aims&lt;br/&gt;to develop new algorithms, language extensions, runtime systems, and&lt;br/&gt;hardware support to improve the efficiency of data race detection. The&lt;br/&gt;research includes validation of these techniques via formal proofs,&lt;br/&gt;experiments with multi-threaded benchmark suites, and detailed hardware&lt;br/&gt;simulation. The researchers plan to openly distribute the systems&lt;br/&gt;built for this project to facilitate examination by other researchers&lt;br/&gt;and integrate the research results into the computer architecture&lt;br/&gt;courses they teach. If successful, the proposed technology will&lt;br/&gt;improve the safety and quality of the vast amounts of multi-threaded&lt;br/&gt;code running on today's and tomorrow?s multi-core devices.</AbstractNarration>
<MinAmdLetterDate>08/24/2013</MinAmdLetterDate>
<MaxAmdLetterDate>08/24/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1337174</AwardID>
<Investigator>
<FirstName>Stephan</FirstName>
<LastName>Zdancewic</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephan A Zdancewic</PI_FULL_NAME>
<EmailAddress>stevez@cis.upenn.edu</EmailAddress>
<PI_PHON>2158982661</PI_PHON>
<NSF_ID>000220116</NSF_ID>
<StartDate>08/24/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Milo</FirstName>
<LastName>Martin</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Milo Martin</PI_FULL_NAME>
<EmailAddress>milom@cis.upenn.edu</EmailAddress>
<PI_PHON>2157462972</PI_PHON>
<NSF_ID>000383219</NSF_ID>
<StartDate>08/24/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Joseph</FirstName>
<LastName>Devietti</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Joseph Devietti</PI_FULL_NAME>
<EmailAddress>devietti@cis.upenn.edu</EmailAddress>
<PI_PHON>2158988133</PI_PHON>
<NSF_ID>000642229</NSF_ID>
<StartDate>08/24/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Pennsylvania</Name>
<CityName>Philadelphia</CityName>
<ZipCode>191046205</ZipCode>
<PhoneNumber>2158987293</PhoneNumber>
<StreetAddress>Research Services</StreetAddress>
<StreetAddress2><![CDATA[3451 Walnut St, 5th Flr Franklin]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>042250712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042250712</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Pennsylvania]]></Name>
<CityName>Philadelphia</CityName>
<StateCode>PA</StateCode>
<ZipCode>191046205</ZipCode>
<StreetAddress><![CDATA[3451 Walnu Street P-221]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8283</Code>
<Text>Exploiting Parallel&amp;Scalabilty</Text>
</ProgramElement>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~700000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Humans often struggle with juggling multiple tasks at one time. Software developers are no exception, though they are frequently asked to write programs that perform multiple tasks at once so as to take advantage of today's ubiquitous multicore computer processors. We refer to a computer program that does multiple computations at the same time as a <em>parallel</em> computer program. Errors can arise from incorrectly managing the parallelism within a program, similar to having two chefs trying to use a single pan at the same time -- neither of their dishes&nbsp;are going to come out as intended.</p> <p>Data-race detection is a technique for identifying these problematic uses of parallelism within a program. Data-race detection acts like a supervisor in the kitchen, making sure that each chef uses their own pans and not someone else's. While data-race detection can identify bugs in parallel programs, it is expensive to do so. Our project seeks to make data-race detection run faster, so that more people will use it to find their software bugs.</p> <p>Our work in this project has followed three main directions. First, we have shown how to make data-race detection faster, without sacrificing precision, for parallel programs running on&nbsp;today's multicore processors. Second, we proposed the first precise and scalable approaches to data-race detection for programs that run on graphics cards (also called GPUs). GPU programs espouse parallelism on a massive scale, often performing millions of computations in parallel, thus increasing the scope for parallelism bugs. Techniques that work for CPU programs struggle to cope with the scale of GPU&nbsp;parallelism, which led us to invent new approaches. Finally, we also evaluated the use of custom processors with hardware support for data-race detection, to make data-race detection much faster than pure-software approaches. With published papers in each of these areas, we have advanced the state-of-the-art in data-race detection and made it easier to find and fix bugs in parallel programs.</p><br> <p>            Last Modified: 11/30/2018<br>      Modified by: Joseph&nbsp;Devietti</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Humans often struggle with juggling multiple tasks at one time. Software developers are no exception, though they are frequently asked to write programs that perform multiple tasks at once so as to take advantage of today's ubiquitous multicore computer processors. We refer to a computer program that does multiple computations at the same time as a parallel computer program. Errors can arise from incorrectly managing the parallelism within a program, similar to having two chefs trying to use a single pan at the same time -- neither of their dishes are going to come out as intended.  Data-race detection is a technique for identifying these problematic uses of parallelism within a program. Data-race detection acts like a supervisor in the kitchen, making sure that each chef uses their own pans and not someone else's. While data-race detection can identify bugs in parallel programs, it is expensive to do so. Our project seeks to make data-race detection run faster, so that more people will use it to find their software bugs.  Our work in this project has followed three main directions. First, we have shown how to make data-race detection faster, without sacrificing precision, for parallel programs running on today's multicore processors. Second, we proposed the first precise and scalable approaches to data-race detection for programs that run on graphics cards (also called GPUs). GPU programs espouse parallelism on a massive scale, often performing millions of computations in parallel, thus increasing the scope for parallelism bugs. Techniques that work for CPU programs struggle to cope with the scale of GPU parallelism, which led us to invent new approaches. Finally, we also evaluated the use of custom processors with hardware support for data-race detection, to make data-race detection much faster than pure-software approaches. With published papers in each of these areas, we have advanced the state-of-the-art in data-race detection and made it easier to find and fix bugs in parallel programs.       Last Modified: 11/30/2018       Submitted by: Joseph Devietti]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
