<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>XPS: DSD: Adaptive Stream-Processing Compilers for a Messy World</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/15/2013</AwardEffectiveDate>
<AwardExpirationDate>08/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>745594.00</AwardTotalIntnAmount>
<AwardAmount>745594</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Stream processing is an increasingly important application domain; a significant portion of the data-deluge beleaguering society takes the form of real-time data, ranging from scientific data to tweets.  Fortunately, in the last decade, a variety of stream-processing languages have sprung up, including WaveScope, StreamIt, Feldspar, and others.  While these languages enable stream-processing programs (which take the form of flow-graphs of stream operators) to execute automatically and efficiently on multicores and small clusters of machines, they optimize assuming an unchanging streaming workload and cannot handle dynamic conditions found in many realistic streaming situations, such as inside modern networks.&lt;br/&gt;&lt;br/&gt;This proposal pursues a more adaptive approach: fast, incremental compilation and recompilation of subgraphs of a stream-processing flow-graph to support dynamic placement and optimization policies while retaining high performance.  The goal is to allow streaming applications to start instantly and in parallel, or restart if the program changes, while adapting to predictable features of the environment over time including streams of constant rate.  Existing just-in-time (JIT) compilers for languages such as JavaScript are a mature technology, but a new body of techniques are needed to apply the more radical optimizations of stream compilers in a dynamic context.  This project aims to develop these techniques and evaluate them in a specific application domain: high-speed in-network processing.</AbstractNarration>
<MinAmdLetterDate>09/12/2013</MinAmdLetterDate>
<MaxAmdLetterDate>09/12/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1337242</AwardID>
<Investigator>
<FirstName>Douglas</FirstName>
<LastName>Swany</LastName>
<PI_MID_INIT>M</PI_MID_INIT>
<PI_SUFX_NAME>Dr.</PI_SUFX_NAME>
<PI_FULL_NAME>Douglas M Swany</PI_FULL_NAME>
<EmailAddress>swany@iu.edu</EmailAddress>
<PI_PHON>8128567795</PI_PHON>
<NSF_ID>000347755</NSF_ID>
<StartDate>09/12/2013</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Ryan</FirstName>
<LastName>Newton</LastName>
<PI_MID_INIT>R</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ryan R Newton</PI_FULL_NAME>
<EmailAddress>rrnewton@purdue.edu</EmailAddress>
<PI_PHON>8122696190</PI_PHON>
<NSF_ID>000596232</NSF_ID>
<StartDate>09/12/2013</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Indiana University</Name>
<CityName>Bloomington</CityName>
<ZipCode>474013654</ZipCode>
<PhoneNumber>3172783473</PhoneNumber>
<StreetAddress>509 E 3RD ST</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN09</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>006046700</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF INDIANA UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>006046700</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Indiana University]]></Name>
<CityName>Bloomington</CityName>
<StateCode>IN</StateCode>
<ZipCode>474057104</ZipCode>
<StreetAddress><![CDATA[150 S. Woodlawn, Lindley 230]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN09</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8283</Code>
<Text>Exploiting Parallel&amp;Scalabilty</Text>
</ProgramElement>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2013~745594</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>&nbsp; &nbsp;This project developed a new body of techniques relevant to implementing high-performance stream-processing systems.&nbsp; Stream-processing systems benefit from optimazitions that involve radical transformations of program logic: for example, fusing adjacent processing steps (operators in a flow-graph).&nbsp; Such program transformations work best if informed by measurements of realistic workloads, i.e. profiling information.&nbsp; In streaming, the needs for profile-driven compilation differ, however, from compilers for traditional applications.&nbsp; It is not sufficient to use techniques that sample the program position based on a timer (gprof, perf, etc).<br />&nbsp; &nbsp;Rather, in the streaming domain, instrumentation-based profiling is necessary: modifying the program at runtime to record statistics on its own behavior.&nbsp; Using instrumentation, it becomes possible to (1) measure the exact time to process an element of an input stream in a particular stage, and (2) precisely measure the quantity of data that flows between consecutive stages.&nbsp; These measurements characterize the flow-graph and drive subsequent optimizations.<br />&nbsp; &nbsp;The challenge was that existing technology for runtime modification of programs on contemporary processors was sharply limited.&nbsp; These technologies inject "probes" into existing programs (function calls not originally present in the binary), but we sought the ability to both rapidly toggle probes on and off, and for probes themselves to be inexpensive to execute.&nbsp; Unfortunately, previous techniques involved either expensive operating-system involvement on every probe invocation, or they required pausing all application threads (e.g. 64 threads on a 64-core processor), in order to toggle even a single probe on or off.<br />&nbsp; &nbsp;Thus, over the course of this project, we developed a new technique for runtime modification of binary programs running on x86_64 processors (presented in PLDI'16 and PLDI'17).&nbsp; Our approach was the first to allow rapid toggling of probes in a multithreaded application, without involving the operating system (OS) or pausing the application threads that are not being probed.&nbsp; We introduced the novel technique of "instruction punning", where we avoid modifying an entire instruction (which may cross a cache-line boundary), and instead only modify the front part of the instruction to a "jump" while reinterpreting the preexisting back part of the instruction as part of the jump target address.<br />&nbsp; &nbsp;Using our rapid-toggling probes, it becomes possible to build a profiling infrastructure that is "always on" (i.e. in production, not just for in the software development phase), and which adaptively limits its own overhead.&nbsp; The adaptive approach works simply by turning off probes after a certain number of invocations, to bound that amount of overhead incurred by a particular probe.&nbsp; This always-on, adaptive profiling is especially well suited to long-running stream-processing applications, which may need to recompile, and reoptimize themselves to best take advantage of changing workloads.</p> <div></div> <p>&nbsp;</p><br> <p>            Last Modified: 05/01/2018<br>      Modified by: Ryan&nbsp;R&nbsp;Newton</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[    This project developed a new body of techniques relevant to implementing high-performance stream-processing systems.  Stream-processing systems benefit from optimazitions that involve radical transformations of program logic: for example, fusing adjacent processing steps (operators in a flow-graph).  Such program transformations work best if informed by measurements of realistic workloads, i.e. profiling information.  In streaming, the needs for profile-driven compilation differ, however, from compilers for traditional applications.  It is not sufficient to use techniques that sample the program position based on a timer (gprof, perf, etc).    Rather, in the streaming domain, instrumentation-based profiling is necessary: modifying the program at runtime to record statistics on its own behavior.  Using instrumentation, it becomes possible to (1) measure the exact time to process an element of an input stream in a particular stage, and (2) precisely measure the quantity of data that flows between consecutive stages.  These measurements characterize the flow-graph and drive subsequent optimizations.    The challenge was that existing technology for runtime modification of programs on contemporary processors was sharply limited.  These technologies inject "probes" into existing programs (function calls not originally present in the binary), but we sought the ability to both rapidly toggle probes on and off, and for probes themselves to be inexpensive to execute.  Unfortunately, previous techniques involved either expensive operating-system involvement on every probe invocation, or they required pausing all application threads (e.g. 64 threads on a 64-core processor), in order to toggle even a single probe on or off.    Thus, over the course of this project, we developed a new technique for runtime modification of binary programs running on x86_64 processors (presented in PLDI'16 and PLDI'17).  Our approach was the first to allow rapid toggling of probes in a multithreaded application, without involving the operating system (OS) or pausing the application threads that are not being probed.  We introduced the novel technique of "instruction punning", where we avoid modifying an entire instruction (which may cross a cache-line boundary), and instead only modify the front part of the instruction to a "jump" while reinterpreting the preexisting back part of the instruction as part of the jump target address.    Using our rapid-toggling probes, it becomes possible to build a profiling infrastructure that is "always on" (i.e. in production, not just for in the software development phase), and which adaptively limits its own overhead.  The adaptive approach works simply by turning off probes after a certain number of invocations, to bound that amount of overhead incurred by a particular probe.  This always-on, adaptive profiling is especially well suited to long-running stream-processing applications, which may need to recompile, and reoptimize themselves to best take advantage of changing workloads.           Last Modified: 05/01/2018       Submitted by: Ryan R Newton]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
