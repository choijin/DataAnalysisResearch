<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: How Much Execution Time, Energy, And Power Does an Algorithm Need?</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/15/2014</AwardEffectiveDate>
<AwardExpirationDate>05/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>515375.00</AwardTotalIntnAmount>
<AwardAmount>515375</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Power efficiency has emerged as the overarching design constraint for modern hybrid-core computing architectures. This research advances new models of the physical time, energy, and power needed to execute an algorithm. Such models aim to address several contemporary research questions in high-performance computing (HPC). For instance, if there is a limited amount of power available to a computer system, how should that power be allocated among various system components to most quickly or most energy-efficiently execute a given computation? Or, does anything need to change in the design of algorithms, given a user's or a system's explicit power or energy constraints?&lt;br/&gt;&lt;br/&gt;The technical approach extends a preliminary model, referred to as the energy roofline, which the Principal Investigator (PI) and his team have developed as part of a prior project. This approach starts from first principles of algorithmic analysis that express the intrinsic concurrency and communication properties of an algorithm; and from that, it derives models of time, energy, and power using cost models informed directly by the behavior of real algorithms, software, and systems. The project considers several critical enhancements of the preliminary work, which is leading to a family of models of increasing accuracy and complexity. The research will have a broad impact on a wide range of important design issues in exascale systems.</AbstractNarration>
<MinAmdLetterDate>06/18/2014</MinAmdLetterDate>
<MaxAmdLetterDate>06/27/2018</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1422935</AwardID>
<Investigator>
<FirstName>Richard</FirstName>
<LastName>Vuduc</LastName>
<PI_MID_INIT>W</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Richard W Vuduc</PI_FULL_NAME>
<EmailAddress>richie@cc.gatech.edu</EmailAddress>
<PI_PHON>5103017014</PI_PHON>
<NSF_ID>000080331</NSF_ID>
<StartDate>06/18/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Georgia Tech Research Corporation</Name>
<CityName>Atlanta</CityName>
<ZipCode>303320420</ZipCode>
<PhoneNumber>4048944819</PhoneNumber>
<StreetAddress>Office of Sponsored Programs</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Georgia</StateName>
<StateCode>GA</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>GA05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>097394084</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>GEORGIA TECH RESEARCH CORPORATION</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>097394084</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Georgia Institute of Technology]]></Name>
<CityName>Atlanta</CityName>
<StateCode>GA</StateCode>
<ZipCode>303320002</ZipCode>
<StreetAddress><![CDATA[225 North Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Georgia</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>GA05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~515375</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Power efficiency is the overarching design constraint for modern computer systems. The primary research goal of this project has been to advance new models of the physical time, energy, and power needed to execute an algorithm. The intellectual merit of this goal has been to create a foundation for answering several contemporary research questions in the design and efficient use of high-performance computing (HPC) systems or "supercomputers." For instance, if there is a limited amount of power available to a computer system, how should that power be allocated among various system components to most quickly or most energy-efficiently execute a given computation? Or, does anything need to change in the design of algorithms, given a user's or a system's explicit power or energy constraints?</p> <p>In its most significant demonstration, the project considered the problem of computing shortest paths in a graph (or "network"), which is any object of entities (vertices) linked to one another (via edges). For a state-of-the-art algorithm for this problem, there is a tuning parameter that affects the speed of the algorithm. However, the "meaning" of the parameter is not easily to interpret, and consequently, it had not been previously known precisely how to set the parameter to find the best setting other than by trial-and-error. In particular, the best setting depends on the specific input graph, and appeared hard to predict ahead of time.</p> <p>Researchers in this project showed one could do much better. First, they showed that the effect of this parameter?='s value on performance could be estimated (or "learned") and predicted as the algorithm runs. Secondly, they used this observation to develop a technique to control the parameter's value automatically. Thirdly, they showed that the parameter?s setting affected not just running time but also how much power (e.g., Watts) the computer system would consume as it ran. From this fact, they were able to change the problem of how to set the parameter: instead of selecting its value, one could impose a constraint on the system of the form, while running, do not use more than a certain amount of power. The automatic controller can use this constraint, which is much easier to interpret than the tuning parameter itself, to then adjust the parameter as the computation runs.</p> <p>The significance of this finding is that it illuminates a process for translating how to set algorithm-level tuning parameters in a controlled and systematic way, and suggests several avenues to apply this idea in many other applications where a tradeoff, such as performance and power, exists. Subsequent work in the project lays out more general mechanisms for doing so, which the team hopes to pursue in future follow-on projects.</p> <p>Beyond these technical innovations, the broader impacts of the project include what we believe to be the first use of energy and power as explicit metrics of consideration in algorithm design. This material is part of an online masters-level course on high-performance computing, developed as part of the Online MS in Computer Science program at Georgia Tech. (Videos only are freely available at Udacity.com and on YouTube.)</p><br> <p>            Last Modified: 05/30/2020<br>      Modified by: Richard&nbsp;W&nbsp;Vuduc</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Images (<span id="selectedPhoto0">1</span> of <span class="totalNumber"></span>)           </div> <div class="galControls" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2020/1422935/1422935_10311372_1590849652519_fig0--rgov-214x142.jpg" original="/por/images/Reports/POR/2020/1422935/1422935_10311372_1590849652519_fig0--rgov-800width.jpg" title="Sample experimental results"><img src="/por/images/Reports/POR/2020/1422935/1422935_10311372_1590849652519_fig0--rgov-66x44.jpg" alt="Sample experimental results"></a> <div class="imageCaptionContainer"> <div class="imageCaption">Speedup (decrease in running time) vs. "power-up" (increase in power) for our power-tunable single-source shortest paths (SSSP) algorithm when running on a mobile GPU. Our method of "self-tuning" (solid lines) can both save time and reduce power, yielding an overall decrease in energy consumption.</div> <div class="imageCredit">Karamati et al. (IPDPS'18)</div> <div class="imagePermisssions">Public Domain</div> <div class="imageSubmitted">Richard&nbsp;W&nbsp;Vuduc</div> <div class="imageTitle">Sample experimental results</div> </div> </li> <li> <a href="/por/images/Reports/POR/2020/1422935/1422935_10311372_1590849965605_fig1--rgov-214x142.jpg" original="/por/images/Reports/POR/2020/1422935/1422935_10311372_1590849965605_fig1--rgov-800width.jpg" title="CSE 6220-OMS: Intro to HPC - Lesson 3"><img src="/por/images/Reports/POR/2020/1422935/1422935_10311372_1590849965605_fig1--rgov-66x44.jpg" alt="CSE 6220-OMS: Intro to HPC - Lesson 3"></a> <div class="imageCaptionContainer"> <div class="imageCaption">Broader impacts: Lessons learned in this project led to the inclusion of power and energy as explicit algorithm-design metrics in a freely available, online masters-level course on high-performance computing, part of Georgia Tech's Online MS in Computer Science program.</div> <div class="imageCredit">Rich Vuduc (PI) / Georgia Tech / Udacity</div> <div class="imagePermisssions">Copyrighted</div> <div class="imageSubmitted">Richard&nbsp;W&nbsp;Vuduc</div> <div class="imageTitle">CSE 6220-OMS: Intro to HPC - Lesson 3</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Power efficiency is the overarching design constraint for modern computer systems. The primary research goal of this project has been to advance new models of the physical time, energy, and power needed to execute an algorithm. The intellectual merit of this goal has been to create a foundation for answering several contemporary research questions in the design and efficient use of high-performance computing (HPC) systems or "supercomputers." For instance, if there is a limited amount of power available to a computer system, how should that power be allocated among various system components to most quickly or most energy-efficiently execute a given computation? Or, does anything need to change in the design of algorithms, given a user's or a system's explicit power or energy constraints?  In its most significant demonstration, the project considered the problem of computing shortest paths in a graph (or "network"), which is any object of entities (vertices) linked to one another (via edges). For a state-of-the-art algorithm for this problem, there is a tuning parameter that affects the speed of the algorithm. However, the "meaning" of the parameter is not easily to interpret, and consequently, it had not been previously known precisely how to set the parameter to find the best setting other than by trial-and-error. In particular, the best setting depends on the specific input graph, and appeared hard to predict ahead of time.  Researchers in this project showed one could do much better. First, they showed that the effect of this parameter?='s value on performance could be estimated (or "learned") and predicted as the algorithm runs. Secondly, they used this observation to develop a technique to control the parameter's value automatically. Thirdly, they showed that the parameter?s setting affected not just running time but also how much power (e.g., Watts) the computer system would consume as it ran. From this fact, they were able to change the problem of how to set the parameter: instead of selecting its value, one could impose a constraint on the system of the form, while running, do not use more than a certain amount of power. The automatic controller can use this constraint, which is much easier to interpret than the tuning parameter itself, to then adjust the parameter as the computation runs.  The significance of this finding is that it illuminates a process for translating how to set algorithm-level tuning parameters in a controlled and systematic way, and suggests several avenues to apply this idea in many other applications where a tradeoff, such as performance and power, exists. Subsequent work in the project lays out more general mechanisms for doing so, which the team hopes to pursue in future follow-on projects.  Beyond these technical innovations, the broader impacts of the project include what we believe to be the first use of energy and power as explicit metrics of consideration in algorithm design. This material is part of an online masters-level course on high-performance computing, developed as part of the Online MS in Computer Science program at Georgia Tech. (Videos only are freely available at Udacity.com and on YouTube.)       Last Modified: 05/30/2020       Submitted by: Richard W Vuduc]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
