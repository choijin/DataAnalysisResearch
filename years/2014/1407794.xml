<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Medium: Collaborative Research: Principled Optimizing Compilation of Dependently Typed Languages</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2014</AwardEffectiveDate>
<AwardExpirationDate>06/30/2018</AwardExpirationDate>
<AwardTotalIntnAmount>600000.00</AwardTotalIntnAmount>
<AwardAmount>600000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Title: SHF: Medium: Collaborative Research: Principled Optimizing Compilation of Dependently Typed Languages&lt;br/&gt;&lt;br/&gt;The project focuses on a form of software engineering with program verification: writing programs with logical, machine-checkable proofs of correctness, reliability, or security.  Such proofs can be done for programs written in conventional programming languages, but the "proof theory" of these languages is complex and difficult, which makes verification time-consuming and expensive.  New, "dependently typed" programming languages use principles of functional programming and advanced type systems to achieve a smoother and cleaner proof theory, so that verifying the correctness and safety of software (written in these new languages) is much easier.  In this project, the research is to build compilers for these new languages that are efficient and are verified correct.&lt;br/&gt;&lt;br/&gt;The intellectual merits are in the challenges and opportunities that occur in dependently typed, purely functional contexts, such as the Coq proof assistant.  The exciting opportunities that arise only in this context are the ability to choose evaluation order for any sub-term (since Coq's language is pure and total), the ability to open a compiler to user-specified (and certified) rewrite rules that support application-specific optimization, and the ability of programmers to use the Calculus of Inductive Constructions (CiC) proof theory of Coq to verify their programs.  The challenges we face, unique to this setting, include the need to determine and erase those terms that are computationally irrelevant.  A major foundational challenge is attempting to preserve types (and hence proofs) as we perform lowering transformations, such as conversion to continuation-passing style (CPS) or static single assignment (SSA).  Our strategy is to use type and proof-preserving compilation where possible, and where not, to prove a simulation-based notion of correctness.  The broader impacts will include (1) pedagogical materials on verified functional programming in Coq; (2) training of graduate students; and (3) improvements in software engineering practice, in enabling practical verified functional programming.</AbstractNarration>
<MinAmdLetterDate>06/17/2014</MinAmdLetterDate>
<MaxAmdLetterDate>06/17/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1407794</AwardID>
<Investigator>
<FirstName>Andrew</FirstName>
<LastName>Appel</LastName>
<PI_MID_INIT>W</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Andrew W Appel</PI_FULL_NAME>
<EmailAddress>appel@cs.princeton.edu</EmailAddress>
<PI_PHON>6092584627</PI_PHON>
<NSF_ID>000303062</NSF_ID>
<StartDate>06/17/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Princeton University</Name>
<CityName>Princeton</CityName>
<ZipCode>085442020</ZipCode>
<PhoneNumber>6092583090</PhoneNumber>
<StreetAddress>Off. of Research &amp; Proj. Admin.</StreetAddress>
<StreetAddress2><![CDATA[P.O. Box 36]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ12</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>002484665</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF PRINCETON UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>002484665</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Princeton University]]></Name>
<CityName>Princeton</CityName>
<StateCode>NJ</StateCode>
<ZipCode>085442020</ZipCode>
<StreetAddress><![CDATA[87 Prospect Street]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ12</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>6892</Code>
<Text>CI REUSE</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7433</Code>
<Text>CyberInfra Frmwrk 21st (CIF21)</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~600000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>One good way to build secure and correct software is to prove it correct using machine-checked deductive logic, then compile it to executable machine code with a compiler that&rsquo;s also proved correct.&nbsp; That way, the program is guaranteed to do what it&rsquo;s supposed to do, and <em>only</em> what it&rsquo;s supposed to do; and there&rsquo;s no way that bugs in the compiler toolchain can introduce insecurity.&nbsp; One of the best ways to write proved-correct programs is in the functional programming language inside a <em>proof assistant</em> (a proof-building/proof-checking tool).&nbsp; Such technology has already been developed; researchers and engineers have already experimented with building correct programs, proving them correct using the proof assistant, and use an <em>extraction/compilation </em>toolchain to produce runnable software.&nbsp; But the state of the art did not include any proved-correct extractor/compilers, so there was always the possibility that bugs in the toolchain (or misunderstandings of its interface) could lead to insecurities.</p> <p>In this project we built &ldquo;CertiCoq,&rdquo; a proved-correct, high-performance extractor/compiler for the Coq proof assistant.&nbsp;&nbsp; CertiCoq takes the functional program in Coq and translates it, via the C programming language, into machine code.&nbsp; CertiCoq is itself a functional program that is proved correct in Coq (except for 2 of its 11 phases whose proofs are still underway).&nbsp;</p> <p><strong>Intellectual merit:</strong> In the course of our research we obtained new results in certified compilation that generalize beyond our particular compiler:</p> <ul> <li>Principled reification of Coq terms that allow preservation of types and semantics;</li> <li>The first correctness verification of the high-performance &ldquo;shrink-reduction&rdquo; algorithm used in several functional-language compilers;</li> <li>The first formalization of &ldquo;safe-for-space&rdquo; closure conversion (guaranteeing that the compiler does not inadvertently increase the memory usage of the program), as part of a functional-correctness verification of the closure converter;</li> <li>A general and precise specification of <em>compiler</em> <em>correctness</em> that is succinct (not mentioning internal details of the compiler), composes vertically (through the phases of the compilation pipeline), composes horizontally (to allow linking of modules), and allows the compiler to choose representations for computationally indistinguishable data;</li> <li>A proved-correct high-performance generational garbage collector, which enables a clean foreign-function interface to the C language.</li> </ul> <ul> </ul> <p><strong>Broader impacts:&nbsp; </strong>Machine-checked program verification is an increasingly important way to ensure the security of our worldwide computing infrastructure, and we expect CertiCoq will become an important part of an engineering verification toolbox.&nbsp; Beyond CertiCoq itself, the methods and scientific principles that we published will be useful in developing other such tools.&nbsp; In addition, this project trained several PhD students to work in formal verification.</p> <p>&nbsp;</p><br> <p>            Last Modified: 08/22/2018<br>      Modified by: Andrew&nbsp;W&nbsp;Appel</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ One good way to build secure and correct software is to prove it correct using machine-checked deductive logic, then compile it to executable machine code with a compiler that?s also proved correct.  That way, the program is guaranteed to do what it?s supposed to do, and only what it?s supposed to do; and there?s no way that bugs in the compiler toolchain can introduce insecurity.  One of the best ways to write proved-correct programs is in the functional programming language inside a proof assistant (a proof-building/proof-checking tool).  Such technology has already been developed; researchers and engineers have already experimented with building correct programs, proving them correct using the proof assistant, and use an extraction/compilation toolchain to produce runnable software.  But the state of the art did not include any proved-correct extractor/compilers, so there was always the possibility that bugs in the toolchain (or misunderstandings of its interface) could lead to insecurities.  In this project we built "CertiCoq," a proved-correct, high-performance extractor/compiler for the Coq proof assistant.   CertiCoq takes the functional program in Coq and translates it, via the C programming language, into machine code.  CertiCoq is itself a functional program that is proved correct in Coq (except for 2 of its 11 phases whose proofs are still underway).   Intellectual merit: In the course of our research we obtained new results in certified compilation that generalize beyond our particular compiler:  Principled reification of Coq terms that allow preservation of types and semantics; The first correctness verification of the high-performance "shrink-reduction" algorithm used in several functional-language compilers; The first formalization of "safe-for-space" closure conversion (guaranteeing that the compiler does not inadvertently increase the memory usage of the program), as part of a functional-correctness verification of the closure converter; A general and precise specification of compiler correctness that is succinct (not mentioning internal details of the compiler), composes vertically (through the phases of the compilation pipeline), composes horizontally (to allow linking of modules), and allows the compiler to choose representations for computationally indistinguishable data; A proved-correct high-performance generational garbage collector, which enables a clean foreign-function interface to the C language.     Broader impacts:  Machine-checked program verification is an increasingly important way to ensure the security of our worldwide computing infrastructure, and we expect CertiCoq will become an important part of an engineering verification toolbox.  Beyond CertiCoq itself, the methods and scientific principles that we published will be useful in developing other such tools.  In addition, this project trained several PhD students to work in formal verification.          Last Modified: 08/22/2018       Submitted by: Andrew W Appel]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
