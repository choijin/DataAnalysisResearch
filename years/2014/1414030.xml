<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Large: Collaborative Research: Exploiting the Naturalness of Software</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2014</AwardEffectiveDate>
<AwardExpirationDate>06/30/2018</AwardExpirationDate>
<AwardTotalIntnAmount>666667.00</AwardTotalIntnAmount>
<AwardAmount>666667</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This inter-disciplinary project has its roots in Natural Language (NL) processing. Languages such as English allow intricate, lovely and complex constructions; yet, everyday, ``natural? speech and writing is simple, prosaic, and repetitive, and thus amenable to statistical modeling. Once large NL corpora became available, computational muscle and algorithmic insight led to rapid advances in the statistical modeling of natural utterances, and revolutionized tasks such as translation, speech recognition, text summarization, etc.  While programming languages, like NL, are flexible and powerful, in theory allowing a great variety of complex programs to be written, we find that ``natural? programs that people actually write are regular, repetitive and predictable. This project will use statistical models to capture and exploit this regularity to create a new generation of software engineering tools to achieve transformative improvements in software quality and productivity. &lt;br/&gt; &lt;br/&gt;The project will exploit language modeling techniques to capture the regularity in natural programs at the lexical, syntactic, and semantic levels. Statistical modeling will also be used to capture alignment regularities in ``bilingual? corpora such as code with comments, or explanatory text (e.g., Stackoverflow) and in systems developed on two platforms such as Java and C#.  These statistical models will help drive novel, data-driven approaches for applications such as code suggestion and completion, and assistive devices for programmers with movement or visual challenges. These models will also be exploited to correct simple errors in programs. Models of bilingual data will used to build code summarization and code retrieval tools, as well as tools for porting across platforms. Finally, this project will create a large, curated corpus of  software, and code analysis products, as well as a corpus of alignments within software bilingual corpora, to help create and nurture a research community in this area.</AbstractNarration>
<MinAmdLetterDate>06/06/2014</MinAmdLetterDate>
<MaxAmdLetterDate>09/16/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1414030</AwardID>
<Investigator>
<FirstName>William</FirstName>
<LastName>Cohen</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>William Cohen</PI_FULL_NAME>
<EmailAddress>wcohen@cs.cmu.edu</EmailAddress>
<PI_PHON>4122687664</PI_PHON>
<NSF_ID>000148698</NSF_ID>
<StartDate>06/06/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Carnegie-Mellon University</Name>
<CityName>PITTSBURGH</CityName>
<ZipCode>152133815</ZipCode>
<PhoneNumber>4122688746</PhoneNumber>
<StreetAddress>5000 Forbes Avenue</StreetAddress>
<StreetAddress2><![CDATA[WQED Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052184116</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CARNEGIE MELLON UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052184116</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Carnegie-Mellon University]]></Name>
<CityName>Pittsburgh</CityName>
<StateCode>PA</StateCode>
<ZipCode>152133815</ZipCode>
<StreetAddress><![CDATA[5000 Forbes Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1640</Code>
<Text>Information Technology Researc</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7925</Code>
<Text>LARGE PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~489653</FUND_OBLG>
<FUND_OBLG>2016~177014</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>What does it mean for a computer to "understand" a technical domain,such as software? To test understanding for a person, one wouldprobably try and measure performance on a number of different tasks.</p> <p>One test of knowledge would be to explain how entities from the domainare related.&nbsp; For example, a "button", a "link", and an "option" are all similar in that they are names of GUI elements.&nbsp; We looked at ways to infer relationships between software entities from text aboutsoftware.&nbsp; Specifically, we collected data from the Q&amp;A websiteStackOverflow, and used NLP methods and statistical machine-learningmethods to find a set of relationships that were frequentllymentioned, and internally consistent. The quality of the top-scoringrelationship was good (as much as 90% for certain measures) whenevaluated by domain experts.</p> <p>As another test, one might ask a person read some computer code and explain in English what it does--i.e., to produce meaningful comments for the code.&nbsp; We built a system could produce English comments on a new program that it was presented with.&nbsp; This system was developedu sing machine learning methods: it was trained on actual comments, written by programmers to explain code that they had written.&nbsp; The learning method we used works by reading the program into a neural memory ("encoding" it), then producing the comment one word at a time, updating the neural memory after each word is produced ("decoding").The best-performing model for comment generation was a novel learning system we called "encoder-reviewer-decoder", which allows some additional neural processing to be performed after the source code isloaded, but before the first word of the comments are produced.&nbsp; The encoder-reviewer-decoder model is intended to model a person's mentalprocess of thinking about the program after reading it, but before explaining it.&nbsp; Although this model cannot produce good-enough program comments on its own, it is accurate enough to help a programmersubstantially, filling in enough of a comment automatically to reduce typing by over a third.</p> <p>Another common way to test understanding for people would be to ask them to answer question about terms from the domain.&nbsp; We looked at answering "fill-in-the-blank" or "cloze" questions, such as</p> <p><br />&nbsp; <em>Django is a free and open-source web framework, written in ____,&nbsp; which follows the model-view-template (MVT) architectural pattern.</em></p> <p><br />(The correct answer here is "Python").&nbsp; From StackOverflow, a web site with questions and answers about computer programming, we extracted thousands of definitions, and constructed over 35,000 cloze questions. These questions are very hard: two experienced, senior programmers answered only 46.8% correctly, on average.</p> <p>We explored a number of approaches to answering these questions automatically.&nbsp; The first approach modeled what a human might do.&nbsp; The system first searches for documents that might contain the answer,then "reads" the documents returned by the search, and finally produces the answer.&nbsp; To "read" the documents use existing methods called reading comprehension (RC) systems.&nbsp; These methods performed reasonably well, with the best existing question-answering methods reaching accuracy of 32.1%.&nbsp; However, further experiments showed than one could do about as well (accuracy of 33.6%) using another approach called a "neural language model" (LM), which simply guesses a plausible word to fill in the blank using general statistics about English sentences in the software domain.</p> <p>Motivated by this, we explored a new approach to answering cloze questions about software. The insight we had was that often, related software entities (e.g., "Django" and "Python") were used together as tags for StackOverFlow posts. (Every posted question can be tagged by the user with a set of software entities, to make it easier for possible question-answerers to find relevant questions.)&nbsp; Often entities that are semantically related are used together as tags ofthe same post.&nbsp; We thus designed a new method specifically designed for answering Cloze (fill-in-the-blank) questions using this sort of text with tagged entities.</p> <p>Our method is called CASE (Context-Adjusted Syntax Embeddings).&nbsp; It's a&nbsp; hybrid of an neural LM and a co-occurrence model, which predicts an answer based on co-occurrence with the entity.&nbsp; This allows a useful "division of labor" between the two models.&nbsp; The LM can predict the appropriate &ldquo;type&rdquo; of the answer entity based on the question syntax (in the example, a programming language is needed), while the co-occurrence model picks out the entity of that "type" based on co-occurrence with the term defined.&nbsp; CASE far outperforms the other methods: it achieved an accuracy of 44.9%, which is close to the performance of human experts.</p><br> <p>            Last Modified: 07/26/2018<br>      Modified by: William&nbsp;Cohen</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ What does it mean for a computer to "understand" a technical domain,such as software? To test understanding for a person, one wouldprobably try and measure performance on a number of different tasks.  One test of knowledge would be to explain how entities from the domainare related.  For example, a "button", a "link", and an "option" are all similar in that they are names of GUI elements.  We looked at ways to infer relationships between software entities from text aboutsoftware.  Specifically, we collected data from the Q&amp;A websiteStackOverflow, and used NLP methods and statistical machine-learningmethods to find a set of relationships that were frequentllymentioned, and internally consistent. The quality of the top-scoringrelationship was good (as much as 90% for certain measures) whenevaluated by domain experts.  As another test, one might ask a person read some computer code and explain in English what it does--i.e., to produce meaningful comments for the code.  We built a system could produce English comments on a new program that it was presented with.  This system was developedu sing machine learning methods: it was trained on actual comments, written by programmers to explain code that they had written.  The learning method we used works by reading the program into a neural memory ("encoding" it), then producing the comment one word at a time, updating the neural memory after each word is produced ("decoding").The best-performing model for comment generation was a novel learning system we called "encoder-reviewer-decoder", which allows some additional neural processing to be performed after the source code isloaded, but before the first word of the comments are produced.  The encoder-reviewer-decoder model is intended to model a person's mentalprocess of thinking about the program after reading it, but before explaining it.  Although this model cannot produce good-enough program comments on its own, it is accurate enough to help a programmersubstantially, filling in enough of a comment automatically to reduce typing by over a third.  Another common way to test understanding for people would be to ask them to answer question about terms from the domain.  We looked at answering "fill-in-the-blank" or "cloze" questions, such as     Django is a free and open-source web framework, written in ____,  which follows the model-view-template (MVT) architectural pattern.   (The correct answer here is "Python").  From StackOverflow, a web site with questions and answers about computer programming, we extracted thousands of definitions, and constructed over 35,000 cloze questions. These questions are very hard: two experienced, senior programmers answered only 46.8% correctly, on average.  We explored a number of approaches to answering these questions automatically.  The first approach modeled what a human might do.  The system first searches for documents that might contain the answer,then "reads" the documents returned by the search, and finally produces the answer.  To "read" the documents use existing methods called reading comprehension (RC) systems.  These methods performed reasonably well, with the best existing question-answering methods reaching accuracy of 32.1%.  However, further experiments showed than one could do about as well (accuracy of 33.6%) using another approach called a "neural language model" (LM), which simply guesses a plausible word to fill in the blank using general statistics about English sentences in the software domain.  Motivated by this, we explored a new approach to answering cloze questions about software. The insight we had was that often, related software entities (e.g., "Django" and "Python") were used together as tags for StackOverFlow posts. (Every posted question can be tagged by the user with a set of software entities, to make it easier for possible question-answerers to find relevant questions.)  Often entities that are semantically related are used together as tags ofthe same post.  We thus designed a new method specifically designed for answering Cloze (fill-in-the-blank) questions using this sort of text with tagged entities.  Our method is called CASE (Context-Adjusted Syntax Embeddings).  It's a  hybrid of an neural LM and a co-occurrence model, which predicts an answer based on co-occurrence with the entity.  This allows a useful "division of labor" between the two models.  The LM can predict the appropriate "type" of the answer entity based on the question syntax (in the example, a programming language is needed), while the co-occurrence model picks out the entity of that "type" based on co-occurrence with the term defined.  CASE far outperforms the other methods: it achieved an accuracy of 44.9%, which is close to the performance of human experts.       Last Modified: 07/26/2018       Submitted by: William Cohen]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
