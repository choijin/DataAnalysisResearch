<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Medium: Collaborative Research: Micro Virtual Machines for Managed Languages: Abstraction, defined and contained</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/15/2014</AwardEffectiveDate>
<AwardExpirationDate>05/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>557681.00</AwardTotalIntnAmount>
<AwardAmount>683681</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Title: Micro Virtual Machines for Managed Languages: Abstraction, contained&lt;br/&gt;&lt;br/&gt;A large fraction of today's software is written in managed languages. These languages increase software productivity by supporting programming at a very high level, hiding the complexity of modern computer hardware and operating systems. Examples include JavaScript, PHP, Objective-C, Java, C#, Python, and Ruby. These languages have great economic importance. Unfortunately, most of these languages are inefficient, imposing overheads as large as a factor of fifty compared to orthodox language choices such as C. The broader impacts of this research are two-fold: (1) Since managed languages are increasingly becoming economic linchpins, deployed in the engine rooms of global e-commerce platforms and Internet applications (including those of key software companies such as Amazon, Google, Facebook, Apple, Oracle, and Microsoft), improving the reliability and performance of these managed language platforms will lead to economic efficiencies as well as resource efficiencies in the form of reduced power costs to data centers and improved battery lifetime on mobile devices;(2) Concerning human diversity in the computing field, the research will engage undergraduates from under-represented groups, and encourage them to pursue graduate school and careers in computing and research.&lt;br/&gt;&lt;br/&gt;This research project is defining, developing, evaluating, and refining the essential components of a new foundation layer for managed language implementation. In doing so, it addresses a key source of systemic inefficiency, by pioneering the "micro virtual machine" (microVM) as an efficient high-performance substrate for managed language implementation. The relationship between a microVM and existing managed language implementations is analogous to that between an operating system micro kernel and monolithic operating systems such as Linux. The microVM captures the insight that there exists a well-defined foundation common to most modern languages that can take responsibility for fundamental abstractions over hardware, concurrency, and memory. By isolating and exposing this substrate, the microVM embodies state-of-the-art base technology available to language implementers while isolating them from the pernicious complexities of these abstractions, freeing them to focus on all-important language-specific optimizations. The research is enabling more efficient software and a distinctly sharper focus for language implementation research and development. The intellectual merits of the research are: (1) Researching and identifying, via prototyping and evaluation, the right microVM abstractions, allowing clean separation of low-level language-neutral and high-level language-specific concerns, capturing the core behaviors, while also admitting high-performance language implementations; (2) Generating secondary research challenges, especially with regard to the effective and efficient combination of abstractions for hardware, concurrency, and memory; and (3) Creating a viable target for formal verification because the microVM has a relatively small code base, thus taking one step on the way towards trustworthy subsystems for assurance of managed software.</AbstractNarration>
<MinAmdLetterDate>06/09/2014</MinAmdLetterDate>
<MaxAmdLetterDate>03/28/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1409284</AwardID>
<Investigator>
<FirstName>J. Eliot</FirstName>
<LastName>Moss</LastName>
<PI_MID_INIT>B</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>J. Eliot B Moss</PI_FULL_NAME>
<EmailAddress>moss@cs.umass.edu</EmailAddress>
<PI_PHON>4135454206</PI_PHON>
<NSF_ID>000261930</NSF_ID>
<StartDate>06/09/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Timothy</FirstName>
<LastName>Richards</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Timothy Richards</PI_FULL_NAME>
<EmailAddress>richards@cs.umass.edu</EmailAddress>
<PI_PHON>4135455229</PI_PHON>
<NSF_ID>000600567</NSF_ID>
<StartDate>06/09/2014</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Massachusetts Amherst</Name>
<CityName>Hadley</CityName>
<ZipCode>010359450</ZipCode>
<PhoneNumber>4135450698</PhoneNumber>
<StreetAddress>Research Administration Building</StreetAddress>
<StreetAddress2><![CDATA[100 Venture Way, Suite 201]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>153926712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF MASSACHUSETTS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>079520631</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Massachusetts Amherst]]></Name>
<CityName>Amherst</CityName>
<StateCode>MA</StateCode>
<ZipCode>010039264</ZipCode>
<StreetAddress><![CDATA[140 Governor's Dr]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7354</Code>
<Text>COMPUTER SYSTEMS</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0117</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~557681</FUND_OBLG>
<FUND_OBLG>2015~110000</FUND_OBLG>
<FUND_OBLG>2017~16000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Programmers almost never write code directly for a "bare" machine, the "raw" hardware.&nbsp; Rather, they write programs intended to execute in a richer environment, providing a variety of services, such as ability to interact with a user via keyboard, mouse, and screen, to access and store data in files, to communicate over a computer network, etc.&nbsp; The collection of facilities provided in a given setting are termed a&nbsp;<em>virtual machine</em>.&nbsp; Some such machines are designed to make it easier to write a program that will work across a wide variety of computers without reprogramming.&nbsp; An example is the Java virtual machine (Java run-time system).&nbsp; A goal of the project was to contribute toward a virtual machine well suited not only for working across a variety of kinds of computers, but to support well a wide variety of programming languages.&nbsp; This makes it easier to develop new languages that bring new capabilities, while making those languages readily available across many computers - without forcing the language developer to do all the complex low-level work to provide their own language-specific virtual machine.&nbsp; Put another way, previously, language developers would build a virtual machine from scratch for their particular language.&nbsp; This project aimed to build a single virtual machine, independent of any particular language, but well suited to supporting a wide range of languages.</p> <p>This language-independent virtual machine, called Mu, was evaluated by prototyping implementations of diverse languages using Mu.&nbsp; These languages included Haskell, python (the pypy version), Java, and C.&nbsp; The reference ("standard") implementation of Mu was built using Scala, and a performant implementation, which includes support for generating somewhat optimized machine code, was written using the Rust programming language.&nbsp; This produced interesting results in how to implement advanced language support techniques,such as on-stack replacement, using Rust.</p> <p>Overall, the Mu project produced three PhD graduates at the Australian National University and supported two graduates each at the University of Massachusetts Amherst and Purdue University.</p> <p>As the project evolved, we focused more of our efforts toward understanding how we might guarantee the correctness of one of these virtual machines, since all code written in the languages that use a virtual machine must trust the virtual machine to function properly.&nbsp; Part of what makes this difficult is that modern computers have many "cores" all working at once, and often their synchronization with memory is complex and can result in surprising reorderings if not managed carefully.&nbsp; We considered how we might model a wide variety of makes of computers in this regard within one general model, which we could then use to prove things about the correctness of particular programs.&nbsp; We devised a model that can capture ways in which one core may be "ahead" of other cores in terms of its updates to memory, ways in which the core may be "behind", and ways in which the core may execute some of its instructions in an order different from that in the program, according to what a given computer design permits.</p> <p>In the long run this should contribute to our ability to trust critical computer infrastructure.&nbsp; Another broader contribution of the project is its education of students to undertake this and similar work in this generation, and its encouragement of undergraduate students to consider a career in science.</p> <p>&nbsp;</p><br> <p>            Last Modified: 07/30/2020<br>      Modified by: J. Eliot&nbsp;B&nbsp;Moss</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Programmers almost never write code directly for a "bare" machine, the "raw" hardware.  Rather, they write programs intended to execute in a richer environment, providing a variety of services, such as ability to interact with a user via keyboard, mouse, and screen, to access and store data in files, to communicate over a computer network, etc.  The collection of facilities provided in a given setting are termed a virtual machine.  Some such machines are designed to make it easier to write a program that will work across a wide variety of computers without reprogramming.  An example is the Java virtual machine (Java run-time system).  A goal of the project was to contribute toward a virtual machine well suited not only for working across a variety of kinds of computers, but to support well a wide variety of programming languages.  This makes it easier to develop new languages that bring new capabilities, while making those languages readily available across many computers - without forcing the language developer to do all the complex low-level work to provide their own language-specific virtual machine.  Put another way, previously, language developers would build a virtual machine from scratch for their particular language.  This project aimed to build a single virtual machine, independent of any particular language, but well suited to supporting a wide range of languages.  This language-independent virtual machine, called Mu, was evaluated by prototyping implementations of diverse languages using Mu.  These languages included Haskell, python (the pypy version), Java, and C.  The reference ("standard") implementation of Mu was built using Scala, and a performant implementation, which includes support for generating somewhat optimized machine code, was written using the Rust programming language.  This produced interesting results in how to implement advanced language support techniques,such as on-stack replacement, using Rust.  Overall, the Mu project produced three PhD graduates at the Australian National University and supported two graduates each at the University of Massachusetts Amherst and Purdue University.  As the project evolved, we focused more of our efforts toward understanding how we might guarantee the correctness of one of these virtual machines, since all code written in the languages that use a virtual machine must trust the virtual machine to function properly.  Part of what makes this difficult is that modern computers have many "cores" all working at once, and often their synchronization with memory is complex and can result in surprising reorderings if not managed carefully.  We considered how we might model a wide variety of makes of computers in this regard within one general model, which we could then use to prove things about the correctness of particular programs.  We devised a model that can capture ways in which one core may be "ahead" of other cores in terms of its updates to memory, ways in which the core may be "behind", and ways in which the core may execute some of its instructions in an order different from that in the program, according to what a given computer design permits.  In the long run this should contribute to our ability to trust critical computer infrastructure.  Another broader contribution of the project is its education of students to undertake this and similar work in this generation, and its encouragement of undergraduate students to consider a career in science.          Last Modified: 07/30/2020       Submitted by: J. Eliot B Moss]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
