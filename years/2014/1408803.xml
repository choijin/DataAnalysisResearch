<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Medium: Collaborative: Retrofitting Software for Defense-in-Depth</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2014</AwardEffectiveDate>
<AwardExpirationDate>08/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>300000.00</AwardTotalIntnAmount>
<AwardAmount>300000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The computer security community has long advocated the concept of building multiple layers of defense to protect a system.  Unfortunately, it has been difficult to realize this vision in the practice of software development, and software often ships with inadequate defenses, typically developed in an ad hoc fashion.&lt;br/&gt;&lt;br/&gt;Developers face a number of challenges when protecting a software system with multiple layers of defense. They lack holistic frameworks in which to express policies and mechanisms for different software layers, automated tools to add these defenses, and tools to prove that software enhanced with defenses has an advertised level of assurance.&lt;br/&gt;&lt;br/&gt;This project develops new techniques to retrofit software for defense in depth. It takes a comprehensive view of the problem, with an emphasis on automated, interactive tools that developers can use to identify site-level security goals, explore the design space of adding security mechanisms, and retrofit legacy code to enforce security policies in a manner that can be machine-verified for assurance. The project develops theory and tools for formal policy language design and validation, static and dynamic code analyses, interactive tools for developers to explore the design space of security, functionality and performance tradeoffs, and methods to formally verify the correctness of program transformations to introduce defenses such as authorization, attacker containment, and auditing mechanisms.&lt;br/&gt;&lt;br/&gt;The broader impact stems from the improved security of systems and the reduced cost of achieving better security, also education activities in the form of summer schools for graduate, undergraduate and high-school students. The tools developed will be released to the public domain, benefiting software developers in the field.</AbstractNarration>
<MinAmdLetterDate>08/20/2014</MinAmdLetterDate>
<MaxAmdLetterDate>08/20/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1408803</AwardID>
<Investigator>
<FirstName>Vinod</FirstName>
<LastName>Ganapathy</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vinod Ganapathy</PI_FULL_NAME>
<EmailAddress>vinodganapathy@gmail.com</EmailAddress>
<PI_PHON>8484458039</PI_PHON>
<NSF_ID>000502351</NSF_ID>
<StartDate>08/20/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Rutgers University New Brunswick</Name>
<CityName>Piscataway</CityName>
<ZipCode>088543925</ZipCode>
<PhoneNumber>8489320150</PhoneNumber>
<StreetAddress>33 Knightsbridge Road</StreetAddress>
<StreetAddress2><![CDATA[2nd Floor East Wing]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>06</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ06</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001912864</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>RUTGERS, THE STATE UNIVERSITY OF NEW JERSEY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001912864</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Rutgers University New Brunswick]]></Name>
<CityName>Piscataway</CityName>
<StateCode>NJ</StateCode>
<ZipCode>088548072</ZipCode>
<StreetAddress><![CDATA[617 Bowser Road]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>06</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ06</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~300000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span style="left: 89.215px; top: 586.566px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.904482);">There is a vast body of prior work on monitoring program execution</span><span style="left: 89.6633px; top: 604.831px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.934389);">at runtime for enforcing various properties related to security, corr</span><span style="left: 89.6633px; top: 623.096px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.897404);">ectness, reliability, debugging, and many others.</span><span style="left: 145.32px; top: 641.361px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.949368);"> Typically, such monitoring is performed via retrofitting</span><span style="left: 89.6633px; top: 659.626px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.949685);"> transformations, in which a given program is modified by adding</span><span style="left: 89.6633px; top: 677.891px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.919375);"> instrumentation to perform checks, and propagate and store meta-</span><span style="left: 89.6633px; top: 696.154px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.942752);">data information at runtime. For example, a transformation to de</span><span style="left: 89.6633px; top: 714.419px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.950928);">tect buffer overflows or other memory-safety errors would instru</span><span style="left: 89.6633px; top: 732.684px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.962747);">ment a program to propagate information about pointer bounds</span><span style="left: 89.1117px; top: 750.949px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.970193);">with each pointer operation and check them on pointer derefer</span><span style="left: 89.6633px; top: 769.214px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.911493);">ences</span><span style="left: 268.608px; top: 769.214px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(1.00307);">. Similarly, a control-flow integrity</span><span style="left: 89.6633px; top: 787.479px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.931191);">enforcement mechanism would add instrumentation to propagate</span><span style="left: 89.6633px; top: 805.744px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.966677);">the set of allowed control flow transfers and check the target of</span><span style="left: 89.6633px; top: 824.009px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.949204);">every indirect call and jump instruction.</span></p> <p><span style="left: 106.268px; top: 842.274px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.912095);">Over the past several years, researchers and practitioners have</span><span style="left: 89.6633px; top: 860.539px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.961356);">developed numerous such retrofitting transformations. They dif-</span><span style="left: 89.6633px; top: 878.804px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.967025);">fer widely in their design, ranging from transformations that are</span><span style="left: 89.6633px; top: 897.068px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.940332);">applied directly at the source-code level,</span><span style="left: 399.92px; top: 897.068px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.952595);"> to those that</span><span style="left: 89.6633px; top: 915.333px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.98319);">modify the compiler to add instrumentation</span><span style="left: 124.853px; top: 933.598px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.986838);">, and to those that add instrumentation via binary rewrit</span><span style="left: 89.6633px; top: 951.863px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(1.01778);">ing</span><span style="left: 174.123px; top: 951.863px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.921769);">. Regardless of the specific design used, retrofitting</span><span style="left: 89.6633px; top: 970.128px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.977081);">transformations are typically complex to implement. This is be</span><span style="left: 89.6633px; top: 988.393px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.900308);">cause the transformations are usually designed at an abstract level, <span style="left: 529.925px; top: 293.183px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.920796);">but any real-world implementation must deal with the complexities </span><span style="left: 529.925px; top: 311.448px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.925559);">of modern languages, runtime, and the hardware ABI.</span></span></p> <p><span style="left: 89.6633px; top: 988.393px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.900308);"><span style="left: 529.925px; top: 311.448px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.925559);"><span style="left: 546.53px; top: 512.361px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.957903);">Apart from removing redundant checks, optimizations can re-</span><span style="left: 529.925px; top: 530.626px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.899181);">move a necessary check (from a retrofitting transformation perspec</span><span style="left: 529.925px; top: 548.891px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.910216);">tive) when they optimize aggressively in the presence of undefined</span><span style="left: 529.925px; top: 567.156px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.949931);">behavior</span><span style="left: 606.11px; top: 567.156px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.923673);">. Further, optimizations can also erroneously remove</span><span style="left: 529.925px; top: 585.421px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.957288);">the inserted checks when implicit assumptions of the retrofitting</span><span style="left: 529.925px; top: 603.686px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.979829);">transformation are not explicitly specified through the dataflow</span><span style="left: 529.925px; top: 621.951px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.967061);">in the program (as these checks seem redundant from the opti-</span><span style="left: 529.925px; top: 640.216px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.932598);">mization&rsquo;s perspective). For example, we discovered a bug in the</span><span style="left: 529.925px; top: 658.481px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.946292);"> SoftBoundCETS transformation in the presence of compiler opti</span><span style="left: 529.925px; top: 676.744px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.956215);">mizations due to a mismatch in the assumptions</span><span style="left: 848.778px; top: 676.744px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.955074);">. As a result,</span><span style="left: 529.925px; top: 695.009px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.889389);">SoftBoundCETS propagates invalid bounds metadata in the shadow</span><span style="left: 529.925px; top: 713.274px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.954453);">stack when the LLVM compiler optimizes function arguments af</span><span style="left: 529.925px; top: 731.539px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.977582);">ter instrumentation</span><span style="left: 665.855px; top: 731.539px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.92909);">. Further, any semantic mismatch between</span><span style="left: 529.925px; top: 749.804px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.930096);">correctness properties and the introduced checks can result in re-</span><span style="left: 529.925px; top: 768.069px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.928378);">moval of checks</span><span style="left: 650.92px; top: 768.069px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.924928);">. </span></span></span></p> <p><span style="left: 89.6633px; top: 988.393px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.900308);"><span style="left: 529.925px; top: 311.448px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.925559);"><span style="left: 650.92px; top: 768.069px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.924928);">One way to address this problem is to avoid </span><span style="left: 529.925px; top: 786.334px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.93552);">compiler optimizations after retrofitting transformations. However,</span><span style="left: 529.925px; top: 804.599px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.907615);">it can result in significant performance overheads.</span><span style="left: 831.63px; top: 804.659px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.843397);"> Hence, our work </span><span style="left: 529.925px; top: 822.924px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.872358);">tackles an alternative research question: is the instrumentation added</span><span style="left: 529.925px; top: 841.189px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.931498);"> to the program by a retrofitting transformation still preserved after</span><span style="left: 529.925px; top: 859.452px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.906708);">compiler optimizations?</span><span style="left: 546.53px; top: 877.658px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.930118);"> </span></span></span></p> <p><span style="left: 89.6633px; top: 988.393px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.900308);"><span style="left: 529.925px; top: 311.448px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.925559);"><span style="left: 546.53px; top: 877.658px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.930118);">This project proposes an approach to detect whether the added</span><span style="left: 529.925px; top: 895.923px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.949588);"> checks have been erroneously removed by optimizations due to</span><span style="left: 529.925px; top: 914.188px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.916064);">mismatches in the assumptions. Our approach relies on the obser</span><span style="left: 529.552px; top: 932.453px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.95616);">vation that any event of interest that is checked in the retrofitted</span><span style="left: 529.925px; top: 950.718px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.926016);"> program must also be checked in the resulting retrofitted program</span><span style="left: 529.925px; top: 968.983px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.917953);"> after optimizations. However, this task is challenging for the followi</span><span style="left: 529.925px; top: 987.248px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.889214);">ng reasons: (1) the checks can be safely optimized away when they</span><span style="left: 529.925px; top: 1005.51px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.899803);">are redundant, (2) the added instrumentation can be moved around</span><span style="left: 529.372px; top: 1023.78px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.924705);">with optimization, and (3) many small functions can be completely</span><span style="left: 529.925px; top: 1042.04px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.971438);">inlined (</span><span style="left: 580.705px; top: 1042.1px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.783524);">e.g.</span><span style="left: 600.222px; top: 1042.04px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.966711);">, with link time optimizations (LTO)).</span></span></span></p> <p><span style="left: 89.6633px; top: 988.393px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.900308);"><span style="left: 529.925px; top: 311.448px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.925559);"><span style="left: 600.222px; top: 1042.04px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.966711);"><span style="left: 106.268px; top: 330.291px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.956616);">We have developed an initial prototype to determine whether</span><span style="left: 89.6633px; top: 348.556px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.966452);">checks in retrofitted LLVM-IR programs have been erroneously</span><span style="left: 89.6633px; top: 366.821px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.937328);">optimized. We have tested the prototype with Olden benchmarks</span><span style="left: 89.6633px; top: 385.086px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.916517);">retrofitted with SoftBoundCETS</span><span style="left: 321.178px; top: 385.086px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.890457);"> and AddressSanitizer trans</span><span style="left: 89.6633px; top: 403.351px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.959225);">formations. Our prototype detects erroneous removal of checks</span><span style="left: 89.6633px; top: 421.616px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.953312);"> in a custom integer overflow checker with undefined behavior. It </span><span style="left: 89.6633px; top: 439.879px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.915866);">has also identified bugs when programs retrofitted with SoftBound-</span><span style="left: 89.6633px; top: 458.144px; font-size: 14.944px; font-family: sans-serif; transform: scaleX(0.92695);">CETS transformation are optimized.</span></span></span></span></p><br> <p>            Last Modified: 06/24/2019<br>      Modified by: Vinod&nbsp;Ganapathy</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ There is a vast body of prior work on monitoring program executionat runtime for enforcing various properties related to security, correctness, reliability, debugging, and many others. Typically, such monitoring is performed via retrofitting transformations, in which a given program is modified by adding instrumentation to perform checks, and propagate and store meta-data information at runtime. For example, a transformation to detect buffer overflows or other memory-safety errors would instrument a program to propagate information about pointer boundswith each pointer operation and check them on pointer dereferences. Similarly, a control-flow integrityenforcement mechanism would add instrumentation to propagatethe set of allowed control flow transfers and check the target ofevery indirect call and jump instruction.  Over the past several years, researchers and practitioners havedeveloped numerous such retrofitting transformations. They dif-fer widely in their design, ranging from transformations that areapplied directly at the source-code level, to those thatmodify the compiler to add instrumentation, and to those that add instrumentation via binary rewriting. Regardless of the specific design used, retrofittingtransformations are typically complex to implement. This is because the transformations are usually designed at an abstract level, but any real-world implementation must deal with the complexities of modern languages, runtime, and the hardware ABI.  Apart from removing redundant checks, optimizations can re-move a necessary check (from a retrofitting transformation perspective) when they optimize aggressively in the presence of undefinedbehavior. Further, optimizations can also erroneously removethe inserted checks when implicit assumptions of the retrofittingtransformation are not explicitly specified through the dataflowin the program (as these checks seem redundant from the opti-mization?s perspective). For example, we discovered a bug in the SoftBoundCETS transformation in the presence of compiler optimizations due to a mismatch in the assumptions. As a result,SoftBoundCETS propagates invalid bounds metadata in the shadowstack when the LLVM compiler optimizes function arguments after instrumentation. Further, any semantic mismatch betweencorrectness properties and the introduced checks can result in re-moval of checks.   One way to address this problem is to avoid compiler optimizations after retrofitting transformations. However,it can result in significant performance overheads. Hence, our work tackles an alternative research question: is the instrumentation added to the program by a retrofitting transformation still preserved aftercompiler optimizations?   This project proposes an approach to detect whether the added checks have been erroneously removed by optimizations due tomismatches in the assumptions. Our approach relies on the observation that any event of interest that is checked in the retrofitted program must also be checked in the resulting retrofitted program after optimizations. However, this task is challenging for the following reasons: (1) the checks can be safely optimized away when theyare redundant, (2) the added instrumentation can be moved aroundwith optimization, and (3) many small functions can be completelyinlined (e.g., with link time optimizations (LTO)).  We have developed an initial prototype to determine whetherchecks in retrofitted LLVM-IR programs have been erroneouslyoptimized. We have tested the prototype with Olden benchmarksretrofitted with SoftBoundCETS and AddressSanitizer transformations. Our prototype detects erroneous removal of checks in a custom integer overflow checker with undefined behavior. It has also identified bugs when programs retrofitted with SoftBound-CETS transformation are optimized.       Last Modified: 06/24/2019       Submitted by: Vinod Ganapathy]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
