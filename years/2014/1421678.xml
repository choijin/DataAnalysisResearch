<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:Small:Collaborative Research: Compositional Verification of Heterogeneous Software Protocol Stacks</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2014</AwardEffectiveDate>
<AwardExpirationDate>12/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>252996.00</AwardTotalIntnAmount>
<AwardAmount>268996</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Developing a software protocol stack is a complex task with many parties and products &lt;br/&gt;involved over multiple years. There are many issues that have to be resolved in the &lt;br/&gt;process, and it is incredibly hard to get all of them correct for all platforms and &lt;br/&gt;all possible states of a system. Hence, there are numerous examples of serious errors&lt;br/&gt;that ended up in production, where the cost of fixing them is high. Software protocol &lt;br/&gt;stacks are widely used in many domains, and rigorous methods to improve their &lt;br/&gt;reliability would have a very broad impact. &lt;br/&gt;&lt;br/&gt;The project develops a more rigorous approach to developing and maintaining such complex software&lt;br/&gt; protocol stacks.In particular, formal methods are used to find errors early through rigorous &lt;br/&gt;verification and testing, as well as to assist the analysis in locating reported errors. The approach&lt;br/&gt; is based on automatically learning abstract and succinct protocol models at different layers of the&lt;br/&gt; target software stack. Compositional reasoning is then applied to find errors effectively and &lt;br/&gt;precisely. The generated models are leveraged to help with error localization and diagnosis. The &lt;br/&gt;usability of the approach is assessed through a real-life case study on the Android Bluetooth&lt;br/&gt; software stack.</AbstractNarration>
<MinAmdLetterDate>06/18/2014</MinAmdLetterDate>
<MaxAmdLetterDate>02/18/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1421678</AwardID>
<Investigator>
<FirstName>Zvonimir</FirstName>
<LastName>Rakamaric</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Zvonimir Rakamaric</PI_FULL_NAME>
<EmailAddress>zvonimir@cs.utah.edu</EmailAddress>
<PI_PHON>8015816903</PI_PHON>
<NSF_ID>000623290</NSF_ID>
<StartDate>06/18/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Utah</Name>
<CityName>SALT LAKE CITY</CityName>
<ZipCode>841128930</ZipCode>
<PhoneNumber>8015816903</PhoneNumber>
<StreetAddress>75 S 2000 E</StreetAddress>
<StreetAddress2><![CDATA[Second Floor]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Utah</StateName>
<StateCode>UT</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>UT02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>009095365</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF UTAH, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>009095365</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Utah]]></Name>
<CityName/>
<StateCode>UT</StateCode>
<ZipCode>841129205</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Utah</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>UT02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~252996</FUND_OBLG>
<FUND_OBLG>2015~16000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The main research goal of this project was to devise novel software verification and testing techniques for improving the reliability and safety of complex protocol stacks, spanning multiple abstraction levels and/or programming languages. Our specific proposed target was the Android ecosystem, which includes the application, Java libraries, and C/C++ operating system (OS) levels. Next, we describe our accomplishments at each of these levels.</p> <p>At the application level, we developed a simple, and yet highly effective technique for detecting malicious Android applications. It is well-known that application market places often contain malicious applications, which can be dangerous when installed to users' phones. Our technique performs automatic classification of applications based on tracking system calls while they are executed in a sandbox environment. We implemented the technique in a tool called maline, and performed extensive empirical evaluation on a suite of around 12,000 applications. The evaluation yields a promising overall detection accuracy as compared to related approaches. This indicates that our technique is viable to be used in practice to detect Android malware. Finally, we show that even simplistic feature choices are highly effective, suggesting that more heavyweight approaches should be thoroughly (re)evaluated. As a part of this line of work we publicly released a large dataset that has been used by other researchers in the area of Android malware detection and machine learning.</p> <p>At the Java libraries level, we devised a novel approach to improve code coverage of automatic testing of Java libraries. The testing of Java libraries is challenging since it requires from the testing tool to generate complex sequences of library method invocations as input in addition to covering hard-to-reach program paths within each method. The approach we proposed is based on a&nbsp;novel combination of random testing and dynamic symbolic execution, where random testing is used to generate interesting sequences of library invocations, while dynamic symbolic execution is used to explore program paths based on each sequence. We implemented this combination as the JDoop automatic Java testing tool, which combines the JDart dynamic symbolic execution engine with the Randoop random software tester. We performed an extensive empirical evaluation of our combination, analyzed that gathered data, and draw conclusions about its pros and cons. In particular, we do show that in some instances our combination outperforms both of the individual approaches, thereby improving state-of-the-art in the area of automatic testing of Java libraries.</p> <p>At the operating system level, we observed that Rust, in combination with C/C++, is gaining traction when it comes to implementing safer operating system modules and protocol stacks. Rust is a new programming language that includes features that make it safer than the traditional OS languages such as C/C++. Hence, we extended our flagship software verifier SMACK with support for cross-language verification of Rust/C/C++ programs. Our architecture based on an intermediate verification language, into which all input languages are translated, allows us to perform uniform verification across language boundaries. We applied SMACK to verify simple Rust implementation of a safe information flow control protocol, thereby showing its promise. We also showed that SMACK can now be used to verify programs that combine Rust with C/C++.</p> <p>We disseminated our research results by publishing conference research papers and reports. We also implemented tools and extensions stemming from this research, and we disseminated those to the academic community as well as practitioners. We made all of the developed tools publicly available as open-source projects. As a part of this project, we also trained a generation of students, including both graduates and undergraduates, in the areas of software verification and testing.</p><br> <p>            Last Modified: 02/20/2018<br>      Modified by: Zvonimir&nbsp;Rakamaric</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The main research goal of this project was to devise novel software verification and testing techniques for improving the reliability and safety of complex protocol stacks, spanning multiple abstraction levels and/or programming languages. Our specific proposed target was the Android ecosystem, which includes the application, Java libraries, and C/C++ operating system (OS) levels. Next, we describe our accomplishments at each of these levels.  At the application level, we developed a simple, and yet highly effective technique for detecting malicious Android applications. It is well-known that application market places often contain malicious applications, which can be dangerous when installed to users' phones. Our technique performs automatic classification of applications based on tracking system calls while they are executed in a sandbox environment. We implemented the technique in a tool called maline, and performed extensive empirical evaluation on a suite of around 12,000 applications. The evaluation yields a promising overall detection accuracy as compared to related approaches. This indicates that our technique is viable to be used in practice to detect Android malware. Finally, we show that even simplistic feature choices are highly effective, suggesting that more heavyweight approaches should be thoroughly (re)evaluated. As a part of this line of work we publicly released a large dataset that has been used by other researchers in the area of Android malware detection and machine learning.  At the Java libraries level, we devised a novel approach to improve code coverage of automatic testing of Java libraries. The testing of Java libraries is challenging since it requires from the testing tool to generate complex sequences of library method invocations as input in addition to covering hard-to-reach program paths within each method. The approach we proposed is based on a novel combination of random testing and dynamic symbolic execution, where random testing is used to generate interesting sequences of library invocations, while dynamic symbolic execution is used to explore program paths based on each sequence. We implemented this combination as the JDoop automatic Java testing tool, which combines the JDart dynamic symbolic execution engine with the Randoop random software tester. We performed an extensive empirical evaluation of our combination, analyzed that gathered data, and draw conclusions about its pros and cons. In particular, we do show that in some instances our combination outperforms both of the individual approaches, thereby improving state-of-the-art in the area of automatic testing of Java libraries.  At the operating system level, we observed that Rust, in combination with C/C++, is gaining traction when it comes to implementing safer operating system modules and protocol stacks. Rust is a new programming language that includes features that make it safer than the traditional OS languages such as C/C++. Hence, we extended our flagship software verifier SMACK with support for cross-language verification of Rust/C/C++ programs. Our architecture based on an intermediate verification language, into which all input languages are translated, allows us to perform uniform verification across language boundaries. We applied SMACK to verify simple Rust implementation of a safe information flow control protocol, thereby showing its promise. We also showed that SMACK can now be used to verify programs that combine Rust with C/C++.  We disseminated our research results by publishing conference research papers and reports. We also implemented tools and extensions stemming from this research, and we disseminated those to the academic community as well as practitioners. We made all of the developed tools publicly available as open-source projects. As a part of this project, we also trained a generation of students, including both graduates and undergraduates, in the areas of software verification and testing.       Last Modified: 02/20/2018       Submitted by: Zvonimir Rakamaric]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
