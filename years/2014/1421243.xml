<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Random Testing for Language Design</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2014</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>500000.00</AwardTotalIntnAmount>
<AwardAmount>500000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Title: SHF:Small:Random Testing for Language Design&lt;br/&gt;&lt;br/&gt;PROPERTY-BASED RANDOM TESTING (PBRT) is a form of black-box testing in which executable partial specifications of a software artifact are used to check its behavior with respect to large numbers of randomly generated test cases. PBRT offers a range of benefits that complement the traditional strengths of full, formal verification; in particular, it (1) allows much more rapid iteration on designs, (2) encourages early focus on stating correct specifications, and (3) supports later proof efforts by allowing invariants to be debugged quickly.  Popularized by the QuickCheck tool in Haskell, PBRT is now widely used in both research and industry.  However, one area where current PBRT methodology has been less successful is where the data values used in testing come with have complex internal structure or intricate invariants.  In particular, this is the case in testing of language designs and related artifacts such as compilers, where the test data are programs. Despite some promising preliminary efforts, random testing has proved difficult to apply to full-scale language designs.  Many of the interesting properties of programming languages are "conditional," leading to a large number of discarded test cases when random testing is applied naively.  This places a premium on the ability to construct good custom generation strategies, but generation strategies for ``interesting programs'' are neither well understood nor well supported by existing tools: better techniques are needed for writing and debugging test-data generators.  &lt;br/&gt;&lt;br/&gt;This project aims to significantly advance the state of the art in property-based random testing, with specific applications to testing fundamental properties of language definitions and related artifacts---properties such as type safety, security (e.g., ``secret inputs cannot influence public outputs''), and compiler correctness.  The intellectual merits are: (1) developing new methodology for writing and debugging random generators for complex data, in particular a framework based on generating ``mutants'' of an artifact under test; (2) designing a domain-specific language for writing generators for random test data with complex invariants (3) distributing polished implementations, both as a compatible extension to the standard QuickCheck library and as a native random-testing tool for the Coq proof assistant; and (4) evaluating the usefulness of these tools by applying them to several significant case studies.  The broader impacts of the project are twofold.  First, better understood, more secure language designs will lead to better and more secure software, and hence to fewer bugs and vulnerabilities in everyday applications and in critical infrastructure.  In particular, the project's main case studies aim to show how random testing can improve the design process for new languages with built-in support for guaranteeing fundamental security properties such as confidentiality, integrity, authorization, and access control.  Second, beyond language design, random testing has proven extremely effective for improving software quality.  The envisaged tools will significantly increase the power of random testing by offering new tools for writing and testing random data generators that can be used with QuickCheck, an existing industry-standard platform, and by offering native support for random testing within Coq, a popular specification and verification tool.  Project results will be incorporated into the "Advanced Programming" course at Penn (which already emphasizes random testing) and will form the basis for a module on random testing of language properties at the Oregon Programming Languages Summer School.</AbstractNarration>
<MinAmdLetterDate>06/13/2014</MinAmdLetterDate>
<MaxAmdLetterDate>06/13/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1421243</AwardID>
<Investigator>
<FirstName>Benjamin</FirstName>
<LastName>Pierce</LastName>
<PI_MID_INIT>C</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Benjamin C Pierce</PI_FULL_NAME>
<EmailAddress>bcpierce@cis.upenn.edu</EmailAddress>
<PI_PHON>2158986222</PI_PHON>
<NSF_ID>000452070</NSF_ID>
<StartDate>06/13/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Pennsylvania</Name>
<CityName>Philadelphia</CityName>
<ZipCode>191046205</ZipCode>
<PhoneNumber>2158987293</PhoneNumber>
<StreetAddress>Research Services</StreetAddress>
<StreetAddress2><![CDATA[3451 Walnut St, 5th Flr Franklin]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>042250712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042250712</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Pennsylvania]]></Name>
<CityName/>
<StateCode>PA</StateCode>
<ZipCode>191046205</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~500000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>PROPERTY-BASED RANDOM TESTING (PBRT) is a form of black-box testing in which executable partial specifications of a software artifact are used to check its behavior with respect to large numbers of randomly generated test cases. PBRT offers a range of benefits that complement the traditional strengths of full, formal verification; in particular, it (1) allows much more rapid iteration on designs, (2) encourages early focus on stating correct specifications, and (3) supports later proof efforts by allowing invariants to be debugged quickly. Popularized by the QuickCheck tool in Haskell, PBRT is now widely used in both research and industry.</p> <p><br />However, one area where current PBRT methodology has been less successful is where the data values used in testing come with have complex internal structure or intricate invariants. In particular, this is the case in testing of language designs and related artifacts such as compilers, where the test data are programs. &nbsp;Despite some promising preliminary efforts, random testing has proved difficult to apply to full-scale language designs. Many of the interesting properties of programming languages are "conditional," leading to a large number of discarded test cases when random testing is applied naively. This places a premium on the ability toconstruct good custom generation strategies, but generation strategies for``interesting programs'' are neither well understood nor well supported by existing tools: better techniques are needed for writing and debugging test-data generators.</p> <p><br />This project focused on property-based random testing of language designs, with specific applications to testing fundamental properties of language definitions and related artifacts---properties such as type safety, security( e.g., ``secret inputs cannot influence public outputs''), and compiler correctness. &nbsp;Specific accomplishments included (1) developing new methodology for writing and debugging random generators for complex data, inparticular a framework based on generating ``mutants'' of an artifact under test; (2) designing a domain-specific language for writing generators for random test data with complex invariants (3) distributing polished implementations, both as a compatible extension to the standard QuickCheck library and as a native random-testing tool for the Coq proof assistant; and( 4) evaluating the usefulness of these tools by applying them to severalsignificant case studies.</p> <p><br />Our first product was a new domain-specificlanguage, called Luck, for writing random generators. We carried out two major case studies in Luck, replicating previous studies (using different technologies) on using PBRT to find bugs in information-flow analyses and functional-language compilers, showing that we can achieve comparable bug-finding effectiveness with much smaller effort, though (with the current prototype implementation) somewhat more slowly.</p> <p><br />The major software product of the grant was a random testing tool called QuickChick for the Coq proof assistant. &nbsp;This tool already existed in prototype form at the start of the grant, but during the grant period it was enormously improved, re-engineered, and applied to several significant case studies. &nbsp;In particular, we built a "mutation testing" framework for QuickChick and used it in testing several pieces of software being developed outside of this project. We used it to aid development of the next design iteration of the Vellvm verified compiler framework, and we used it to help design and specify the DeepSpec web server. &nbsp;QuickChick is now publicly released and included in Coq's continuous integration suite.</p> <p><br />QuickChick is described in a new book written during the grant -- volume 4 in the Software Foundations series. We taught about 250 people to use it as part of the NSF-supported DeepSpec summer schools on verified software.&nbsp;</p> <p><br />Apart from work on Luck and QuickChick, we used the Erlang version ofQuickCheck to build a testable specification for distributed file synchronization services, which was able to find several bugs in Dropbox that were not known to the Dropbox engineers. &nbsp;Finally, in ongoing work that began during the grant, we used the Haskell version of QuickCheck to help prototype, debug, and analyze several of the "micro policies" being developed at Draper Labs and Dover Microsystems for enforcing dynamic security policies using CoreGuard, a new tagged security coprocessor architecture.</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 01/27/2020<br>      Modified by: Benjamin&nbsp;C&nbsp;Pierce</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Image         </div> <div class="galControls onePhoto" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation onePhoto" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2020/1421243/1421243_10310199_1580141742038_ScreenShot2020-01-27at10.28.43AM--rgov-214x142.jpg" original="/por/images/Reports/POR/2020/1421243/1421243_10310199_1580141742038_ScreenShot2020-01-27at10.28.43AM--rgov-800width.jpg" title="QuickChick book cover"><img src="/por/images/Reports/POR/2020/1421243/1421243_10310199_1580141742038_ScreenShot2020-01-27at10.28.43AM--rgov-66x44.jpg" alt="QuickChick book cover"></a> <div class="imageCaptionContainer"> <div class="imageCaption">Cover design for the electronic textbook on QuickChick.</div> <div class="imageCredit">Benjamin C. Pierce</div> <div class="imagePermisssions">Copyrighted</div> <div class="imageSubmitted">Benjamin&nbsp;C&nbsp;Pierce</div> <div class="imageTitle">QuickChick book cover</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ PROPERTY-BASED RANDOM TESTING (PBRT) is a form of black-box testing in which executable partial specifications of a software artifact are used to check its behavior with respect to large numbers of randomly generated test cases. PBRT offers a range of benefits that complement the traditional strengths of full, formal verification; in particular, it (1) allows much more rapid iteration on designs, (2) encourages early focus on stating correct specifications, and (3) supports later proof efforts by allowing invariants to be debugged quickly. Popularized by the QuickCheck tool in Haskell, PBRT is now widely used in both research and industry.   However, one area where current PBRT methodology has been less successful is where the data values used in testing come with have complex internal structure or intricate invariants. In particular, this is the case in testing of language designs and related artifacts such as compilers, where the test data are programs.  Despite some promising preliminary efforts, random testing has proved difficult to apply to full-scale language designs. Many of the interesting properties of programming languages are "conditional," leading to a large number of discarded test cases when random testing is applied naively. This places a premium on the ability toconstruct good custom generation strategies, but generation strategies for``interesting programs'' are neither well understood nor well supported by existing tools: better techniques are needed for writing and debugging test-data generators.   This project focused on property-based random testing of language designs, with specific applications to testing fundamental properties of language definitions and related artifacts---properties such as type safety, security( e.g., ``secret inputs cannot influence public outputs''), and compiler correctness.  Specific accomplishments included (1) developing new methodology for writing and debugging random generators for complex data, inparticular a framework based on generating ``mutants'' of an artifact under test; (2) designing a domain-specific language for writing generators for random test data with complex invariants (3) distributing polished implementations, both as a compatible extension to the standard QuickCheck library and as a native random-testing tool for the Coq proof assistant; and( 4) evaluating the usefulness of these tools by applying them to severalsignificant case studies.   Our first product was a new domain-specificlanguage, called Luck, for writing random generators. We carried out two major case studies in Luck, replicating previous studies (using different technologies) on using PBRT to find bugs in information-flow analyses and functional-language compilers, showing that we can achieve comparable bug-finding effectiveness with much smaller effort, though (with the current prototype implementation) somewhat more slowly.   The major software product of the grant was a random testing tool called QuickChick for the Coq proof assistant.  This tool already existed in prototype form at the start of the grant, but during the grant period it was enormously improved, re-engineered, and applied to several significant case studies.  In particular, we built a "mutation testing" framework for QuickChick and used it in testing several pieces of software being developed outside of this project. We used it to aid development of the next design iteration of the Vellvm verified compiler framework, and we used it to help design and specify the DeepSpec web server.  QuickChick is now publicly released and included in Coq's continuous integration suite.   QuickChick is described in a new book written during the grant -- volume 4 in the Software Foundations series. We taught about 250 people to use it as part of the NSF-supported DeepSpec summer schools on verified software.    Apart from work on Luck and QuickChick, we used the Erlang version ofQuickCheck to build a testable specification for distributed file synchronization services, which was able to find several bugs in Dropbox that were not known to the Dropbox engineers.  Finally, in ongoing work that began during the grant, we used the Haskell version of QuickCheck to help prototype, debug, and analyze several of the "micro policies" being developed at Draper Labs and Dover Microsystems for enforcing dynamic security policies using CoreGuard, a new tagged security coprocessor architecture.             Last Modified: 01/27/2020       Submitted by: Benjamin C Pierce]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
