<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:Small:Designing Architectures to be Formally Verifiable</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/15/2014</AwardEffectiveDate>
<AwardExpirationDate>07/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>340000.00</AwardTotalIntnAmount>
<AwardAmount>348000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Computer systems are exceedingly complicated, and a major challenge is&lt;br/&gt;verifying that they are correct in all situations.  Hardware industry&lt;br/&gt;accordingly spends more effort on verification than it does on actual&lt;br/&gt;design, yet functional design bugs still exist in today's computer&lt;br/&gt;systems, including shipped processor chips from major vendors.  This&lt;br/&gt;project seeks to overcome this verification challenge through a&lt;br/&gt;verification-aware design methodology.  &lt;br/&gt;&lt;br/&gt;This project designs systems such that they can be verified with existing &lt;br/&gt;formal verification methodologies, rather than expecting arbitrary designs &lt;br/&gt;to be verifiable.  Rather than design a system and then try to verify it, &lt;br/&gt;the proposed philosophy is to understand the capabilities of existing verification &lt;br/&gt;methodologies and then try to design the best possible systems that are compatible&lt;br/&gt;with these methodologies. In this work, the verification is performed &lt;br/&gt;with existing verification tools and the innovation is in the design.  &lt;br/&gt;The broad impact of this work is the development of computer systems, &lt;br/&gt;or portions thereof, that are formally verified and thus provably correct &lt;br/&gt;in all cases.</AbstractNarration>
<MinAmdLetterDate>08/14/2014</MinAmdLetterDate>
<MaxAmdLetterDate>04/29/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1421167</AwardID>
<Investigator>
<FirstName>Daniel</FirstName>
<LastName>Sorin</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Daniel Sorin</PI_FULL_NAME>
<EmailAddress>sorin@ee.duke.edu</EmailAddress>
<PI_PHON>9196843030</PI_PHON>
<NSF_ID>000280417</NSF_ID>
<StartDate>08/14/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Duke University</Name>
<CityName>Durham</CityName>
<ZipCode>277054010</ZipCode>
<PhoneNumber>9196843030</PhoneNumber>
<StreetAddress>2200 W. Main St, Suite 710</StreetAddress>
<StreetAddress2><![CDATA[Erwin Square]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<StateCode>NC</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NC01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>044387793</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>DUKE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>044387793</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Duke University]]></Name>
<CityName/>
<StateCode>NC</StateCode>
<ZipCode>277080291</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>North Carolina</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NC04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~340000</FUND_OBLG>
<FUND_OBLG>2016~8000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>One of the most difficult aspects of designing a computer processor is verifying that the design is correct.&nbsp; Processors are extremely complicated and it is often difficult, if not impossible, to fully verify that the design is bug-free.&nbsp; Typically, computer architects design the processors so as to maximize performance and minimize power consumption, and then the verification team tries to find as many bugs as possible before shipping the product.<br />In this project, we have made verifiability a key goal, such that we are designing the processors so as to be provably verifiable.&nbsp; Our goal is formal (mathematical) verification that the processor is bug-free, and not simply testing in search of bugs, which is never complete for systems this complicated.&nbsp; Initially, we assumed that we were starting with the best available formal theory and tools for formal verification, and we figured out how to design parts of the processor such that they could be verified with existing tools.&nbsp; We focused on protocols, both for power management and for cache coherence, which is a mechanism for keeping data up-to-date in the many small on-chip memories.&nbsp; Protocols are notoriously difficult to verify, particularly for large numbers of processor cores.&nbsp; However we showed how to design protocols such that they could be verified in a way that isi ndependent of the number of cores.&nbsp; We immplemented these protocols and experimentally evaluated them to show that verifiability need not cost much performance.</p> <p><br />These new protocols were very exciting, because they were the first protocols that were verifiable and "flat", in that there was one manager and a large number of peers cores.&nbsp; Prior work by the PI showed how to design verifiable hierarchical protocols that were organized as tall, skinny trees (each parent could have only two children).&nbsp; These two classes of verifiable protocols are extremes, and we decided we wanted arbitrary hierarchies of protocols.&nbsp; To do this, we had to develop a new theory that proves, mathematically, why such protocols could be verified in a scalable fashion.</p> <p>The results of this research project are very exciting.&nbsp; Previously, nobody had shown how to design realistic protocols that could be verified for arbitrary numbers of processor cores.&nbsp; Industry had been using testing to find bugs (which is an incomplete process) and formal verification only on tiny system models with only a handful of cores. Industry already spends more money on verification than design and they still have bugs; our work shows a path towards verifiability, and we expect it to change how the industry designs protocols.</p> <p><br />This inter-disciplinary research--in both computer architecture and verification--has had numerous broader impacts.&nbsp; The research, both inarchitecture and theory, was disseminated to both research communities in their top conferences.&nbsp; The technology was transferred to industry in two respects.&nbsp; First, the lead graduate student, Dr. Opeoluwa Matthews, spent an internship at Intel in a verification group. Seccond, we worked with colleagues at Intel on our new theory.&nbsp; The project trained Dr. Matthews, an under-represented minority, in research and communication, and he is now pursuing a postdoc at Princeton University, with a goal of becoming a professor.&nbsp; If successful, Dr. Matthews would become one of a very small number of black faculty in computer architecture.</p><br> <p>            Last Modified: 08/03/2018<br>      Modified by: Daniel&nbsp;Sorin</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ One of the most difficult aspects of designing a computer processor is verifying that the design is correct.  Processors are extremely complicated and it is often difficult, if not impossible, to fully verify that the design is bug-free.  Typically, computer architects design the processors so as to maximize performance and minimize power consumption, and then the verification team tries to find as many bugs as possible before shipping the product. In this project, we have made verifiability a key goal, such that we are designing the processors so as to be provably verifiable.  Our goal is formal (mathematical) verification that the processor is bug-free, and not simply testing in search of bugs, which is never complete for systems this complicated.  Initially, we assumed that we were starting with the best available formal theory and tools for formal verification, and we figured out how to design parts of the processor such that they could be verified with existing tools.  We focused on protocols, both for power management and for cache coherence, which is a mechanism for keeping data up-to-date in the many small on-chip memories.  Protocols are notoriously difficult to verify, particularly for large numbers of processor cores.  However we showed how to design protocols such that they could be verified in a way that isi ndependent of the number of cores.  We immplemented these protocols and experimentally evaluated them to show that verifiability need not cost much performance.   These new protocols were very exciting, because they were the first protocols that were verifiable and "flat", in that there was one manager and a large number of peers cores.  Prior work by the PI showed how to design verifiable hierarchical protocols that were organized as tall, skinny trees (each parent could have only two children).  These two classes of verifiable protocols are extremes, and we decided we wanted arbitrary hierarchies of protocols.  To do this, we had to develop a new theory that proves, mathematically, why such protocols could be verified in a scalable fashion.  The results of this research project are very exciting.  Previously, nobody had shown how to design realistic protocols that could be verified for arbitrary numbers of processor cores.  Industry had been using testing to find bugs (which is an incomplete process) and formal verification only on tiny system models with only a handful of cores. Industry already spends more money on verification than design and they still have bugs; our work shows a path towards verifiability, and we expect it to change how the industry designs protocols.   This inter-disciplinary research--in both computer architecture and verification--has had numerous broader impacts.  The research, both inarchitecture and theory, was disseminated to both research communities in their top conferences.  The technology was transferred to industry in two respects.  First, the lead graduate student, Dr. Opeoluwa Matthews, spent an internship at Intel in a verification group. Seccond, we worked with colleagues at Intel on our new theory.  The project trained Dr. Matthews, an under-represented minority, in research and communication, and he is now pursuing a postdoc at Princeton University, with a goal of becoming a professor.  If successful, Dr. Matthews would become one of a very small number of black faculty in computer architecture.       Last Modified: 08/03/2018       Submitted by: Daniel Sorin]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
