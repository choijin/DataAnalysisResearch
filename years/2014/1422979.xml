<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Small: Using a Capability-Enhanced Microkernel as a Testbed for Language-based Security (CEMLaBS)</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2014</AwardEffectiveDate>
<AwardExpirationDate>09/30/2018</AwardExpirationDate>
<AwardTotalIntnAmount>324364.00</AwardTotalIntnAmount>
<AwardAmount>324364</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Shannon Beck</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>This project is investigating the potential for language-based security techniques in the construction of low-level systems software.  The specific focus is on the development of an open, capability-enhanced microkernel whose design is based on seL4, a "security enhanced" version of the L4 microkernel that was developed, by a team in Australia, as the first fully verified, general purpose operating system.&lt;br/&gt;&lt;br/&gt;The work on seL4 is rightly celebrated as a landmark for formal verification, and provides a strong foundation for building trustworthy systems.  The costs of its development and maintenance, however, are quite high.  We have observed that many of the security properties established in the seL4 verification (including the absence of code injection attacks, buffer overflows, and null pointer dereferences) could have been guaranteed automatically by writing it in a language that incorporates language-based security mechanisms such as an enhanced type system.  Motivated by such insights, the specific goals of this project are to evaluate: whether it is actually feasible to write software of this kind in a language with meaningful, language-based security guarantees; what practical impact this might have, particularly in reducing verification costs; and whether it is possible to meet the performance goals that are&lt;br/&gt;typically required in such applications.&lt;br/&gt;&lt;br/&gt;The primary impact of this project will be in increasing the applicability of verification and language-based security techniques for the construction of secure computer systems.  It will also generate and distribute key artefacts including the microkernel implementation, with associated teaching materials, for use in education, research, and industry.</AbstractNarration>
<MinAmdLetterDate>07/29/2014</MinAmdLetterDate>
<MaxAmdLetterDate>07/29/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1422979</AwardID>
<Investigator>
<FirstName>Mark</FirstName>
<LastName>Jones</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Mark Jones</PI_FULL_NAME>
<EmailAddress>mpj@pdx.edu</EmailAddress>
<PI_PHON>5037259989</PI_PHON>
<NSF_ID>000661966</NSF_ID>
<StartDate>07/29/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Portland State University</Name>
<CityName>Portland</CityName>
<ZipCode>972070751</ZipCode>
<PhoneNumber>5037259900</PhoneNumber>
<StreetAddress>1600 SW 4th Ave</StreetAddress>
<StreetAddress2><![CDATA[Attn: Sponsored Projects Admin]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Oregon</StateName>
<StateCode>OR</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>OR03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052226800</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PORTLAND STATE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052226800</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Portland State University]]></Name>
<CityName/>
<StateCode>OR</StateCode>
<ZipCode>972070751</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Oregon</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>OR03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~324364</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Modern society relies on computer systems in fundamental ways. &nbsp;Whether it is a communication network, a banking system, or a medical device, we must place our trust in these machines to enable, support, and protect us in so many of our day-to-day activities. &nbsp;At the same time, we are all painfully aware that these systems sometimes fail as a result of bugs in their software. &nbsp;At the very least, such failures result in inconvenience as we wait for a system to be restarted or repaired. &nbsp;In the worst-case, however, the consequences can be severe, potentially exposing personal information, compromising our safety, or even risking loss of life. &nbsp;It is important to find efficient and effective ways to design and deploy new software systems for use across the rapidly expanding range of applications. &nbsp;But it is also essential to ensure that the resulting software will function correctly, justifying our implicit trust in the systems that we already rely on many times every day.</p> <p>One critical area where these concerns occur is in the design of "low-level", "bare metal", or "systems" software, such as an operating system that interacts directly with the computer's hardware components and provides a platform for running all of the higher-level applications. &nbsp;This kind of software can be difficult to write, requiring the developer to pay attention to many fiddly and subtle details that are easily overlooked. &nbsp;But it is also important to ensure that this software functions correctly because any flaw in this foundational layer can potentially compromise the safety and security of any higher-level applications that it supports.</p> <p>In 2009, a group of researchers in Australia announced a major accomplishment in this area, having completed a "formal verification" of a low-level operating system (more specifically, a "capability-enhanced" microkernel) called seL4. &nbsp;In essence, this group demonstrated, for the first time, that it was possible to build industrially-relevant, high-performance systems software and, simultaneously, to construct a rigorous mathematical proof to show that the software will always obey a high-level, mathematical specification of its behavior. &nbsp;The software for seL4 was written in the C programming language, whose origins date back to the early 1970s; several decades later, C is still well-known and widely used for developing systems software, so it made sense that the seL4 team would choose to use it for their project. &nbsp;On the other hand, in the years since C was first introduced, numerous other programming languages have been designed, incorporating new features that aim to increase programmer productivity, and to detect and prevent broad families of programming errors that can be made inadvertently when writing programs in C. &nbsp;What might these newer languages have to offer when it comes to writing low-level software?</p> <p>&nbsp;</p> <p>The work on seL4 is rightly celebrated as a landmark achievement, and provides a strong foundation for building trustworthy systems. &nbsp;The costs of its development and maintenance, however, were quite high, involving the construction of a 200,000 line formal proof and requiring approximately 20 person years of effort for a relatively small program that is less than 10,000 lines long. &nbsp;But the decision to write seL4 in C also complicated the formal verification effort because it forced the proof engineers to consider a range of security vulnerabilities that could have been avoided automatically if the code had been written in a newer language. &nbsp;Programming languages the incorporate mechanisms for language-based security, such as a "type system", are particularly interesting candidates here because they can be used to ensure that certain important classes of programming errors are detected automatically, without even running the program.</p> <p>Motivated by such insights, the specific goals of the CEMLaBS project were to evaluate: whether it is feasible to write software of this kind in a language with meaningful, language-based security guarantees; what practical impact this might have, particularly in reducing verification costs; and whether it is possible to meet the performance goals that are typically required in such applications.</p> <p>The project included a strong educational component, centered on the development and delivery of a new course to teach students about the challenges of building low-level software and to explore opportunities for reducing development costs (and improving program quality) by using different programming languages. &nbsp;This course was offered three times at PSU, and an extensive set of course materials, suitable for both group and individual study, has been released under open licenses at http://web.cecs.pdx.edu/~mpj/llp/.</p> <p>The project has also lead to the development of tools and sample software using Habit, a programming language that includes features from "functional" languages that increase programmer productivity, language-based security features that improve program quality, and systems programming features that support low-level development. &nbsp;The resulting tools, together with sample programs and more information, are available under open source licenses from http://www.habit-lang.org.<br /><br /></p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 12/21/2018<br>      Modified by: Mark&nbsp;Jones</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Modern society relies on computer systems in fundamental ways.  Whether it is a communication network, a banking system, or a medical device, we must place our trust in these machines to enable, support, and protect us in so many of our day-to-day activities.  At the same time, we are all painfully aware that these systems sometimes fail as a result of bugs in their software.  At the very least, such failures result in inconvenience as we wait for a system to be restarted or repaired.  In the worst-case, however, the consequences can be severe, potentially exposing personal information, compromising our safety, or even risking loss of life.  It is important to find efficient and effective ways to design and deploy new software systems for use across the rapidly expanding range of applications.  But it is also essential to ensure that the resulting software will function correctly, justifying our implicit trust in the systems that we already rely on many times every day.  One critical area where these concerns occur is in the design of "low-level", "bare metal", or "systems" software, such as an operating system that interacts directly with the computer's hardware components and provides a platform for running all of the higher-level applications.  This kind of software can be difficult to write, requiring the developer to pay attention to many fiddly and subtle details that are easily overlooked.  But it is also important to ensure that this software functions correctly because any flaw in this foundational layer can potentially compromise the safety and security of any higher-level applications that it supports.  In 2009, a group of researchers in Australia announced a major accomplishment in this area, having completed a "formal verification" of a low-level operating system (more specifically, a "capability-enhanced" microkernel) called seL4.  In essence, this group demonstrated, for the first time, that it was possible to build industrially-relevant, high-performance systems software and, simultaneously, to construct a rigorous mathematical proof to show that the software will always obey a high-level, mathematical specification of its behavior.  The software for seL4 was written in the C programming language, whose origins date back to the early 1970s; several decades later, C is still well-known and widely used for developing systems software, so it made sense that the seL4 team would choose to use it for their project.  On the other hand, in the years since C was first introduced, numerous other programming languages have been designed, incorporating new features that aim to increase programmer productivity, and to detect and prevent broad families of programming errors that can be made inadvertently when writing programs in C.  What might these newer languages have to offer when it comes to writing low-level software?     The work on seL4 is rightly celebrated as a landmark achievement, and provides a strong foundation for building trustworthy systems.  The costs of its development and maintenance, however, were quite high, involving the construction of a 200,000 line formal proof and requiring approximately 20 person years of effort for a relatively small program that is less than 10,000 lines long.  But the decision to write seL4 in C also complicated the formal verification effort because it forced the proof engineers to consider a range of security vulnerabilities that could have been avoided automatically if the code had been written in a newer language.  Programming languages the incorporate mechanisms for language-based security, such as a "type system", are particularly interesting candidates here because they can be used to ensure that certain important classes of programming errors are detected automatically, without even running the program.  Motivated by such insights, the specific goals of the CEMLaBS project were to evaluate: whether it is feasible to write software of this kind in a language with meaningful, language-based security guarantees; what practical impact this might have, particularly in reducing verification costs; and whether it is possible to meet the performance goals that are typically required in such applications.  The project included a strong educational component, centered on the development and delivery of a new course to teach students about the challenges of building low-level software and to explore opportunities for reducing development costs (and improving program quality) by using different programming languages.  This course was offered three times at PSU, and an extensive set of course materials, suitable for both group and individual study, has been released under open licenses at http://web.cecs.pdx.edu/~mpj/llp/.  The project has also lead to the development of tools and sample software using Habit, a programming language that includes features from "functional" languages that increase programmer productivity, language-based security features that improve program quality, and systems programming features that support low-level development.  The resulting tools, together with sample programs and more information, are available under open source licenses from http://www.habit-lang.org.                  Last Modified: 12/21/2018       Submitted by: Mark Jones]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
