<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:Small:Collaborative Research: Compositional Verification of Heterogeneous Software Protocol Stacks</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2014</AwardEffectiveDate>
<AwardExpirationDate>06/30/2019</AwardExpirationDate>
<AwardTotalIntnAmount>246958.00</AwardTotalIntnAmount>
<AwardAmount>246958</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Developing a software protocol stack is a complex task with many parties and products &lt;br/&gt;involved over multiple years. There are many issues that have to be resolved in the &lt;br/&gt;process, and it is incredibly hard to get all of them correct for all platforms and &lt;br/&gt;all possible states of a system. Hence, there are numerous examples of serious errors&lt;br/&gt;that ended up in production, where the cost of fixing them is high. Software protocol &lt;br/&gt;stacks are widely used in many domains, and rigorous methods to improve their &lt;br/&gt;reliability would have a very broad impact. &lt;br/&gt;&lt;br/&gt;The project develops a more rigorous approach to developing and maintaining such complex software&lt;br/&gt; protocol stacks.In particular, formal methods are used to find errors early through rigorous &lt;br/&gt;verification and testing, as well as to assist the analysis in locating reported errors. The approach&lt;br/&gt; is based on automatically learning abstract and succinct protocol models at different layers of the&lt;br/&gt; target software stack. Compositional reasoning is then applied to find errors effectively and &lt;br/&gt;precisely. The generated models are leveraged to help with error localization and diagnosis. The &lt;br/&gt;usability of the approach is assessed through a real-life case study on the Android Bluetooth&lt;br/&gt; software stack.</AbstractNarration>
<MinAmdLetterDate>06/18/2014</MinAmdLetterDate>
<MaxAmdLetterDate>03/03/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1422705</AwardID>
<Investigator>
<FirstName>Limin</FirstName>
<LastName>Jia</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Limin Jia</PI_FULL_NAME>
<EmailAddress>liminjia@cmu.edu</EmailAddress>
<PI_PHON>4122688746</PI_PHON>
<NSF_ID>000555265</NSF_ID>
<StartDate>03/03/2017</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Falk</FirstName>
<LastName>Howar</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Falk Howar</PI_FULL_NAME>
<EmailAddress>falk.howar@sv.cmu.edu</EmailAddress>
<PI_PHON>4122689527</PI_PHON>
<NSF_ID>000661927</NSF_ID>
<StartDate>06/18/2014</StartDate>
<EndDate>07/31/2014</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Temesghen</FirstName>
<LastName>Kahsai Azene</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Temesghen Kahsai Azene</PI_FULL_NAME>
<EmailAddress>teme.kahsai@sv.cmu.edu</EmailAddress>
<PI_PHON>4122689527</PI_PHON>
<NSF_ID>000661928</NSF_ID>
<StartDate>07/31/2014</StartDate>
<EndDate>03/03/2017</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Temesghen</FirstName>
<LastName>Kahsai Azene</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Temesghen Kahsai Azene</PI_FULL_NAME>
<EmailAddress>teme.kahsai@sv.cmu.edu</EmailAddress>
<PI_PHON>4122689527</PI_PHON>
<NSF_ID>000661928</NSF_ID>
<StartDate>06/18/2014</StartDate>
<EndDate>07/31/2014</EndDate>
<RoleCode>Former Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Carnegie-Mellon University</Name>
<CityName>PITTSBURGH</CityName>
<ZipCode>152133815</ZipCode>
<PhoneNumber>4122688746</PhoneNumber>
<StreetAddress>5000 Forbes Avenue</StreetAddress>
<StreetAddress2><![CDATA[WQED Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052184116</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CARNEGIE MELLON UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052184116</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Carnegie-Mellon University]]></Name>
<CityName>Moffett Field</CityName>
<StateCode>CA</StateCode>
<ZipCode>940350001</ZipCode>
<StreetAddress><![CDATA[NASA Ames Research Park]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~246958</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software we use today, e.g., Android applications, often contains heterogeneous software protocol stack, spanning layers starting from hardware at the bottom, then going through several low-leveloperating system (OS) layers written in C, and ending up with high-level libraries written in managed languages such as Java. To ensure security and availability of such applications, developers need tools to help them to identify bugs early in the development phase and again later in the testing and software update and maintenance phase. This project has developed techniques and tools to aid the verification and testing of heterogeneous software protocol stack.</p> <p><br />Motivated by the need to effectively verify both lower-level layers written in C and upper-level layers written in Java, this project developed the SeaHorn and JayHorn model checker.&nbsp; SeaHorn is split into three main components: the front-end, the middle-end, and the back-end.&nbsp; The front-end compiles C programs and generates an internal intermediate representation more suitable for verification. The middle-end uses Constraint Horn Clauses to encode the verification conditions that arise from the verification of the generated LLVM bitcode from the front-end. Finally, the back-end discharges the verification conditions using SMT solvers. The modular design of SeaHorn enables other researchers to re-use components of SeaHorn. New back-end solvers can be easily swapped in and connected to the middle-end. New language semantics can be delt with by the front-endand the middle-end is parametric on the language semantics. SeaHorn has demonstrated to be extremely competitive in the category of Linux device drivers verification.&nbsp; Similar to SeaHorn, JayHorn is amodular, Horn clauses based verification engine for Java programs. JayHorn compiles Java Bytecode into Horn clauses and it uses Horn clauses solver to discharge the proof obligations.<br /><br />This project has also developed a technique to check for inconsistency in software programs. A piece of code is inconsistent if it is not part of any safely terminating execution. Inconsistent code is an important class of program abnormalities that appears in real-world code bases and often reveals serious bugs.&nbsp; The ability of existingtools to detect inconsistencies is limited by gross over-approximation of looping control-flow. This project have developed a novel approach to inconsistent code detection that can reason about programs with loops without compromising precision. This technique is integrated in SeaHorn and is able to analyze programs with inconsistencies that were previously unattainable.</p> <p><br />Finally, this project has investigated the feasibility of verifying safety invariants of the Java Native Interface (JNI) via model checking.&nbsp; JNI is a two-way interface between Java code and functionswritten in C, C++, or assembly language and has over 1,500 usage rules which, if violated, may lead to errors, memory leaks, and crashes. JNIis the glue between protocol layers.&nbsp;A set of constraints of JNI functions that couldbe verified using model checking is identified. The majority of these constraints concern resource acquire and release usage pattern, similar to proper nesting of lock/unlock in Linux device driver verification. This project has developed an infrastructure to automatically insert assertions for checking JNI safety invariants and then invoke model checkers such as SeaHorn.&nbsp;<br /><br />The results of this project contributed two verification tools SeaHornand JayHorn and advanced existing techniques of program verification by using Horn clauses. SeaHorn, the tool developed as part of thisproject, was used as an educational tool at summer schools on formal techniques, to teach graduate students about formal analysis techniques.&nbsp; The project provided training for several undergraduate, graduate students, including several from underrepresented groups.<br /><br /><br /><br /><br /><br /><br /><br /></p><br> <p>            Last Modified: 09/17/2019<br>      Modified by: Limin&nbsp;Jia</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Software we use today, e.g., Android applications, often contains heterogeneous software protocol stack, spanning layers starting from hardware at the bottom, then going through several low-leveloperating system (OS) layers written in C, and ending up with high-level libraries written in managed languages such as Java. To ensure security and availability of such applications, developers need tools to help them to identify bugs early in the development phase and again later in the testing and software update and maintenance phase. This project has developed techniques and tools to aid the verification and testing of heterogeneous software protocol stack.   Motivated by the need to effectively verify both lower-level layers written in C and upper-level layers written in Java, this project developed the SeaHorn and JayHorn model checker.  SeaHorn is split into three main components: the front-end, the middle-end, and the back-end.  The front-end compiles C programs and generates an internal intermediate representation more suitable for verification. The middle-end uses Constraint Horn Clauses to encode the verification conditions that arise from the verification of the generated LLVM bitcode from the front-end. Finally, the back-end discharges the verification conditions using SMT solvers. The modular design of SeaHorn enables other researchers to re-use components of SeaHorn. New back-end solvers can be easily swapped in and connected to the middle-end. New language semantics can be delt with by the front-endand the middle-end is parametric on the language semantics. SeaHorn has demonstrated to be extremely competitive in the category of Linux device drivers verification.  Similar to SeaHorn, JayHorn is amodular, Horn clauses based verification engine for Java programs. JayHorn compiles Java Bytecode into Horn clauses and it uses Horn clauses solver to discharge the proof obligations.  This project has also developed a technique to check for inconsistency in software programs. A piece of code is inconsistent if it is not part of any safely terminating execution. Inconsistent code is an important class of program abnormalities that appears in real-world code bases and often reveals serious bugs.  The ability of existingtools to detect inconsistencies is limited by gross over-approximation of looping control-flow. This project have developed a novel approach to inconsistent code detection that can reason about programs with loops without compromising precision. This technique is integrated in SeaHorn and is able to analyze programs with inconsistencies that were previously unattainable.   Finally, this project has investigated the feasibility of verifying safety invariants of the Java Native Interface (JNI) via model checking.  JNI is a two-way interface between Java code and functionswritten in C, C++, or assembly language and has over 1,500 usage rules which, if violated, may lead to errors, memory leaks, and crashes. JNIis the glue between protocol layers. A set of constraints of JNI functions that couldbe verified using model checking is identified. The majority of these constraints concern resource acquire and release usage pattern, similar to proper nesting of lock/unlock in Linux device driver verification. This project has developed an infrastructure to automatically insert assertions for checking JNI safety invariants and then invoke model checkers such as SeaHorn.   The results of this project contributed two verification tools SeaHornand JayHorn and advanced existing techniques of program verification by using Horn clauses. SeaHorn, the tool developed as part of thisproject, was used as an educational tool at summer schools on formal techniques, to teach graduate students about formal analysis techniques.  The project provided training for several undergraduate, graduate students, including several from underrepresented groups.               Last Modified: 09/17/2019       Submitted by: Limin Jia]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
