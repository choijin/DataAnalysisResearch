<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Medium: Collaborative: Aspire: Leveraging Automated Synthesis Technologies for Enhancing System Security</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2014</AwardEffectiveDate>
<AwardExpirationDate>07/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>800000.00</AwardTotalIntnAmount>
<AwardAmount>800000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Designing secure systems and validating security of existing systems are hard challenges facing our society. For implementing secure applications, a serious stumbling block lies in the generation of a correct system specification for a security policy. It is non-trivial for both system designers and end users to express their intent in terms of formal logic. Similar challenges plague users' trying to validate security properties of existing applications, such as web or cloud based services, which often have no formal specifications. Thus, there is an urgent need for mechanisms that can bridge the gap between expressions of user intent and system specifications. This research designs an approach and a system called Aspire that is able to translate user intent into security specifications. &lt;br/&gt;&lt;br/&gt;Aspire takes as input, expressions of user intent such as a system demonstration,  application input-output examples, or natural language. Aspire leverages recent  developments in the field of automated synthesis technologies that can consider such examples of user intent as input to the synthesis of security specifications. Aspire combines such inputs, along with a domain specific language for security applications, to synthesize a candidate set of possible outputs. The user can either choose a candidate output or provide more examples to guide the synthesis process. In this iterative fashion, the user can generate system specifications, policies, or properties. Aspire uses concepts from the domain of formal methods, machine learning, and programming languages to perform synthesis. Aspire is applicable to a variety of domains including web, mobile, and cloud applications. The output of Aspire's synthesis can either be used for analyzing security vulnerabilities, or for compilation and testing with real systems.</AbstractNarration>
<MinAmdLetterDate>08/05/2014</MinAmdLetterDate>
<MaxAmdLetterDate>08/05/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1409915</AwardID>
<Investigator>
<FirstName>Dawn</FirstName>
<LastName>Song</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Dawn Song</PI_FULL_NAME>
<EmailAddress>dawnsong@cs.berkeley.edu</EmailAddress>
<PI_PHON>5106428282</PI_PHON>
<NSF_ID>000079467</NSF_ID>
<StartDate>08/05/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Berkeley</Name>
<CityName>BERKELEY</CityName>
<ZipCode>947101749</ZipCode>
<PhoneNumber>5106433891</PhoneNumber>
<StreetAddress>Sponsored Projects Office</StreetAddress>
<StreetAddress2><![CDATA[1608 Fourth Street, Suite 220]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA13</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>124726725</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Berkeley]]></Name>
<CityName>Berkeley</CityName>
<StateCode>CA</StateCode>
<ZipCode>947201776</ZipCode>
<StreetAddress><![CDATA[675 Soda Hall]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA13</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~800000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span id="docs-internal-guid-e3b68e5e-7fff-0d93-2c39-46cb0f4d325c"> <p dir="ltr"><span>We have made significant progress in advancing the field of neural program synthesis, where we leverage deep neural networks to generate programs. We have proposed novel techniques to synthesize programs from user intents specified in diverse formats, including natural language and input-output examples. We have also developed techniques for software engineering applications.</span></p> <br /> <p dir="ltr"><span>First, we proposed new model architectures and training algorithms to learn programs that generalize to test cases far from the training distribution. The key insight is to incorporate recursion into the approach design, which provides effective regularization of the program space. By utilizing recursive traces to train the Neural Programmer-Interpreter (NPI) architecture, the model achieves 100% accuracy on learning sorting and several other simple algorithms. We also proposed new model architectures to support hierarhical program generation, and improved the model expressiveness to handle more complex tasks. In particular, we proposed novel techniques to learn a context-free parser from pairs of input programs and their parse trees. Our neural parsing programs can be learned to achieve 100% test accuracy on test inputs that are 500X longer than the training samples. We published related papers on these topics at ICLR 2017 and ICLR 2018, and the paper on recursive NPI won the Best Paper Award at ICLR 2017.</span></p> <br /> <p dir="ltr"><span>Second, we have developed a series of techniques to leverage execution results for program synthesis. Specifically, we incorporate an execution machine into our neural program synthesis framework, so that we can utilize the execution traces to provide richer information for model prediction. We conduct the evaluation on a benchmark program synthesis task based on the Karel programming language (an educational programming language, where imperative programs control an agent in a grid-world), and our approaches achieve significant performance gain compared to previous work. We have published related papers at NeurIPS 2018 and ICLR 2019.</span></p> <br /> <p dir="ltr"><span>Third, we have developed novel deep neural network architectures for software engineering applications. We have developed a novel method for using tree-structured neural networks to interpret and synthesize programs, with the application of translating code from one programming language to another. We created a dataset of JavaScript and CoffeeScript program pairs and evaluated our system on it; our tree-to-tree method achieves significantly higher performance than baselines based on sequence-based neural networks. We also evaluated the performance of our methodology on a Java to C# translation task proposed by prior work, where our system was 1.5-3x more accurate than the prior work. In addition, we developed a framework to incorporate program repair as a sub-routine for program synthesis, where the repair module aims at fixing the errors in the programs predicted by the neural program synthesizer. We designed neural networks for specification-guided program repair, and demonstrated that the repair module provides further improvement for program synthesis. We have published the paper on program translation at NeurIPS 2018.</span></p> <br /> <p dir="ltr"><span>Fourth, we have developed techniques for synthesizing programs from natural language, including logical forms in domain-specific languages, SQL queries, and Python. For example, we have developed a system for synthesizing a restricted class of programs called &ldquo;If-Then&rdquo; programs. Our system determines which services an If-Then program interacts with given a natural language description of the program. We proposed the Latent Attention neural network architecture, which takes into account the embedded meanings of words and their positions in the description, in addition to the relative importance of each word in the vocabulary. We demonstrated superior performance on the public data available on IFTTT and Zapier. We have also developed a neural-symbolic approach for reading comprehension. Specifically, given a question and a passage as the context, instead of directly generating the final answer, our model generates a program for multi-step reasoning, which can be executed to produce the answer. We demonstrated superior performance on reading comprehension benchmarks that require advanced numerical reasoning. We have published related papers at NeurIPS 2016 and ICLR 2020.</span></p> <br /> <p dir="ltr"><span>Finally, we have studied the effect of training data bias for neural program synthesis. For input-output program synthesis, a common practice for training dataset construction is to randomly generate programs and their corresponding input-output pairs. However, we showed that such type of processes may lead to subtle biases in the distribution of the resulting data, and models trained on such data will fail to work on input-output specifications that fall outside of the distribution. Through more careful generation of the training data, we were able to obtain significant performance improvement on synthesizing programs in Karel language. For our work on If-Then program synthesis, we also considered the few-shot learning scenario, where the test samples may call APIs that do not appear frequently in the training set, and we proposed a 2-step training method to improve the model performance in this more challenging setting. We have published related papers at NeurIPS 2016 and ICLR 2019.</span></p> </span></p><br> <p>            Last Modified: 08/06/2020<br>      Modified by: Dawn&nbsp;Song</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  We have made significant progress in advancing the field of neural program synthesis, where we leverage deep neural networks to generate programs. We have proposed novel techniques to synthesize programs from user intents specified in diverse formats, including natural language and input-output examples. We have also developed techniques for software engineering applications.   First, we proposed new model architectures and training algorithms to learn programs that generalize to test cases far from the training distribution. The key insight is to incorporate recursion into the approach design, which provides effective regularization of the program space. By utilizing recursive traces to train the Neural Programmer-Interpreter (NPI) architecture, the model achieves 100% accuracy on learning sorting and several other simple algorithms. We also proposed new model architectures to support hierarhical program generation, and improved the model expressiveness to handle more complex tasks. In particular, we proposed novel techniques to learn a context-free parser from pairs of input programs and their parse trees. Our neural parsing programs can be learned to achieve 100% test accuracy on test inputs that are 500X longer than the training samples. We published related papers on these topics at ICLR 2017 and ICLR 2018, and the paper on recursive NPI won the Best Paper Award at ICLR 2017.   Second, we have developed a series of techniques to leverage execution results for program synthesis. Specifically, we incorporate an execution machine into our neural program synthesis framework, so that we can utilize the execution traces to provide richer information for model prediction. We conduct the evaluation on a benchmark program synthesis task based on the Karel programming language (an educational programming language, where imperative programs control an agent in a grid-world), and our approaches achieve significant performance gain compared to previous work. We have published related papers at NeurIPS 2018 and ICLR 2019.   Third, we have developed novel deep neural network architectures for software engineering applications. We have developed a novel method for using tree-structured neural networks to interpret and synthesize programs, with the application of translating code from one programming language to another. We created a dataset of JavaScript and CoffeeScript program pairs and evaluated our system on it; our tree-to-tree method achieves significantly higher performance than baselines based on sequence-based neural networks. We also evaluated the performance of our methodology on a Java to C# translation task proposed by prior work, where our system was 1.5-3x more accurate than the prior work. In addition, we developed a framework to incorporate program repair as a sub-routine for program synthesis, where the repair module aims at fixing the errors in the programs predicted by the neural program synthesizer. We designed neural networks for specification-guided program repair, and demonstrated that the repair module provides further improvement for program synthesis. We have published the paper on program translation at NeurIPS 2018.   Fourth, we have developed techniques for synthesizing programs from natural language, including logical forms in domain-specific languages, SQL queries, and Python. For example, we have developed a system for synthesizing a restricted class of programs called "If-Then" programs. Our system determines which services an If-Then program interacts with given a natural language description of the program. We proposed the Latent Attention neural network architecture, which takes into account the embedded meanings of words and their positions in the description, in addition to the relative importance of each word in the vocabulary. We demonstrated superior performance on the public data available on IFTTT and Zapier. We have also developed a neural-symbolic approach for reading comprehension. Specifically, given a question and a passage as the context, instead of directly generating the final answer, our model generates a program for multi-step reasoning, which can be executed to produce the answer. We demonstrated superior performance on reading comprehension benchmarks that require advanced numerical reasoning. We have published related papers at NeurIPS 2016 and ICLR 2020.   Finally, we have studied the effect of training data bias for neural program synthesis. For input-output program synthesis, a common practice for training dataset construction is to randomly generate programs and their corresponding input-output pairs. However, we showed that such type of processes may lead to subtle biases in the distribution of the resulting data, and models trained on such data will fail to work on input-output specifications that fall outside of the distribution. Through more careful generation of the training data, we were able to obtain significant performance improvement on synthesizing programs in Karel language. For our work on If-Then program synthesis, we also considered the few-shot learning scenario, where the test samples may call APIs that do not appear frequently in the training set, and we proposed a 2-step training method to improve the model performance in this more challenging setting. We have published related papers at NeurIPS 2016 and ICLR 2019.        Last Modified: 08/06/2020       Submitted by: Dawn Song]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
