<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF: Medium: Collaborative Research: Sparse Polynomials, Complexity, and Algorithms</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2014</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>250000.00</AwardTotalIntnAmount>
<AwardAmount>250000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Tracy Kimbrel</SignBlockName>
<PO_EMAI>tkimbrel@nsf.gov</PO_EMAI>
<PO_PHON>7032927924</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Solving equations quickly is what gets modern technology off the ground: Transmitting conversations between cellphones, sending data from space-craft back to earth, navigating aircraft, and making robots move correctly, all rely on solving equations quickly. In each setting, the equations have their own personality -- a special structure that we try to take advantage of, in order to find solutions more quickly. In this project, the principle investigators will study equations involving sparse polynomials -- polynomials that have few terms but very high degree.&lt;br/&gt;&lt;br/&gt;But solving equations is more than just calculating quickly -- it also means understanding, and using, computational hardness. For example, classical results in Number Theory and Algebraic Geometry give us specially structured equations that, after centuries of research, still can not be solved quickly. These are the equations that are actually the most useful in Cryptography and complexity theory: Computational hardness can be used to secure sensitive data by forcing an adversary to spend a prohibitively large effort before successfully stealing anything. However, truly understanding hardness is subtle: Every day, codes and cryptosystems are broken because of a missed theoretical detail or a newly discovered backdoor.&lt;br/&gt;&lt;br/&gt;The principal investigators on this project are world experts in Algebraic Geometry, Number Theory, Complexity Theory, and specially structured equations. They bring sophisticated new tools, never used before in Complexity Theory, in order to better classify what kinds of algebraic circuits define intractable equations. Their interdisciplinary approach is well-suited toward attracting mathematically talented students to theoretical Computer Science, Cryptography, and Number Theory.</AbstractNarration>
<MinAmdLetterDate>07/02/2014</MinAmdLetterDate>
<MaxAmdLetterDate>06/17/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1405564</AwardID>
<Investigator>
<FirstName>Daqing</FirstName>
<LastName>Wan</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Daqing Wan</PI_FULL_NAME>
<EmailAddress>dwan@math.uci.edu</EmailAddress>
<PI_PHON>9498247013</PI_PHON>
<NSF_ID>000429800</NSF_ID>
<StartDate>07/02/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Irvine</Name>
<CityName>Irvine</CityName>
<ZipCode>926977600</ZipCode>
<PhoneNumber>9498247295</PhoneNumber>
<StreetAddress>160 Aldrich Hall</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>45</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA45</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>046705849</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CALIFORNIA, IRVINE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Irvine]]></Name>
<CityName>Irvine</CityName>
<StateCode>CA</StateCode>
<ZipCode>926973875</ZipCode>
<StreetAddress><![CDATA[Departmet of Mathematics]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>45</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA45</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7796</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7927</Code>
<Text>COMPLEXITY &amp; CRYPTOGRAPHY</Text>
</ProgramReference>
<ProgramReference>
<Code>7933</Code>
<Text>NUM, SYMBOL, &amp; ALGEBRA COMPUT</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~168829</FUND_OBLG>
<FUND_OBLG>2016~81171</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>One of the most puzzling problems in theoretical computer science, originally posed in 1971, is to determine whether P = NP.&nbsp; That is, to determine whether the complexity class of problems which can be solved in deterministic polynomial time is equivalent to the class of problems whose solutions, if any, can be verified in deterministic polynomial time. <br /><br />All NP-complete problems are equivalent to each other under polynomial time reduction. One approach to proving that P = NP is to find an NP-complete problem and prove (or disprove) that it is deterministically solvable in polynomial time.&nbsp; We choose the subset sum problem over finite fields, which is <br />a classical NP-complete problem. Although this problem is out of reach, our aim&nbsp; is to explore deterministic polynomial time algorithms to this and similar variations of this problem in various interesting special cases with some algebraic strcutures so that powerful mathematical tools can be applied.&nbsp;</p> <p>Our interest in the subset sum problem comes from coding theory, namely, error-correcting codes which are vital in diverse applications such as digital communications. One of the most important classes of codes is the classical Reed-Solomon codes, which are defined using low degree polynomials. A received word with errors will be a higher degree polynomial. The central problem here is the decoding problem, namely, given a received word, compute tits error distance to code words. This naturally leads to the subset sum problem and its generalization callled moment subset sum problem. From mathematical point of views, the key is to study the number of distinct roots of a high degree polynomial when we allow the low degree part to vary.</p> <p>In joint works with collobarators, we showed that for various interesting centers (received words) in a variety of framework, the error distance can be computed quickly or given by a simple formula or non-trivially bounded. In addition to tools from coding theory and computer sciences, we creatively utilized diverse powerful methods from number theory, arithmetic algebraic geometry and combinatorics.&nbsp; This project resulted in 11 research publications, trained three graduate students who recieved their Ph.D. degree (one female) and directed the research of three undergraduate students.</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 12/03/2019<br>      Modified by: Daqing&nbsp;Wan</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ One of the most puzzling problems in theoretical computer science, originally posed in 1971, is to determine whether P = NP.  That is, to determine whether the complexity class of problems which can be solved in deterministic polynomial time is equivalent to the class of problems whose solutions, if any, can be verified in deterministic polynomial time.   All NP-complete problems are equivalent to each other under polynomial time reduction. One approach to proving that P = NP is to find an NP-complete problem and prove (or disprove) that it is deterministically solvable in polynomial time.  We choose the subset sum problem over finite fields, which is  a classical NP-complete problem. Although this problem is out of reach, our aim  is to explore deterministic polynomial time algorithms to this and similar variations of this problem in various interesting special cases with some algebraic strcutures so that powerful mathematical tools can be applied.   Our interest in the subset sum problem comes from coding theory, namely, error-correcting codes which are vital in diverse applications such as digital communications. One of the most important classes of codes is the classical Reed-Solomon codes, which are defined using low degree polynomials. A received word with errors will be a higher degree polynomial. The central problem here is the decoding problem, namely, given a received word, compute tits error distance to code words. This naturally leads to the subset sum problem and its generalization callled moment subset sum problem. From mathematical point of views, the key is to study the number of distinct roots of a high degree polynomial when we allow the low degree part to vary.  In joint works with collobarators, we showed that for various interesting centers (received words) in a variety of framework, the error distance can be computed quickly or given by a simple formula or non-trivially bounded. In addition to tools from coding theory and computer sciences, we creatively utilized diverse powerful methods from number theory, arithmetic algebraic geometry and combinatorics.  This project resulted in 11 research publications, trained three graduate students who recieved their Ph.D. degree (one female) and directed the research of three undergraduate students.             Last Modified: 12/03/2019       Submitted by: Daqing Wan]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
