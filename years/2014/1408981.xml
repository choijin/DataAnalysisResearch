<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Medium: Collaborative Research: Automatic Locality Management for Dynamically Scheduled Parallelism</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/01/2014</AwardEffectiveDate>
<AwardExpirationDate>05/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>236744.00</AwardTotalIntnAmount>
<AwardAmount>236744</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Automatic Locality Management for Dynamically Scheduled Parallelism&lt;br/&gt;&lt;br/&gt;Today's multicore and manycore computers provide increasing amounts of computational power in the form of parallel processing coupled with a complex memory organization with many levels of hierarchy and orders of magnitude difference in cost between accessing different levels. When software exhibits spatial and temporal locality, meaning that it reads and writes memory addresses that are close to one another in relatively small time span, it is able to primarily access data in fast caches, rather than in slow main memory, and deliver good sequential and parallel performance. Unfortunately, with software written in high-level managed programming languages it is difficult to ensure or to predict the amount of spatial and temporal locality, due to the lack of low-level programmer control and the complexities of and interactions between the specific hardware platform and the thread scheduler and the memory manager. This project explores techniques for automatic management of locality in high-level managed programming languages executing on parallel computers with sophisticated memory hierarchies. Using the theoretical models, efficient algorithms, and practical implementations being developed in the project, programmers are able to reason about the expected locality of their programs independent of the target hardware, while a runtime system, including thread scheduler and memory manager, maps the program onto specific hardware to achieve the established performance bounds.&lt;br/&gt;&lt;br/&gt;In particular, this project addresses the problem of automatically managing locality via the runtime system of a high-level garbage-collected parallel functional programming language. A comprehensive approach that considers scheduling, memory allocation, and memory reclamation together is used, allowing the thread scheduler to influence the memory manager and vice versa. A key insight of this research program is to view the allocated data of a program as a hierarchical collection of task- and scheduler-mapped heaps. This view guides the theoretical cost model that enables a programmer to reason about locality at a high-level, the efficient algorithms that control when to create and to garbage collect a heap with provable bounds, and the practical implementation that delivers automatic locality management in a parallel functional programming language. The intellectual merits are advances in understanding the interaction of thread scheduling and memory management with locality on modern parallel hardware, the development of high-level, machine-independent cost model, and a synthesis of programming languages, algorithmic theory, and system design to address the challenges of automatic locality management. The broader impacts are improvements in software quality and programmer productivity, the creation of a parallel functional programming language usable in both education and research, and the integration of results into courses and outreach activities.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>06/03/2014</MinAmdLetterDate>
<MaxAmdLetterDate>03/21/2019</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1408981</AwardID>
<Investigator>
<FirstName>Matthew</FirstName>
<LastName>Fluet</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Matthew Fluet</PI_FULL_NAME>
<EmailAddress>mtf@cs.rit.edu</EmailAddress>
<PI_PHON/>
<NSF_ID>000105569</NSF_ID>
<StartDate>06/03/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Umut</FirstName>
<LastName>Acar</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Umut Acar</PI_FULL_NAME>
<EmailAddress>umut@cs.cmu.edu</EmailAddress>
<PI_PHON>4122689527</PI_PHON>
<NSF_ID>000636864</NSF_ID>
<StartDate>02/26/2019</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Rochester Institute of Tech</Name>
<CityName>ROCHESTER</CityName>
<ZipCode>146235603</ZipCode>
<PhoneNumber>5854757987</PhoneNumber>
<StreetAddress>1 LOMB MEMORIAL DR</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>25</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY25</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>002223642</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>ROCHESTER INSTITUTE OF TECHNOLOGY (INC)</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>002223642</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Rochester Institute of Tech]]></Name>
<CityName>Rochester</CityName>
<StateCode>NY</StateCode>
<ZipCode>146235603</ZipCode>
<StreetAddress><![CDATA[1 Lomb Memorial Drive]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>25</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY25</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~236744</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span id="docs-internal-guid-b72655e1-7fff-82d8-a3e5-e4c2be0b38d7"> </span></p> <p dir="ltr"><span>The major goal of this project has been to develop techniques for automatically managing and exploiting spatial and temporal locality within the run-time system of high-level managed programming languages executing on parallel computers with sophisticated memory hierarchies (SNAPL'15).&nbsp; The project has addressed the problem in the context of a high-level garbage-collected parallel functional programming language using a comprehensive approach that considers scheduling, memory allocation, and memory reclamation together, allowing the thread scheduler to influence the memory manager and vice versa.</span></p> <p dir="ltr"><span>In our primary line of research, we have explored hierarchical garbage collection techniques.&nbsp; The hierarchical garbage collector creates a sub-heap for each created parallel task; these sub-heaps are organized in a tree that mirrors the parent-child relationship between tasks and when a child joins with its parent, its sub-heap is merged into the parent's sub-heap.&nbsp; Only the sub-heaps that correspond to leaves of the tree are active (running tasks are performing allocations).&nbsp; This work has been the main focus of Ph.D. students Ram Raghunathan and Sam Westrick at Carnegie Mellon University.&nbsp; Stefan Muller, another PhD student at Carnegie Mellon, has also contributed.&nbsp; In our initial work (ICFP'16), we focused on pure (mutationless) computations, which naturally maintain the invariant that data in child sub-heaps can reference data in ancestor sub-heaps.&nbsp; This invariant remains valid under load balancing actions by the scheduler without needing to promote or copy data in memory.&nbsp; This property turns out to be key to efficient and scalable parallelism.</span></p> <p dir="ltr"><span>Because data in parent sub-heaps cannot reference data in descendent sub-heaps, any sub-tree of sub-heaps can be independently collected; an important special case is that leaves of the tree can be collected without any coordination or synchronization.&nbsp; Noting that this invariant can be violated in the presence of mutation (crucial for the efficient implementation of imperative algorithms), we turned our attention to the important problem of supporting mutation.&nbsp; We first developed a promotion scheme to maintain the invariants required by the hierarchical garbage collector (PPoPP'18).&nbsp; When a task attempts to update an object in an ancestor's heap with a reference to an object in a descendent's heap, we require the descendent object be promoted to the ancestor's sub-heap, effectively creating a copy of the descendent object as an ancestor object, and the promoted copy is used to perform the update.&nbsp; We demonstrated that our approach has a number of useful properties and performs well.&nbsp; We have also investigated a weaker *disentanglement* invariant (POPL'20).&nbsp; At a high-level, the disentanglement property ensures that a task cannot access memory allocated by a concurrently executing task.&nbsp; Importantly, disentanglement is satisfied by all determinacy-race-free nested-parallel programs (and, consequently, by many real parallel algorithms).&nbsp; But, disentanglement is weaker than race-freedom and allows certain kinds of races (for example, concurrently executing threads can communicate via objects allocated by shared ancestor tasks).&nbsp; We modified the hierarchical garbage collection scheme to take advantage of the disentanglement property and empirically demonstrate that it is efficient and scales well.</span></p> <p dir="ltr"><span>An important aspect of our work has been to develop practical implementations of these memory management techniques.&nbsp; To that end, we have developed MaPLe (MPL), a fork of the MLton Standard ML compiler that supports parallel programs and hierarchical memory management, developed in a public GitHub repository (https://github.com/MPLLang/mpl). Throughout the project, we have made infrastructure improvements to the compiler and runtime system to facilitate current and future research.&nbsp; We have periodically updated the MaPLe compiler source code with respect to the upstream MLton source code, gaining general improvements and bug fixes, and we have also backported some infrastructure changes from the MaPLe compiler source code.&nbsp; The empirical evaluations described above were conducted using the MaPLe compiler.&nbsp; The MaPLe compiler has proven robust enough to be used in the CMU undergraduate algorithms course, with as many as 500 students per year taking the course developed by PIs Acar and Blelloch.</span></p> <p dir="ltr"><span>In a second line of research, we have studied algorithms for scheduling of parallel computations that mix traditional compute-intensive parallelism with interactive tasks, where responsiveness to external requests (from a user or the network) is important and latency is an issue. This line of research has led to the PhD thesis of Stefan Muller at Carnegie Mellon University.&nbsp; We have extended work-stealing scheduling to support latency-hiding (SPAA'16), developed a graph-based cost model for cooperative and competitive threading (PLDI'17), integrated a notion of fairness and developed a fairly prompt scheduling principle that bounds the time by which a low-priority task can be delayed by a high-priority task (ICFP'19), developed the Adaptive Priority Scheduling (APS) algorithm that provides provably efficient response time for tasks at all priority levels (SPAA'20). and developed a type system and cost model for a language with implicit parallelism in the form of prioritized futures and mutable state in the form of references that statically prevents priority inversions (PLDI'20).</span></p> <p>&nbsp;</p><br> <p>            Last Modified: 07/26/2020<br>      Modified by: Matthew&nbsp;Fluet</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[   The major goal of this project has been to develop techniques for automatically managing and exploiting spatial and temporal locality within the run-time system of high-level managed programming languages executing on parallel computers with sophisticated memory hierarchies (SNAPL'15).  The project has addressed the problem in the context of a high-level garbage-collected parallel functional programming language using a comprehensive approach that considers scheduling, memory allocation, and memory reclamation together, allowing the thread scheduler to influence the memory manager and vice versa. In our primary line of research, we have explored hierarchical garbage collection techniques.  The hierarchical garbage collector creates a sub-heap for each created parallel task; these sub-heaps are organized in a tree that mirrors the parent-child relationship between tasks and when a child joins with its parent, its sub-heap is merged into the parent's sub-heap.  Only the sub-heaps that correspond to leaves of the tree are active (running tasks are performing allocations).  This work has been the main focus of Ph.D. students Ram Raghunathan and Sam Westrick at Carnegie Mellon University.  Stefan Muller, another PhD student at Carnegie Mellon, has also contributed.  In our initial work (ICFP'16), we focused on pure (mutationless) computations, which naturally maintain the invariant that data in child sub-heaps can reference data in ancestor sub-heaps.  This invariant remains valid under load balancing actions by the scheduler without needing to promote or copy data in memory.  This property turns out to be key to efficient and scalable parallelism. Because data in parent sub-heaps cannot reference data in descendent sub-heaps, any sub-tree of sub-heaps can be independently collected; an important special case is that leaves of the tree can be collected without any coordination or synchronization.  Noting that this invariant can be violated in the presence of mutation (crucial for the efficient implementation of imperative algorithms), we turned our attention to the important problem of supporting mutation.  We first developed a promotion scheme to maintain the invariants required by the hierarchical garbage collector (PPoPP'18).  When a task attempts to update an object in an ancestor's heap with a reference to an object in a descendent's heap, we require the descendent object be promoted to the ancestor's sub-heap, effectively creating a copy of the descendent object as an ancestor object, and the promoted copy is used to perform the update.  We demonstrated that our approach has a number of useful properties and performs well.  We have also investigated a weaker *disentanglement* invariant (POPL'20).  At a high-level, the disentanglement property ensures that a task cannot access memory allocated by a concurrently executing task.  Importantly, disentanglement is satisfied by all determinacy-race-free nested-parallel programs (and, consequently, by many real parallel algorithms).  But, disentanglement is weaker than race-freedom and allows certain kinds of races (for example, concurrently executing threads can communicate via objects allocated by shared ancestor tasks).  We modified the hierarchical garbage collection scheme to take advantage of the disentanglement property and empirically demonstrate that it is efficient and scales well. An important aspect of our work has been to develop practical implementations of these memory management techniques.  To that end, we have developed MaPLe (MPL), a fork of the MLton Standard ML compiler that supports parallel programs and hierarchical memory management, developed in a public GitHub repository (https://github.com/MPLLang/mpl). Throughout the project, we have made infrastructure improvements to the compiler and runtime system to facilitate current and future research.  We have periodically updated the MaPLe compiler source code with respect to the upstream MLton source code, gaining general improvements and bug fixes, and we have also backported some infrastructure changes from the MaPLe compiler source code.  The empirical evaluations described above were conducted using the MaPLe compiler.  The MaPLe compiler has proven robust enough to be used in the CMU undergraduate algorithms course, with as many as 500 students per year taking the course developed by PIs Acar and Blelloch. In a second line of research, we have studied algorithms for scheduling of parallel computations that mix traditional compute-intensive parallelism with interactive tasks, where responsiveness to external requests (from a user or the network) is important and latency is an issue. This line of research has led to the PhD thesis of Stefan Muller at Carnegie Mellon University.  We have extended work-stealing scheduling to support latency-hiding (SPAA'16), developed a graph-based cost model for cooperative and competitive threading (PLDI'17), integrated a notion of fairness and developed a fairly prompt scheduling principle that bounds the time by which a low-priority task can be delayed by a high-priority task (ICFP'19), developed the Adaptive Priority Scheduling (APS) algorithm that provides provably efficient response time for tasks at all priority levels (SPAA'20). and developed a type system and cost model for a language with implicit parallelism in the form of prioritized futures and mutable state in the form of references that statically prevents priority inversions (PLDI'20).          Last Modified: 07/26/2020       Submitted by: Matthew Fluet]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
