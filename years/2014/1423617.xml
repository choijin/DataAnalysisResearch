<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: SEQUBE: A Sequent Calculus Foundation for High- Level and Intermediate Programming Languages</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2014</AwardEffectiveDate>
<AwardExpirationDate>06/30/2019</AwardExpirationDate>
<AwardTotalIntnAmount>499951.00</AwardTotalIntnAmount>
<AwardAmount>499951</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Title: SHF:Small:SEQUBE:A Sequent Calculus Foundation for High-Level and Intermediate Programming Languages&lt;br/&gt;&lt;br/&gt;Modern programming languages are complex. They provide sophisticated control mechanisms, offer a combination of different programming paradigms (e.g., functional or object-oriented), and allow the definition of infinite objects and processes (e.g., servers or operating systems).  To have assurance in our software, it is fundamentally important to have a simple and intuitive framework for reasoning about and experimenting with programs that use these features: both for programming language designers and implementors, as well as for programmers who need to prove safety properties of critical applications.&lt;br/&gt;&lt;br/&gt;Traditionally, the lambda-calculus has served as a foundation for writing and proving properties of programs. The intellectual merit of this research consists of developing an alternative model of programs based on the sequent calculus.  Instead of starting from a core language and layering features on top as needed, the new model naturally includes these features from the beginning. Like the lambda-calculus, the sequent-based model originates from logic, but is rooted in the concept of duality that provides two ways to approach problems, where one is often more familiar. Additionally, the sequent-based model provides a new way to organize intermediate languages used in compilers to aid program optimization and analysis.&lt;br/&gt;&lt;br/&gt;The broader impact of the research consists of providing a vehicle for disseminating knowledge between different communities. Since the new model includes both the functional and object-oriented paradigms naturally as duals, it provides a logical interpretation of languages, such as Scala, that merge the two approaches. In addition, the research will explore ways to incorporate reasoning about infinite processes and computational effects in a proof assistant. Lastly, an emphasis on duality is beneficial for education; given two possible explanations, students can be introduced to the more familiar one first when introducing difficult ideas, while using existing knowledge and intuition to explore new concepts.</AbstractNarration>
<MinAmdLetterDate>06/13/2014</MinAmdLetterDate>
<MaxAmdLetterDate>06/13/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1423617</AwardID>
<Investigator>
<FirstName>Zena</FirstName>
<LastName>Ariola</LastName>
<PI_MID_INIT>M</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Zena M Ariola</PI_FULL_NAME>
<EmailAddress>ariola@cs.uoregon.edu</EmailAddress>
<PI_PHON>5413464448</PI_PHON>
<NSF_ID>000097717</NSF_ID>
<StartDate>06/13/2014</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Oregon Eugene</Name>
<CityName>Eugene</CityName>
<ZipCode>974035219</ZipCode>
<PhoneNumber>5413465131</PhoneNumber>
<StreetAddress>5219 UNIVERSITY OF OREGON</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Oregon</StateName>
<StateCode>OR</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>OR04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>079289626</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF OREGON</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049793995</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Oregon Eugene]]></Name>
<CityName/>
<StateCode>OR</StateCode>
<ZipCode>974031202</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Oregon</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>OR04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~499951</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span>This work developed tools for reasoning about programs for the purposes of both verification and optimization.&nbsp; These tools are based on a logical system known as the sequent calculus, which brings out the notion of duality in programs and their semantics.&nbsp; One running theme we used to leverage duality in programming languages is in the way that information is constructed and used in a program: "data" is built up according to a predictable schema and processed in many different ways, whereas its dual "codata" is processed according to a predictable interface and generated in many different ways.&nbsp; In practice, we found that functional programming languages have a diversity of data, whereas object-oriented languages instead focus on codata. &nbsp;</span></p> <p><span>For the purpose of verification, we found ways in which duality in the sequent calculus helps in building and checking well-behaved programs.&nbsp; In the field of verification, most reasoning is done by "induction," which covers an infinite number of cases by beginning with the small base cases, and demonstrating how to build larger and larger results.&nbsp; This pattern of inductive reasoning corresponds exactly to the way data is constructed and processed.&nbsp; In contrast, the dual form of reasoning called "coinduction" is useful for modeling processes like servers or interactive systems, but is not nearly as well understood or supported for verification.&nbsp; Through this duality, we found that coinduction corresponds exactly to the way codata is generated and used, and developed a system to bring coinduction to the same level of expressiveness as induction.</span></p> <p><span>Continuing, we found other ways in which the idea of codata can help reasoning about programs.&nbsp; There is a dilemma in functional languages where computational effects (like general recursion) force us to break either the usual semantics or the evaluation method for functions.&nbsp; Changing the semantics of functions means that we have weaker reasoning principles for which programs are equivalent, and changing the evaluation method comes with a higher performance cost.&nbsp; By viewing functions as codata, we developed a new evaluation method that avoids that performance cost while preserving the proper reasoning principles for functions.&nbsp; This idea helps in extending common properties of foundational core languages (in particular "strong normalization" and "confluence" which say that no matter which way a program is run, the program must come to an end and all possible results must be the same, respectively) to more practical settings.&nbsp; This led to a model for programs with a clear notion of "subtyping" as found in object-oriented languages through the relationship between values and contexts.&nbsp; As a result, we were also able to model "intersection" and "union" types, which have interesting applications in compilers, with the full duality expressed in the sequent calculus.</span></p> <p><span>For the purpose of optimization, we investigated the usefulness of sequent-calculus inspired intermediate languages to be used inside of a compiler.&nbsp; We found that one aspect of compilation that the sequent calculus represents well is the notion of a "join point:" after a conditional branch with two different paths, it represents the point at which the control flow joins back together and the rest of the program is now the same no matter which branch was taken.&nbsp; Previously, join points were only present in more low-level compiler intermediate representations like SSA and continuation-passing style.&nbsp; Instead, we used the sequent calculus to lift join points up to a high-level, direct-style representation based on the lambda calculus in a way that maintains all of its existing advantages.&nbsp; This work was integrated into the Glasgow Haskell Compiler, and enabled further optimizations in fusing nested loops in programs.</span></p> <p><span>We also developed a more general way for intermediate languages to manage the impact of evaluation strategy. The notion of "polarity" in logic can be seen as a mixture of two evaluation strategies for programs, known as "call-by-value" and "call-by-name," in such a way that the equalities between programs are maximized.&nbsp; Polarity has the advantage of giving a compiler more flexibility for optimizing programs, and is a good fit for call-by-value languages like OCaml.&nbsp; However, lazy languages like Haskell use a different evaluation strategy, known as "call-by-need," in order to efficiently process delayed computations by sharing their results.&nbsp; We extended a polarized language with call-by-need evaluation, so that the same intermediate language can serve as a compile target for both lazy and strict functional programs.&nbsp; This intermediate language has a handful of core programming structures that are capable of faithfully encoding many features from high-level languages, including: user-defined data and codata, type abstraction in the form of polymorphism and modules, and computational effects.&nbsp; Through the use of duality in the sequent calculus, we were also able to express more low-level operations, like reifying the program call stack as a concrete piece of data that can be inspected and manipulated inside the program.</span></p><br> <p>            Last Modified: 07/28/2019<br>      Modified by: Zena&nbsp;M&nbsp;Ariola</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This work developed tools for reasoning about programs for the purposes of both verification and optimization.  These tools are based on a logical system known as the sequent calculus, which brings out the notion of duality in programs and their semantics.  One running theme we used to leverage duality in programming languages is in the way that information is constructed and used in a program: "data" is built up according to a predictable schema and processed in many different ways, whereas its dual "codata" is processed according to a predictable interface and generated in many different ways.  In practice, we found that functional programming languages have a diversity of data, whereas object-oriented languages instead focus on codata.    For the purpose of verification, we found ways in which duality in the sequent calculus helps in building and checking well-behaved programs.  In the field of verification, most reasoning is done by "induction," which covers an infinite number of cases by beginning with the small base cases, and demonstrating how to build larger and larger results.  This pattern of inductive reasoning corresponds exactly to the way data is constructed and processed.  In contrast, the dual form of reasoning called "coinduction" is useful for modeling processes like servers or interactive systems, but is not nearly as well understood or supported for verification.  Through this duality, we found that coinduction corresponds exactly to the way codata is generated and used, and developed a system to bring coinduction to the same level of expressiveness as induction.  Continuing, we found other ways in which the idea of codata can help reasoning about programs.  There is a dilemma in functional languages where computational effects (like general recursion) force us to break either the usual semantics or the evaluation method for functions.  Changing the semantics of functions means that we have weaker reasoning principles for which programs are equivalent, and changing the evaluation method comes with a higher performance cost.  By viewing functions as codata, we developed a new evaluation method that avoids that performance cost while preserving the proper reasoning principles for functions.  This idea helps in extending common properties of foundational core languages (in particular "strong normalization" and "confluence" which say that no matter which way a program is run, the program must come to an end and all possible results must be the same, respectively) to more practical settings.  This led to a model for programs with a clear notion of "subtyping" as found in object-oriented languages through the relationship between values and contexts.  As a result, we were also able to model "intersection" and "union" types, which have interesting applications in compilers, with the full duality expressed in the sequent calculus.  For the purpose of optimization, we investigated the usefulness of sequent-calculus inspired intermediate languages to be used inside of a compiler.  We found that one aspect of compilation that the sequent calculus represents well is the notion of a "join point:" after a conditional branch with two different paths, it represents the point at which the control flow joins back together and the rest of the program is now the same no matter which branch was taken.  Previously, join points were only present in more low-level compiler intermediate representations like SSA and continuation-passing style.  Instead, we used the sequent calculus to lift join points up to a high-level, direct-style representation based on the lambda calculus in a way that maintains all of its existing advantages.  This work was integrated into the Glasgow Haskell Compiler, and enabled further optimizations in fusing nested loops in programs.  We also developed a more general way for intermediate languages to manage the impact of evaluation strategy. The notion of "polarity" in logic can be seen as a mixture of two evaluation strategies for programs, known as "call-by-value" and "call-by-name," in such a way that the equalities between programs are maximized.  Polarity has the advantage of giving a compiler more flexibility for optimizing programs, and is a good fit for call-by-value languages like OCaml.  However, lazy languages like Haskell use a different evaluation strategy, known as "call-by-need," in order to efficiently process delayed computations by sharing their results.  We extended a polarized language with call-by-need evaluation, so that the same intermediate language can serve as a compile target for both lazy and strict functional programs.  This intermediate language has a handful of core programming structures that are capable of faithfully encoding many features from high-level languages, including: user-defined data and codata, type abstraction in the form of polymorphism and modules, and computational effects.  Through the use of duality in the sequent calculus, we were also able to express more low-level operations, like reifying the program call stack as a concrete piece of data that can be inspected and manipulated inside the program.       Last Modified: 07/28/2019       Submitted by: Zena M Ariola]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
