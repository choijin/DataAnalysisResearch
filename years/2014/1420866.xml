<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:Small: Crash Scene Investigation - Debugging Programs that Fail Unexpectedly</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2014</AwardEffectiveDate>
<AwardExpirationDate>08/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>477833.00</AwardTotalIntnAmount>
<AwardAmount>477833</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Computer systems are pervasive in all aspects of modern society.  The&lt;br/&gt;software running on these systems, however, is difficult to implement&lt;br/&gt;correctly, and many failures occur after software is already released to&lt;br/&gt;the public.  Unfortunately, these "post-deployment" failures are often&lt;br/&gt;the most difficult to fix.  Failing runs are difficult to reproduce and&lt;br/&gt;analyze, as information about these failures is much more difficult and&lt;br/&gt;costly to obtain than failures occurring before software release.  The&lt;br/&gt;PI's research will address this problem by making post-deployment&lt;br/&gt;failures more informative without sacrificing the end-user experience.&lt;br/&gt;&lt;br/&gt;Specifically, the project will tackle this problem on two fronts.  First,&lt;br/&gt;deployed programs will perform low-cost, customizable tracing to enhance&lt;br/&gt;core memory dumps produced by failures.  The project will investigate methods&lt;br/&gt;using both static and dynamic analysis to reduce the cost and improve&lt;br/&gt;the utility of traced information.  Second, the enhanced memory dumps&lt;br/&gt;will require development of powerful new automated postmortem analyses&lt;br/&gt;to partially automate the process of debugging and program&lt;br/&gt;understanding.  These analysis results can then be used to further&lt;br/&gt;inform useful tracing strategies via dynamic feedback from previous&lt;br/&gt;failures.  Thus, information about a particular post-deployment fault&lt;br/&gt;could continually improve as more failures are observed.  This automated&lt;br/&gt;iterative improvement of postmortem analyses has the potential to&lt;br/&gt;substantially reduce effort required to fix post-deployment faults, thus&lt;br/&gt;leading to faster and more accurate patches, resulting in greater&lt;br/&gt;reliability for the software we all rely upon in our daily lives.</AbstractNarration>
<MinAmdLetterDate>08/06/2014</MinAmdLetterDate>
<MaxAmdLetterDate>06/02/2020</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1420866</AwardID>
<Investigator>
<FirstName>Thomas</FirstName>
<LastName>Reps</LastName>
<PI_MID_INIT>W</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Thomas W Reps</PI_FULL_NAME>
<EmailAddress>reps@cs.wisc.edu</EmailAddress>
<PI_PHON>6082622091</PI_PHON>
<NSF_ID>000134593</NSF_ID>
<StartDate>06/02/2020</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Benjamin</FirstName>
<LastName>Liblit</LastName>
<PI_MID_INIT>R</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Benjamin R Liblit</PI_FULL_NAME>
<EmailAddress>liblit@cs.wisc.edu</EmailAddress>
<PI_PHON>6082626617</PI_PHON>
<NSF_ID>000203014</NSF_ID>
<StartDate>08/06/2014</StartDate>
<EndDate>06/02/2020</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Wisconsin-Madison</Name>
<CityName>MADISON</CityName>
<ZipCode>537151218</ZipCode>
<PhoneNumber>6082623822</PhoneNumber>
<StreetAddress>21 North Park Street</StreetAddress>
<StreetAddress2><![CDATA[Suite 6401]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Wisconsin</StateName>
<StateCode>WI</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>WI02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>161202122</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF WISCONSIN SYSTEM</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041188822</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Wisconsin-Madison]]></Name>
<CityName>Madison</CityName>
<StateCode>WI</StateCode>
<ZipCode>537061685</ZipCode>
<StreetAddress><![CDATA[1210 W Dayton St.]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Wisconsin</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>WI02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~477833</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><h1>Lightweight Instrumentation for Postmortem Debugging</h1> <p class="Textbody">We explored strategies for improving debugging using latent information in postmortem core dumps, augmented by lightweight, tunable instrumentation. We also demonstrated pre-debugging uses of this enhanced information, including a unique hybrid program slicing restriction and a reduction of potentially-executed control-flow graph nodes and edges. Experimental evaluation found interprocedural-slice reductions as high as 78%, and active node and edge reductions as high as 71%. Average overheads were merely 1.3% in a realistic debugging configuration. Thus, we provided significant debugging support for negligible cost.</p> <p class="Textbody">We developed CSIclipse, a plugin for the Eclipse IDE that presents analysis data with intuitive source-code overlays and powerful data-exploration mechanisms. Our plugin is likely general enough to support trace data from a variety of program analyses.</p> <p class="Textbody">We investigated the problem of determining whether each statement in a program did or did not execute, given a set of incomplete observations. Our first solution to this problem represents observations as regular languages, and computes intersections over these languages using finite-state acceptors. Our second formulation encodes the problem as a set of Boolean constraints, and uses answer-set programming to solve the constraints.</p> <p class="Textbody">We showed how to give programmers additional information about program activity shortly before failure, using latent information in post-failure memory dumps, augmented by lightweight instrumentation. We demonstrated several potential uses of this enhanced information, including a novel postmortem static-slice-restriction technique and a reduced view of potentially executed code. Experimental evaluation showed our approach to be very effective: our analyses shrank stack-sensitive interprocedural static slices by 53%&ndash;78% in larger applications.</p> <p class="Textbody">We created a system that adapts optimization to customizable coverage requirements. We proved that selecting optimal partial-coverage probes is NP-hard, and we presented a solution based on mixed integer linear programming along with two practical approximation approaches. Our techniques can substantially reduce instrumentation, while allowing the user immense freedom in defining coverage requirements.</p> <p class="Textbody">We also introduced a new subclass of regular languages, the unreliable-trace languages, suitable for answering control-flow queries in polynomial time. We can answer many control-flow queries based on failure data in reasonable time, and pointed to different use cases for our three different solvers that offer different trade-offs among speed, memory, and precision.</p> <p class="Textbody">We have developed alternate MILP formulations that work in concert with aspects of our heuristic alternatives to give provably optimal results with good scaling behavior as well. Beyond serving the goals of our debugging research, these advances&nbsp; may also be of broader interest to the numerical-optimization community.</p> <h1>Fuzzing and Mutation Testing</h1> <p class="Textbody">We created TOFU (for Target-Oriented FUzzer) to provide program fuzzing that targets specific program points of interest. TOFU is also input-structure aware (i.e., the search makes use of a specification of a superset of the program's allowed inputs). Our experiments on xmllint showed that TOFU is 28% faster than AFLGo, while reaching 45% more targets. Moreover, both distance-guided search and exploitation of knowledge of the input structure contributed significantly to TOFU's performance.</p> <p class="Textbody">We also combined TOFU with work on mutation testing to create a tool that uses mutation-testing tools to aid in the process of automatic test-case generation and the automatic construction of entire test suites. Test-suite development often focuses on code coverage, but this strategy has limits. Instead, we attempt to construct stronger test suites through the combination of mutation testing and target-oriented fuzzing. A live mutant provides an example program usable by the engineer to expand the test suite&mdash;so long as the mutant program is semantically different from the original program and an input that kills the mutant can be found to create a new test case.</p> <p class="Textbody">Our goal was to construct both individual test cases, as well as entire test suites. Our strategy to accomplish these goals was to first find live mutants, and then kill them through the application of target-oriented fuzzing. When performed on an individual mutant, a successful application of the technique will yield a test case. When the results of analysis of an entire corpus of mutants are aggregated, the result is a test suite. Our technique can be a powerful tool for an engineer seeking to build a stronger test suite for their project, either by adding individual test cases or generating an entire test suite.</p> <p class="Textbody">Beyond just the generation of test cases, our approach also provides an argument for the inclusion of our generated test cases within a project's test suite. We combine (i) a live mutant from the results of mutation testing with (ii) an input causing the mutant and original program to exhibit different behavior to justify to the engineer that our constructed test case is useful&mdash;not only do we create a new test case, but we provide an example fault detected by the new test case.</p> <p>&nbsp;</p><br> <p>            Last Modified: 10/10/2020<br>      Modified by: Thomas&nbsp;W&nbsp;Reps</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Lightweight Instrumentation for Postmortem Debugging We explored strategies for improving debugging using latent information in postmortem core dumps, augmented by lightweight, tunable instrumentation. We also demonstrated pre-debugging uses of this enhanced information, including a unique hybrid program slicing restriction and a reduction of potentially-executed control-flow graph nodes and edges. Experimental evaluation found interprocedural-slice reductions as high as 78%, and active node and edge reductions as high as 71%. Average overheads were merely 1.3% in a realistic debugging configuration. Thus, we provided significant debugging support for negligible cost. We developed CSIclipse, a plugin for the Eclipse IDE that presents analysis data with intuitive source-code overlays and powerful data-exploration mechanisms. Our plugin is likely general enough to support trace data from a variety of program analyses. We investigated the problem of determining whether each statement in a program did or did not execute, given a set of incomplete observations. Our first solution to this problem represents observations as regular languages, and computes intersections over these languages using finite-state acceptors. Our second formulation encodes the problem as a set of Boolean constraints, and uses answer-set programming to solve the constraints. We showed how to give programmers additional information about program activity shortly before failure, using latent information in post-failure memory dumps, augmented by lightweight instrumentation. We demonstrated several potential uses of this enhanced information, including a novel postmortem static-slice-restriction technique and a reduced view of potentially executed code. Experimental evaluation showed our approach to be very effective: our analyses shrank stack-sensitive interprocedural static slices by 53%&ndash;78% in larger applications. We created a system that adapts optimization to customizable coverage requirements. We proved that selecting optimal partial-coverage probes is NP-hard, and we presented a solution based on mixed integer linear programming along with two practical approximation approaches. Our techniques can substantially reduce instrumentation, while allowing the user immense freedom in defining coverage requirements. We also introduced a new subclass of regular languages, the unreliable-trace languages, suitable for answering control-flow queries in polynomial time. We can answer many control-flow queries based on failure data in reasonable time, and pointed to different use cases for our three different solvers that offer different trade-offs among speed, memory, and precision. We have developed alternate MILP formulations that work in concert with aspects of our heuristic alternatives to give provably optimal results with good scaling behavior as well. Beyond serving the goals of our debugging research, these advances  may also be of broader interest to the numerical-optimization community. Fuzzing and Mutation Testing We created TOFU (for Target-Oriented FUzzer) to provide program fuzzing that targets specific program points of interest. TOFU is also input-structure aware (i.e., the search makes use of a specification of a superset of the program's allowed inputs). Our experiments on xmllint showed that TOFU is 28% faster than AFLGo, while reaching 45% more targets. Moreover, both distance-guided search and exploitation of knowledge of the input structure contributed significantly to TOFU's performance. We also combined TOFU with work on mutation testing to create a tool that uses mutation-testing tools to aid in the process of automatic test-case generation and the automatic construction of entire test suites. Test-suite development often focuses on code coverage, but this strategy has limits. Instead, we attempt to construct stronger test suites through the combination of mutation testing and target-oriented fuzzing. A live mutant provides an example program usable by the engineer to expand the test suite&mdash;so long as the mutant program is semantically different from the original program and an input that kills the mutant can be found to create a new test case. Our goal was to construct both individual test cases, as well as entire test suites. Our strategy to accomplish these goals was to first find live mutants, and then kill them through the application of target-oriented fuzzing. When performed on an individual mutant, a successful application of the technique will yield a test case. When the results of analysis of an entire corpus of mutants are aggregated, the result is a test suite. Our technique can be a powerful tool for an engineer seeking to build a stronger test suite for their project, either by adding individual test cases or generating an entire test suite. Beyond just the generation of test cases, our approach also provides an argument for the inclusion of our generated test cases within a project's test suite. We combine (i) a live mutant from the results of mutation testing with (ii) an input causing the mutant and original program to exhibit different behavior to justify to the engineer that our constructed test case is useful&mdash;not only do we create a new test case, but we provide an example fault detected by the new test case.          Last Modified: 10/10/2020       Submitted by: Thomas W Reps]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
