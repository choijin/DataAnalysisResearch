<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Collaborative Research: Dynamic Invariant Inference, Enhanced</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2009</AwardEffectiveDate>
<AwardExpirationDate>08/31/2012</AwardExpirationDate>
<AwardTotalIntnAmount>167000.00</AwardTotalIntnAmount>
<AwardAmount>183000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>In just a decade, dynamic invariant inference has emerged as one of the most promising directions in program analysis, with a variety of applications. An invariant inference system observes a program during test execution and filters a large number of candidate invariants (i.e., suspected relations between program data), finally reporting only those that hold with high confidence. However, inferred invariants are not always true (they depend on the quality of a test suite), and the few really useful invariants discovered are often accompanied by many more true but trivial and irrelevant facts. This work improves the quality of discovered invariants by ensuring their consistency with facts that are known statically. For instance, even though the invariants describing the behavior of two functions f1 and f2 may be unknown, we may know that any valid input for f1 is also valid for f2. This fact can be incorporated in the inference process to eliminate inconsistent invariants. More generally, the work explores techniques for expressing, discovering, and employing such consistency constraints to improve the quality of produced invariants, from type information and other sources including static analysis and user-supplied annotation.&lt;br/&gt;&lt;br/&gt;The work will impact many aspects of software engineering, including scientific and industrial uses. Concrete benefits will be in the form of publications, usable software (released under an academic open-source license), software prototypes, and educational activities and resources (enhancement of a textbook and current courses, internships for high school students).</AbstractNarration>
<MinAmdLetterDate>07/27/2009</MinAmdLetterDate>
<MaxAmdLetterDate>07/07/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0917391</AwardID>
<Investigator>
<FirstName>Michal</FirstName>
<LastName>Young</LastName>
<PI_MID_INIT>T</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Michal T Young</PI_FULL_NAME>
<EmailAddress>michal@cs.uoregon.edu</EmailAddress>
<PI_PHON>5413464140</PI_PHON>
<NSF_ID>000434200</NSF_ID>
<StartDate>07/27/2009</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Oregon Eugene</Name>
<CityName>Eugene</CityName>
<ZipCode>974035219</ZipCode>
<PhoneNumber>5413465131</PhoneNumber>
<StreetAddress>5219 UNIVERSITY OF OREGON</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Oregon</StateName>
<StateCode>OR</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>OR04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>079289626</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF OREGON</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049793995</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Oregon Eugene]]></Name>
<CityName>Eugene</CityName>
<StateCode>OR</StateCode>
<ZipCode>974035219</ZipCode>
<StreetAddress><![CDATA[5219 UNIVERSITY OF OREGON]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Oregon</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>OR04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>9216</Code>
<Text>ADVANCED SOFTWARE TECH &amp; ALGOR</Text>
</ProgramReference>
<ProgramReference>
<Code>9217</Code>
<Text>NATNL RESERCH &amp; EDUCAT NETWORK</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2009~167000</FUND_OBLG>
<FUND_OBLG>2010~16000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software is as vital to the 21st century as steel was to the 20th. &nbsp;It is fundamental to advances in everything from automobiles to cell phones to drug discovery to emergency response coordination, and leadership in software development is key to economic competitiveness. &nbsp;&nbsp;</p> <p><br />The complexity of software is bounded only by human capacity to understand and control it. &nbsp;Software developers work always near the edge of their ability to tame complexity. A primary goal of much research in software engineering and programming languages is to provide software developers better technical and intellectual tools for ensuring that the complex software structures they construct and assemble conform to the design intent of the developers. &nbsp;Usually this involves both synthetic approaches (partial automation of software construction from specifications of intent) and analytic approaches (automated and partially automated checks of software structure and behavior relative to specified intent, and diagnosis of deviations). &nbsp;Foundational theory of computation tells us that there can never be a complete and infallible solution to the general problem, so advances must leverage and magnify human ingenuity rather than replacing it. Among the levers we can develop are dynamic analysis tools that allow the software developer to sift through enormous volumes of information gathered from program execution to find important facts about those executions. &nbsp;These facts may be used to diagnose a programming error ("bug") or to assess and plan a potential improvement or extension to the software. &nbsp;</p> <p><br />Dynamic invariant detection is a technique for producing observations about relations among internal structures maintained by software. In essence it is simple: Automatically generate a large number of conjectures, then eliminate all of the conjectures that are contradicted by actual observations over several test executions of the software. &nbsp;The conjectures that remain after many checks are "likely invariants", i.e., facts that seem to hold for all the observed executions. Dynamic invariant detection is potentially useful to support a variety of typical software development tasks, including development of good test suites (by noting unintended uniformity in a weak test suite) and assessment and planning of program enhancements. &nbsp;<br />Unfortunately, dynamic invariant detection in its current form produces far too many putative facts about a program, most of which are true but few of which are really useful. &nbsp;The developer who attempts to use dynamic invariant detection to gain a better understanding of software suffers a "needle in a haystack" problem. &nbsp;Our project produces better needles in much smaller haystacks, by making use of explicit abstractions provided by developers. Some of those abstractions are already expressed in some way in the program, typically through organization of the program's data structures &nbsp;as a hierarchical collection of classes. &nbsp;Additional hints about the design intent of the developer --- e.g., that a particular structure is meant to represent a sequence of items in a particular order --- permits us to extract fewer but much richer description of observed "likely invariants" in terms of those abstractions. &nbsp;</p> <p><br />We have constructed a prototype software tool to demonstrate and evaluation this approach to dynamic invariant detection. &nbsp;Our Alembic system allows a developer to specify the abstractions important to him or her, at whatever level of detail seems most useful. &nbsp;Alembic creates a new, instrumented version of the program to be analyzed, gathers observations during program execution, and produces a set of likely invariants for the programmer. &nbsp;Applying Alembic to software from widely used libraries, we have shown that it can radically reduce the v...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Software is as vital to the 21st century as steel was to the 20th.  It is fundamental to advances in everything from automobiles to cell phones to drug discovery to emergency response coordination, and leadership in software development is key to economic competitiveness.      The complexity of software is bounded only by human capacity to understand and control it.  Software developers work always near the edge of their ability to tame complexity. A primary goal of much research in software engineering and programming languages is to provide software developers better technical and intellectual tools for ensuring that the complex software structures they construct and assemble conform to the design intent of the developers.  Usually this involves both synthetic approaches (partial automation of software construction from specifications of intent) and analytic approaches (automated and partially automated checks of software structure and behavior relative to specified intent, and diagnosis of deviations).  Foundational theory of computation tells us that there can never be a complete and infallible solution to the general problem, so advances must leverage and magnify human ingenuity rather than replacing it. Among the levers we can develop are dynamic analysis tools that allow the software developer to sift through enormous volumes of information gathered from program execution to find important facts about those executions.  These facts may be used to diagnose a programming error ("bug") or to assess and plan a potential improvement or extension to the software.     Dynamic invariant detection is a technique for producing observations about relations among internal structures maintained by software. In essence it is simple: Automatically generate a large number of conjectures, then eliminate all of the conjectures that are contradicted by actual observations over several test executions of the software.  The conjectures that remain after many checks are "likely invariants", i.e., facts that seem to hold for all the observed executions. Dynamic invariant detection is potentially useful to support a variety of typical software development tasks, including development of good test suites (by noting unintended uniformity in a weak test suite) and assessment and planning of program enhancements.   Unfortunately, dynamic invariant detection in its current form produces far too many putative facts about a program, most of which are true but few of which are really useful.  The developer who attempts to use dynamic invariant detection to gain a better understanding of software suffers a "needle in a haystack" problem.  Our project produces better needles in much smaller haystacks, by making use of explicit abstractions provided by developers. Some of those abstractions are already expressed in some way in the program, typically through organization of the program's data structures  as a hierarchical collection of classes.  Additional hints about the design intent of the developer --- e.g., that a particular structure is meant to represent a sequence of items in a particular order --- permits us to extract fewer but much richer description of observed "likely invariants" in terms of those abstractions.     We have constructed a prototype software tool to demonstrate and evaluation this approach to dynamic invariant detection.  Our Alembic system allows a developer to specify the abstractions important to him or her, at whatever level of detail seems most useful.  Alembic creates a new, instrumented version of the program to be analyzed, gathers observations during program execution, and produces a set of likely invariants for the programmer.  Applying Alembic to software from widely used libraries, we have shown that it can radically reduce the volume and improve the quality of information presented to the developer, at a very modest cost in effort to specify simple abstractions.        Last Modified: 12/12/2012       Submitted by: ...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
