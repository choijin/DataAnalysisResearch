<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF: Medium: Collaborative Research: Approximate Computational Geometry via Controlled Linear Perturbation</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2009</AwardEffectiveDate>
<AwardExpirationDate>08/31/2013</AwardExpirationDate>
<AwardTotalIntnAmount>300000.00</AwardTotalIntnAmount>
<AwardAmount>308000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Dmitri Maslov</SignBlockName>
<PO_EMAI>dmaslov@nsf.gov</PO_EMAI>
<PO_PHON>7032928910</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The investigators will develop an approximate computational geometry that is algorithm independent, accurate, and fast.  Geometric predicate evaluation and element construction will be performed approximately using floating point arithmetic.  Degeneracy will be handled transparently.  The evaluation and construction techniques will be encapsulated in a software library that will be free for nonprofit use.&lt;br/&gt;&lt;br/&gt;The research challenge is robustness: the output of an approximate algorithm must be correct for a small perturbation of the given input.  This definition extends the numerical analysis definition of a stable algorithm to cover combinatorial error.  Robustness is a fundamental computer science problem that is a major challenge in computational geometry.  The predominant strategy in computational geometry, exact computation using algebraic geometry, has high computational complexity and contradicts the standard scientific and engineering strategy of approximate computation with error bounds.  The investigators will adapt approximate computation to the special needs of computational geometry, which is primarily combinatorial.  This task involves core research at the interface between computational geometry and numerical computing.&lt;br/&gt;&lt;br/&gt;Robust approximate computation will transform how computational geometry is taught, how algorithms are developed and implemented, and how the field interacts with the wider scientific and engineering community.  Introductory courses will present a rigorous, practical robustness theory, instead of treating robustness in an ad hoc, incomplete way.  Programmers will implement real RAM algorithms as stated, using our library to ensure robustness and to handle degeneracy, instead of addressing these problems anew for every algorithm, which is often a major research challenge.  Computational geometry will be available to other disciplines in the form of high-quality software libraries, akin to modern applied mathematics libraries.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>09/03/2009</MinAmdLetterDate>
<MaxAmdLetterDate>05/14/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0904832</AwardID>
<Investigator>
<FirstName>Elisha</FirstName>
<LastName>Sacks</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Elisha Sacks</PI_FULL_NAME>
<EmailAddress>sacks@cs.purdue.edu</EmailAddress>
<PI_PHON>7654946010</PI_PHON>
<NSF_ID>000220105</NSF_ID>
<StartDate>09/03/2009</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Purdue University</Name>
<CityName>West Lafayette</CityName>
<ZipCode>479072114</ZipCode>
<PhoneNumber>7654941055</PhoneNumber>
<StreetAddress>Young Hall</StreetAddress>
<StreetAddress2><![CDATA[155 S Grant Street]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>072051394</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PURDUE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>072051394</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Purdue University]]></Name>
<CityName>West Lafayette</CityName>
<StateCode>IN</StateCode>
<ZipCode>479072114</ZipCode>
<StreetAddress><![CDATA[Young Hall]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7926</Code>
<Text>ALGORITHMS</Text>
</ProgramElement>
<ProgramElement>
<Code>7929</Code>
<Text>COMPUTATIONAL GEOMETRY</Text>
</ProgramElement>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2009~300000</FUND_OBLG>
<FUND_OBLG>2010~8000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Computational geometry is the branch of computer science that develops<br />algorithms for solving geometry problems.&nbsp; The field addresses abstract<br />problems, such as how a set of lines partitions the plane into regions and how a<br />polyhedron can be decomposed into tetrahedrons.&nbsp; Algorithms that solve these<br />problems advance our understanding of the interplay between computing and<br />geometry.&nbsp; Many scientific and engineering problems can be formulated in the<br />language of computational geometry.&nbsp; Examples include planning a safe path for a<br />robot in a cluttered environment, computer-aided design of complex parts using a<br />library of standard shape, and construction of three-dimensional models of<br />tumors from MRI data.<br /><br />We researched the robustness problem: how to convert computational geometry<br />algorithms into reliable, efficient software.&nbsp; Numerical algorithms, including<br />algorithms of computational geometry, are formulated under the simplifying<br />assumptions that real numbers have unit size and real arithmetic takes unit<br />time.&nbsp; The is called the real-RAM model.&nbsp; However, algorithms are implemented<br />using floating point computer arithmetic, which has rounding.&nbsp; The resulting<br />program is accurate and its running time matches the prediction of the real-RAM<br />model.&nbsp; Computational geometry algorithms are atypical because their control<br />logic is expressed using predicates: polynomials whose signs are interpreted as<br />truth values.&nbsp; Although floating point predicate evaluation is accurate, even a<br />small error can make the sign incorrect and thus can cause a large error in the<br />program output.&nbsp; Predicates can be evaluated exactly using integer arithmetic,<br />but this strategy imposes a high overhead in running time and in computer<br />memory.&nbsp; Moreover, a predicate can be degenerate, meaning zero rather than<br />positive or negative.&nbsp; Degeneracy adds special cases to the control logic that<br />are usually ignored by algorithm creators.&nbsp; The software must handle these cases<br />or face erratic failures.<br /><br />We solved the robustness problem by developing a technique for evaluating<br />predicates exactly and efficiently using floating point interval arithmetic.<br />Interval arithmetic is a version of floating point arithmetic that computes an<br />interval of floating point numbers, represented by its two endpoints, that is<br />guaranteed to contain the exact result.&nbsp; We perturb the input parameters to the<br />computational geomtry algorithm.&nbsp; The perturbation eliminates degeneracy by<br />eliminating the coincidental relations among the inputs.&nbsp; We evaluate predicates<br />in floating point interval arithmetic.&nbsp; The result is ambiguous if the interval<br />contains zero, so either sign is consistent with this interval.&nbsp; We remove the<br />ambiguity by increasing the precision of the interval arithmetic, which shrinks<br />the interval.&nbsp; We adaptively increase the precision until the sign is verified.<br />We use an extended precision software library called MPFR because the computer<br />hardware does not directly support arbitrary precision arithmetic.&nbsp; We have<br />proved that the expected overhead of this technique is constant for predicates<br />in the input parameters.<br /><br />As a result of this work, we have been able to implement algorithms that were<br />devised 25 years aga, but until now could not be turned into programs.&nbsp; Visit<br />http://youtu.be/BsCcy0vYerw for a video illustrating an implementation of path<br />planning.<br /><br /></p><br> <p>            Last Modified: 10/25/2013<br>      Modified by: Elisha&nbsp;Sacks</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Computational geometry is the branch of computer science that develops algorithms for solving geometry problems.  The field addresses abstract problems, such as how a set of lines partitions the plane into regions and how a polyhedron can be decomposed into tetrahedrons.  Algorithms that solve these problems advance our understanding of the interplay between computing and geometry.  Many scientific and engineering problems can be formulated in the language of computational geometry.  Examples include planning a safe path for a robot in a cluttered environment, computer-aided design of complex parts using a library of standard shape, and construction of three-dimensional models of tumors from MRI data.  We researched the robustness problem: how to convert computational geometry algorithms into reliable, efficient software.  Numerical algorithms, including algorithms of computational geometry, are formulated under the simplifying assumptions that real numbers have unit size and real arithmetic takes unit time.  The is called the real-RAM model.  However, algorithms are implemented using floating point computer arithmetic, which has rounding.  The resulting program is accurate and its running time matches the prediction of the real-RAM model.  Computational geometry algorithms are atypical because their control logic is expressed using predicates: polynomials whose signs are interpreted as truth values.  Although floating point predicate evaluation is accurate, even a small error can make the sign incorrect and thus can cause a large error in the program output.  Predicates can be evaluated exactly using integer arithmetic, but this strategy imposes a high overhead in running time and in computer memory.  Moreover, a predicate can be degenerate, meaning zero rather than positive or negative.  Degeneracy adds special cases to the control logic that are usually ignored by algorithm creators.  The software must handle these cases or face erratic failures.  We solved the robustness problem by developing a technique for evaluating predicates exactly and efficiently using floating point interval arithmetic. Interval arithmetic is a version of floating point arithmetic that computes an interval of floating point numbers, represented by its two endpoints, that is guaranteed to contain the exact result.  We perturb the input parameters to the computational geomtry algorithm.  The perturbation eliminates degeneracy by eliminating the coincidental relations among the inputs.  We evaluate predicates in floating point interval arithmetic.  The result is ambiguous if the interval contains zero, so either sign is consistent with this interval.  We remove the ambiguity by increasing the precision of the interval arithmetic, which shrinks the interval.  We adaptively increase the precision until the sign is verified. We use an extended precision software library called MPFR because the computer hardware does not directly support arbitrary precision arithmetic.  We have proved that the expected overhead of this technique is constant for predicates in the input parameters.  As a result of this work, we have been able to implement algorithms that were devised 25 years aga, but until now could not be turned into programs.  Visit http://youtu.be/BsCcy0vYerw for a video illustrating an implementation of path planning.         Last Modified: 10/25/2013       Submitted by: Elisha Sacks]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
