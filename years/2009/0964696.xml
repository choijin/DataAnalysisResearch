<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF: Medium:  A Fair Prescription for Partial Synchrony</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/01/2010</AwardEffectiveDate>
<AwardExpirationDate>05/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>737656.00</AwardTotalIntnAmount>
<AwardAmount>889094</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Balasubramanian Kalyanasundaram</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>Partial synchrony refers to computing environments where timing bounds exist for communication delays and processing speeds, but knowledge of these bounds may be limited or unknown. Although such bounds are only implicit, they can still be used to advantage for building reliable distributed systems in the presence of message loss and crashed processors. The central problem however, is how timing parameters for partial synchrony should be modeled, measured, and denominated.&lt;br/&gt;&lt;br/&gt;Since its inception some 25 years ago, the prevailing paradigm of chronometry-based models has invoked real-time as a formal basis for modeling temporal bounds on message delays and process speeds. Unfortunately, such models are intrinsically limited (and even flawed) as descriptions of empirical distributed systems, because the characteristic property of partial synchrony is not chronometric timeliness, but rather chronological fairness.&lt;br/&gt;&lt;br/&gt;This project is developing a fundamental theory of partial synchrony  based on the notion of chronological fairness. The key technical innovation is that system failures can be detected in executions that are unfair, rather than untimely. This approach leads to greater generality because many untimely executions are still fair. Theoretical results codify a hierarchy of fairness properties, including technical limitations, expressivity, and reducibility to oracular models. Practical results extract fairness models from empirical systems. An integrated critique of chronometric models  helps to initiate a broader shift in research trends to focus on fairness-based paradigms of partial synchrony.</AbstractNarration>
<MinAmdLetterDate>05/24/2010</MinAmdLetterDate>
<MaxAmdLetterDate>08/22/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0964696</AwardID>
<Investigator>
<FirstName>Jennifer</FirstName>
<LastName>Welch</LastName>
<PI_MID_INIT>L</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Jennifer L Welch</PI_FULL_NAME>
<EmailAddress>welch@cse.tamu.edu</EmailAddress>
<PI_PHON>9798455076</PI_PHON>
<NSF_ID>000365769</NSF_ID>
<StartDate>05/24/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Scott</FirstName>
<LastName>Pike</LastName>
<PI_MID_INIT>M</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Scott M Pike</PI_FULL_NAME>
<EmailAddress>pike@cse.tamu.edu</EmailAddress>
<PI_PHON>9797762162</PI_PHON>
<NSF_ID>000282987</NSF_ID>
<StartDate>05/24/2010</StartDate>
<EndDate>08/22/2013</EndDate>
<RoleCode>Former Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Texas A&amp;M Engineering Experiment Station</Name>
<CityName>College Station</CityName>
<ZipCode>778454645</ZipCode>
<PhoneNumber>9798626777</PhoneNumber>
<StreetAddress>400 Harvey Mitchell Pkwy S</StreetAddress>
<StreetAddress2><![CDATA[Suite 300]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>17</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX17</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>847205572</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TEXAS A&amp;M ENGINEERING EXPERIMENT STATION</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042915991</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Texas A&amp;M Engineering Experiment Station]]></Name>
<CityName>College Station</CityName>
<StateCode>TX</StateCode>
<ZipCode>778454645</ZipCode>
<StreetAddress><![CDATA[400 Harvey Mitchell Pkwy S]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>17</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX17</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7796</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramElement>
<Code>7934</Code>
<Text>PARAL/DISTRIBUTED ALGORITHMS</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7926</Code>
<Text>ALGORITHMS</Text>
</ProgramReference>
<ProgramReference>
<Code>9102</Code>
<Text>WOMEN, MINORITY, DISABLED, NEC</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~586218</FUND_OBLG>
<FUND_OBLG>2012~151438</FUND_OBLG>
<FUND_OBLG>2013~151438</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Distributed computing systems are all around us, ranging from multiple<br />cores in a cell phone to the Internet itself.&nbsp; Developing software for<br />distributed systems that is correct and efficient is challenging due<br />to complications caused by concurrency, component failures, and<br />variable communication delays.&nbsp; This project takes a principled<br />approach, based on rigorous mathematical reasoning, to find<br />distributed algorithms for some fundamental problems that underlie<br />distributed applications.<br /><br />Most distributed systems are partially synchronous, i.e., they exhibit<br />some level of coordination concerning relative times when the<br />computing processes take steps and how long communication between the<br />processes takes.&nbsp; Partial synchrony has commonly been defined with<br />real time: for example, some event happened at 4:00 and another event<br />happened at 4:10.&nbsp; This project has explored a new approach to<br />defining partial synchrony, using the notion of "fairness": for<br />example, in between two steps of one process, another process takes at<br />most ten steps, regardless of the real times at which these events<br />occur.<br /><br />(1) Systems that are both asynchronous and subject to (undetectable)<br />process crashes make it difficult, and sometimes impossible, for<br />processes to coordinate with each other.&nbsp; A common mechanism for<br />overcoming this obstacle is a system service called a failure<br />detector, which provides processes with some level of information<br />about crashes.&nbsp; We proved that it is sufficient (as well as necessary)<br />for a failure detector mechanism to ensure bounds on the relative<br />occurrences of events, regardless of the real times when these events<br />occur.&nbsp; Our results further the shift in the direction of research on<br />how to construct good failure detectors away from traditional<br />real-time notions, which require knowledge of events outside the<br />system, and towards fairness-based partial synchrony, which can be<br />understood solely with respect to other events that are internal to<br />the system.&nbsp; Our results suggest that fairness is the appropriate way<br />to understand crash tolerance.<br /><br />(2) The "link reversal" approach has been exploited in distributed<br />algorithms for numerous problems, including resource allocation,<br />mutual exclusion, routing, and leader election in the past several<br />decades.&nbsp; In the link reversal approach, a virtual direction is<br />imposed on the link between two processes in the system (modeled as a<br />graph), where the direction indicates which process of the two has<br />precedence to take some action.&nbsp; By reversing the direction of the<br />link, the precedence changes, thus providing some level of fairness to<br />the actions of the processes.&nbsp; Our work provided exact formulas for<br />the work and time performance, as well as tradeoffs between work and<br />time, of two well-known routing algorithms based on link reversal.&nbsp; As<br />a result, we are now able to select which routing algorithm is best<br />depending on the pattern of connections between processes and whether<br />work performance or time performance is more important.<br /><br />(3) Distributed storage, or shared data, is a vital mechanism for<br />communication among processors in distributed systems (for example,<br />note the escalation of cloud computing), and facilitates the<br />development of higher-quality applications.&nbsp; Although shared data is a<br />convenient abstraction, it is not generally provided in large-scale<br />distributed systems.&nbsp; Instead, processors keep individual copies of<br />the data, and communicate by sending messages to keep the replicas<br />consistent.&nbsp; It is known that providing shared objects of many<br />"classic" data types...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Distributed computing systems are all around us, ranging from multiple cores in a cell phone to the Internet itself.  Developing software for distributed systems that is correct and efficient is challenging due to complications caused by concurrency, component failures, and variable communication delays.  This project takes a principled approach, based on rigorous mathematical reasoning, to find distributed algorithms for some fundamental problems that underlie distributed applications.  Most distributed systems are partially synchronous, i.e., they exhibit some level of coordination concerning relative times when the computing processes take steps and how long communication between the processes takes.  Partial synchrony has commonly been defined with real time: for example, some event happened at 4:00 and another event happened at 4:10.  This project has explored a new approach to defining partial synchrony, using the notion of "fairness": for example, in between two steps of one process, another process takes at most ten steps, regardless of the real times at which these events occur.  (1) Systems that are both asynchronous and subject to (undetectable) process crashes make it difficult, and sometimes impossible, for processes to coordinate with each other.  A common mechanism for overcoming this obstacle is a system service called a failure detector, which provides processes with some level of information about crashes.  We proved that it is sufficient (as well as necessary) for a failure detector mechanism to ensure bounds on the relative occurrences of events, regardless of the real times when these events occur.  Our results further the shift in the direction of research on how to construct good failure detectors away from traditional real-time notions, which require knowledge of events outside the system, and towards fairness-based partial synchrony, which can be understood solely with respect to other events that are internal to the system.  Our results suggest that fairness is the appropriate way to understand crash tolerance.  (2) The "link reversal" approach has been exploited in distributed algorithms for numerous problems, including resource allocation, mutual exclusion, routing, and leader election in the past several decades.  In the link reversal approach, a virtual direction is imposed on the link between two processes in the system (modeled as a graph), where the direction indicates which process of the two has precedence to take some action.  By reversing the direction of the link, the precedence changes, thus providing some level of fairness to the actions of the processes.  Our work provided exact formulas for the work and time performance, as well as tradeoffs between work and time, of two well-known routing algorithms based on link reversal.  As a result, we are now able to select which routing algorithm is best depending on the pattern of connections between processes and whether work performance or time performance is more important.  (3) Distributed storage, or shared data, is a vital mechanism for communication among processors in distributed systems (for example, note the escalation of cloud computing), and facilitates the development of higher-quality applications.  Although shared data is a convenient abstraction, it is not generally provided in large-scale distributed systems.  Instead, processors keep individual copies of the data, and communicate by sending messages to keep the replicas consistent.  It is known that providing shared objects of many "classic" data types with strong guarantees on how consistent the data is can be expensive, in particular, the operations on the data can take a long time to complete.  This fact has fueled interest in more relaxed versions of the data types, in the hopes that they can be implemented faster.  Our research provided the first analysis for message-passing implementations of relaxed queues (a common data type), in which an element removed by a dequeue ...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
