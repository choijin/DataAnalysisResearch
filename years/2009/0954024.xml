<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER:  Scalable and Trustworthy Automatic Program Repair</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2010</AwardEffectiveDate>
<AwardExpirationDate>08/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Fixing software bugs is a difficult and time-consuming process, accounting for up to 90% of the lifetime cost of a typical program.  Because the number of defects outstrips the resources available for repairing them, most software is shipped with both known and unknown bugs.  This research builds upon a novel, fully-automated method for repairing bugs in existing software, producing trustworthy repairs for real-world programs. The research will be broadly applicable, targeting large legacy applications with many testcases.&lt;br/&gt;&lt;br/&gt;The technical focus of the work is a scalable and trustworthy technique to automatically repair program bugs. Program variants are evolved, using analogues of biological processes such as mutation, until one is found that both retains required functionality and avoids the defect. Thousands of standard software testcases, program invariants, mined specifications, and "fuzz" inputs are used to represent bugs, encode program requirements, and build trusted repairs. Empirical evaluations include an automated hardening scenario: programs and attacks against them are coevolved over time, simulating parts of the security arms race.  Significant potential outcomes include: a scalable and trustworthy automated program repair methodology and freely available tools; advances in formal program analyses; significant efforts in outreach and education; and dissemination of the results.</AbstractNarration>
<MinAmdLetterDate>02/01/2010</MinAmdLetterDate>
<MaxAmdLetterDate>06/12/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0954024</AwardID>
<Investigator>
<FirstName>Westley</FirstName>
<LastName>Weimer</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Westley Weimer</PI_FULL_NAME>
<EmailAddress>weimerw@umich.edu</EmailAddress>
<PI_PHON>7346159916</PI_PHON>
<NSF_ID>000205470</NSF_ID>
<StartDate>02/01/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Virginia Main Campus</Name>
<CityName>CHARLOTTESVILLE</CityName>
<ZipCode>229044195</ZipCode>
<PhoneNumber>4349244270</PhoneNumber>
<StreetAddress>P.O.  BOX 400195</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Virginia</StateName>
<StateCode>VA</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>VA05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>065391526</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>RECTOR &amp; VISITORS OF THE UNIVERSITY OF VIRGINIA</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>065391526</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Virginia Main Campus]]></Name>
<CityName>CHARLOTTESVILLE</CityName>
<StateCode>VA</StateCode>
<ZipCode>229044195</ZipCode>
<StreetAddress><![CDATA[P.O.  BOX 400195]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Virginia</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>VA05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~79965</FUND_OBLG>
<FUND_OBLG>2011~82869</FUND_OBLG>
<FUND_OBLG>2012~86048</FUND_OBLG>
<FUND_OBLG>2013~74180</FUND_OBLG>
<FUND_OBLG>2014~76938</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This project explored a variety of approaches for automatically repairing buggy programs. Bringing together techniques from software engineering (testing) and evolutionary computation (genetic algorithms), we created algorithms that evolve software patches to fix defects in off-the-shelf, legacy software.<br /><br />Software maintenance is a costly aspect of the software lifecycle, and automated program repair techniques may provide significant benefits in mitigating the cost to fix program defects. Ultimately, this project helped establish automated program repair as an up-and-coming research area in the software engineering community. It also led to a fertile cross-pollination with projects related to n-variant programming and program optimization.<br /><br />There were three primary research thrusts associated with this project:&nbsp; 1) designing automated repair algorithms applicable to real-world software, 2) producing high-quality, human-acceptable program repairs, and 3) carrying out compelling empirical investigation.</p> <p>This project investigated genetic programming and evolutionary techniques for repairing programs. Given a program, an indicative test suite that characterizes its normal behavior, and evidence of a bug, we automatically create a patch that causes the program to retain all required functionality and avoid the bug. We approach this by first localizing the fault: even in large programs, most fixes are dozens of lines long rather than thousands of lines long. Second, we consider modifications to the program: inserting, deleting, or replacing lines of code -- either with code from other places in the same program, or from a library of useful repair templates. Such changes to the program form a candidate patch. We recompile the program using the candidate patch and execute the test suite: we desire patches that pass all of the tests and defeat the bug.<br /><br />We also conducted human studies to capture what humans think of such machine-generated patches. We found that humans consider machine-generated patches to be as maintainable as human-written patches when accompanied by (automatically-generated) documentation. We also carried out large-scale empirical evaluations, culminating in the publication of a dataset of of 1,183 defects for use in the evaluation of program repair techniques. Our approach repairs about 50% of such defects in systems software; addressing more complicated defect scenarios remains an open problem and may warrant further investigation.</p> <p>The work resulting from this project has been well-received by the academic community. The project has generated nine distinguished paper awards among a total of 34 conference papers and 12 journal articles.&nbsp; Top software engineering conferences now often include entirely separate automated repair tracks, and the community has grown to include international Dagstuhl seminars and other scientific gatherings. Our algorithms, implementations, datasets and benchmarks remain available as open-source tools at https://squareslab.github.io/genprog-code/</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/13/2017<br>      Modified by: Westley&nbsp;Weimer</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This project explored a variety of approaches for automatically repairing buggy programs. Bringing together techniques from software engineering (testing) and evolutionary computation (genetic algorithms), we created algorithms that evolve software patches to fix defects in off-the-shelf, legacy software.  Software maintenance is a costly aspect of the software lifecycle, and automated program repair techniques may provide significant benefits in mitigating the cost to fix program defects. Ultimately, this project helped establish automated program repair as an up-and-coming research area in the software engineering community. It also led to a fertile cross-pollination with projects related to n-variant programming and program optimization.  There were three primary research thrusts associated with this project:  1) designing automated repair algorithms applicable to real-world software, 2) producing high-quality, human-acceptable program repairs, and 3) carrying out compelling empirical investigation.  This project investigated genetic programming and evolutionary techniques for repairing programs. Given a program, an indicative test suite that characterizes its normal behavior, and evidence of a bug, we automatically create a patch that causes the program to retain all required functionality and avoid the bug. We approach this by first localizing the fault: even in large programs, most fixes are dozens of lines long rather than thousands of lines long. Second, we consider modifications to the program: inserting, deleting, or replacing lines of code -- either with code from other places in the same program, or from a library of useful repair templates. Such changes to the program form a candidate patch. We recompile the program using the candidate patch and execute the test suite: we desire patches that pass all of the tests and defeat the bug.  We also conducted human studies to capture what humans think of such machine-generated patches. We found that humans consider machine-generated patches to be as maintainable as human-written patches when accompanied by (automatically-generated) documentation. We also carried out large-scale empirical evaluations, culminating in the publication of a dataset of of 1,183 defects for use in the evaluation of program repair techniques. Our approach repairs about 50% of such defects in systems software; addressing more complicated defect scenarios remains an open problem and may warrant further investigation.  The work resulting from this project has been well-received by the academic community. The project has generated nine distinguished paper awards among a total of 34 conference papers and 12 journal articles.  Top software engineering conferences now often include entirely separate automated repair tracks, and the community has grown to include international Dagstuhl seminars and other scientific gatherings. Our algorithms, implementations, datasets and benchmarks remain available as open-source tools at https://squareslab.github.io/genprog-code/             Last Modified: 09/13/2017       Submitted by: Westley Weimer]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
