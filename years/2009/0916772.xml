<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TC: Small: Collaborative Research: Trustworthy Hardware from Certified Behavioral Synthesis</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/15/2009</AwardEffectiveDate>
<AwardExpirationDate>08/31/2013</AwardExpirationDate>
<AwardTotalIntnAmount>249989.00</AwardTotalIntnAmount>
<AwardAmount>249989</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Jeremy Epstein</SignBlockName>
<PO_EMAI>jepstein@nsf.gov</PO_EMAI>
<PO_PHON>7032928338</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Electronic System Level (ESL) designs, specified behaviorally using&lt;br/&gt;high-level languages such as SystemC, raise the level of hardware&lt;br/&gt;design abstraction. This approach crucially depends on behavioral&lt;br/&gt;synthesis, which compiles ESL designs to Register Transfer Level (RTL)&lt;br/&gt;designs. However, optimizations performed by synthesis tools make&lt;br/&gt;their implementation error-prone, undermining the trustworthiness of&lt;br/&gt;synthesized hardware.  &lt;br/&gt;&lt;br/&gt;This research develops a mechanized infrastructure for certifying&lt;br/&gt;hardware designs generated by behavioral synthesis. It entails&lt;br/&gt;developing a certified "reference flow" of synthesis transformations. &lt;br/&gt;The reference flow is disentangled from the workings of a production&lt;br/&gt;synthesis tool through new formal structure called "clocked control&lt;br/&gt;data flow graph" (CCDFG) formalizing internal design representation. &lt;br/&gt;Given an ESL design and its synthesized RTL, certification entails the&lt;br/&gt;following automatic steps: (1) extracting initial CCDFG; (2) applying&lt;br/&gt;certified "primitive transformations" from the reference flow,&lt;br/&gt;following the application sequence by the synthesis tool, and (3)&lt;br/&gt;checking equivalence between the transformed CCDFG and RTL. Theorem&lt;br/&gt;proving is used to certify primitive transformations off-line;&lt;br/&gt;equivalence checking accounts for low-level transformations and&lt;br/&gt;manual tweaks. The correspondence between the transformed CCDFG and&lt;br/&gt;the synthesized hardware makes equivalence checking efficient. &lt;br/&gt;&lt;br/&gt;The project facilitates development of scalable and trustworthy&lt;br/&gt;hardware: adoption of ESL approach expedites design cycle while formal&lt;br/&gt;analysis guarantees trust in the synthesized hardware. The reference&lt;br/&gt;flow makes explicit key design invariants implicitly assumed by&lt;br/&gt;synthesis tools, facilitating development of more aggressive synthesis&lt;br/&gt;tools. Finally, the tight integration of two complementary techniques&lt;br/&gt;--- model checking and theorem proving --- in the certification is&lt;br/&gt;applicable to other domains. &lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>09/18/2009</MinAmdLetterDate>
<MaxAmdLetterDate>08/25/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0916772</AwardID>
<Investigator>
<FirstName>Warren</FirstName>
<LastName>Hunt, Jr.</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Warren A Hunt, Jr.</PI_FULL_NAME>
<EmailAddress>hunt@cs.utexas.edu</EmailAddress>
<PI_PHON>5124719748</PI_PHON>
<NSF_ID>000369883</NSF_ID>
<StartDate>08/25/2012</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Warren</FirstName>
<LastName>Hunt, Jr.</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Warren A Hunt, Jr.</PI_FULL_NAME>
<EmailAddress>hunt@cs.utexas.edu</EmailAddress>
<PI_PHON>5124719748</PI_PHON>
<NSF_ID>000369883</NSF_ID>
<StartDate>09/18/2009</StartDate>
<EndDate>08/25/2012</EndDate>
<RoleCode>Former Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Sandip</FirstName>
<LastName>Ray</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Sandip Ray</PI_FULL_NAME>
<EmailAddress>sandip@ece.ufl.edu</EmailAddress>
<PI_PHON>3523921605</PI_PHON>
<NSF_ID>000082522</NSF_ID>
<StartDate>09/18/2009</StartDate>
<EndDate>08/25/2012</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Texas at Austin</Name>
<CityName>Austin</CityName>
<ZipCode>787595316</ZipCode>
<PhoneNumber>5124716424</PhoneNumber>
<StreetAddress>3925 W Braker Lane, Ste 3.340</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>170230239</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF TEXAS AT AUSTIN</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>042000273</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Texas at Austin]]></Name>
<CityName>Austin</CityName>
<StateCode>TX</StateCode>
<ZipCode>787595316</ZipCode>
<StreetAddress><![CDATA[3925 W Braker Lane, Ste 3.340]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2009~80002</FUND_OBLG>
<FUND_OBLG>2010~169987</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The complexity of computing systems has been increasing steadily, making it infeasible for designers to hand-craft their implementations. &nbsp;It is critical to develop tools that allow designers to specify design functionality at a high abstraction level from which implementation can be automatically synthesized. &nbsp;Behavioral synthesis is one such approach, for hardware systems; behavioral synthesis tools generate hardware implementations (called "RTL") from high-level specifications (called "ESL"). &nbsp;Albeit promising, ESL is not widely adopted. &nbsp;A key reason is the lack of designer's confidence that the synthesized RTL implements the functionality specified in ESL. &nbsp;Since the synthesis tool implements complex transformations, it is prone to errors that can introduce subtle behavior mismatches between ESL and RTL; if detected late, this can cost the producing company millions of dollars, result in costly recall of fabricated hardware, etc.<br />This collaborative project develops an approach for certifying correctness of hardware designs generated through behavioral synthesis. &nbsp;The key outcome is the development of a tool-suite, along with a process (or "flow") for its usage. &nbsp;Given an ESL specification E and a RTL R, if each step of the flow is successfully completed then there is a mathematical guarantee that R indeed implements E. &nbsp;Our flow has certified designs containing tens of thousands of lines of RTL, synthesized by commercial tools. &nbsp;We are not aware of any other technology to achieve certification at this scale.<br />The project develops several innovative solutions, both in technology and methodology, that overcome road-blocks in commercially deploying a certification solution in the commercial context. &nbsp;As an example of methodological road-block, most commercial synthesis tools are closed-source, making it impossible to certify by reviewing or analyzing their implementation; not to mention, the implementation is inordinately complex and likely out-of-reach for most certification tools.<br />Our approach is based on several insights. &nbsp;The first is that while implementations of most behavioral synthesis tools are not open to review or analysis, one can obtain a series of intermediate design representations ("IRs") E1,...,En, generated by the synthesis tool as it transforms an ESL E to RTL R. &nbsp;Furthermore, the structural correspondence between Ei and Ei+1 is typically small; thus one can develop a computer program to certify if they are equivalent. &nbsp;The transformations that destroy structural correspondence are few and hence a custom solution for each is viable. &nbsp;Finally, the IR En is close in abstraction to R, so the equivalence between the two can also be certified by an analysis tool. &nbsp;Thus we developed the following three technical approaches:<br />(1) a tool to check equivalence between closely matching consecutive IRs;<br />(2) a tool to check equivalence between an IR and RTL;<br />(3) an approach for checking equivalence between IRs without structural correspondence.<br />(1) and (2) handle a number of optimizations commonly applied by synthesis tools, e.g., addition of modules implementing power-saving functionality. &nbsp;For (3), suppose a transformation Ei-&gt;Ei+1 destroys structural correspondence. &nbsp;(A typical such transformation is loop pipelining.) &nbsp;Since the transformation implementation is closed-source, we develop our own "reference implementation" (using information available from the synthesis tool to ensure structural similarity with Ei+1), which can take Ei as input and generate some output Ei'. &nbsp;If Ei' is indeed structurally similar to Ei+1, we can check their equivalence. &nbsp;Finally, we employ an interactive reasoning tool, ACL2, to prove mathematically that our reference implementations are correct. &nbsp;ACL2 requires manual effort and a disc...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The complexity of computing systems has been increasing steadily, making it infeasible for designers to hand-craft their implementations.  It is critical to develop tools that allow designers to specify design functionality at a high abstraction level from which implementation can be automatically synthesized.  Behavioral synthesis is one such approach, for hardware systems; behavioral synthesis tools generate hardware implementations (called "RTL") from high-level specifications (called "ESL").  Albeit promising, ESL is not widely adopted.  A key reason is the lack of designer's confidence that the synthesized RTL implements the functionality specified in ESL.  Since the synthesis tool implements complex transformations, it is prone to errors that can introduce subtle behavior mismatches between ESL and RTL; if detected late, this can cost the producing company millions of dollars, result in costly recall of fabricated hardware, etc. This collaborative project develops an approach for certifying correctness of hardware designs generated through behavioral synthesis.  The key outcome is the development of a tool-suite, along with a process (or "flow") for its usage.  Given an ESL specification E and a RTL R, if each step of the flow is successfully completed then there is a mathematical guarantee that R indeed implements E.  Our flow has certified designs containing tens of thousands of lines of RTL, synthesized by commercial tools.  We are not aware of any other technology to achieve certification at this scale. The project develops several innovative solutions, both in technology and methodology, that overcome road-blocks in commercially deploying a certification solution in the commercial context.  As an example of methodological road-block, most commercial synthesis tools are closed-source, making it impossible to certify by reviewing or analyzing their implementation; not to mention, the implementation is inordinately complex and likely out-of-reach for most certification tools. Our approach is based on several insights.  The first is that while implementations of most behavioral synthesis tools are not open to review or analysis, one can obtain a series of intermediate design representations ("IRs") E1,...,En, generated by the synthesis tool as it transforms an ESL E to RTL R.  Furthermore, the structural correspondence between Ei and Ei+1 is typically small; thus one can develop a computer program to certify if they are equivalent.  The transformations that destroy structural correspondence are few and hence a custom solution for each is viable.  Finally, the IR En is close in abstraction to R, so the equivalence between the two can also be certified by an analysis tool.  Thus we developed the following three technical approaches: (1) a tool to check equivalence between closely matching consecutive IRs; (2) a tool to check equivalence between an IR and RTL; (3) an approach for checking equivalence between IRs without structural correspondence. (1) and (2) handle a number of optimizations commonly applied by synthesis tools, e.g., addition of modules implementing power-saving functionality.  For (3), suppose a transformation Ei-&gt;Ei+1 destroys structural correspondence.  (A typical such transformation is loop pipelining.)  Since the transformation implementation is closed-source, we develop our own "reference implementation" (using information available from the synthesis tool to ensure structural similarity with Ei+1), which can take Ei as input and generate some output Ei'.  If Ei' is indeed structurally similar to Ei+1, we can check their equivalence.  Finally, we employ an interactive reasoning tool, ACL2, to prove mathematically that our reference implementations are correct.  ACL2 requires manual effort and a disciplined development of the program being analyzed.  The effort is reasonable since the number of such transformations is small and verification is done off-line once for each transformation.  Our implem...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
