<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Improving Software Assurance Using Transactions</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2010</AwardEffectiveDate>
<AwardExpirationDate>08/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>366722.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>he goal of this CAREER project is to develop novel mechanisms that use&lt;br/&gt;transactions to improve software assurance.  This project is developing&lt;br/&gt;Transactional Memory Introspection---or TMI, which is an approach to &lt;br/&gt;building software security mechanisms by leveraging recent advances in &lt;br/&gt;hardware and software transactional memory. Security mechanisms based &lt;br/&gt;on TMI build upon the same machinery that transactional memory systems &lt;br/&gt;use to ensure performance and functionality. TMI therefore promises to &lt;br/&gt;make security mechanisms efficient and easy to integrate with software.&lt;br/&gt;&lt;br/&gt;TMI-based security mechanisms being researched in this project include:&lt;br/&gt;(1) TxAuth: a reference monitor architecture to better ensure complete&lt;br/&gt;mediation of security-sensitive operations and allow easier integration &lt;br/&gt;with legacy systems;&lt;br/&gt;(2) TxInt: a data structure integrity monitor to protect extensible &lt;br/&gt;software systems, such as operating systems and browsers, from untrusted &lt;br/&gt;extensions; and&lt;br/&gt;(3) TMWatch: a data watchpoint framework that equips malware analysis &lt;br/&gt;tools and debuggers with new capabilities to reverse-engineer malware &lt;br/&gt;behavior.&lt;br/&gt;&lt;br/&gt;More broadly, this project seeks to demonstrate that concurrency control&lt;br/&gt;machinery implemented in transactional memory systems can also be used to &lt;br/&gt;improve software assurance. These additional benefits may lead to more &lt;br/&gt;research on transactions and their ultimate adoption by hardware and &lt;br/&gt;software vendors.  The results from this project are being disseminated &lt;br/&gt;via the development of new course material that will expose students and &lt;br/&gt;software vendors to the dos and don'ts of secure programming. Suitable &lt;br/&gt;course material developed in this project is also being included in &lt;br/&gt;courses targeted towards K-12 and undergraduate students to attract&lt;br/&gt;them to computer science programs.</AbstractNarration>
<MinAmdLetterDate>02/16/2010</MinAmdLetterDate>
<MaxAmdLetterDate>07/18/2014</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0952128</AwardID>
<Investigator>
<FirstName>Vinod</FirstName>
<LastName>Ganapathy</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vinod Ganapathy</PI_FULL_NAME>
<EmailAddress>vinodganapathy@gmail.com</EmailAddress>
<PI_PHON>8484458039</PI_PHON>
<NSF_ID>000502351</NSF_ID>
<StartDate>02/16/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Rutgers University New Brunswick</Name>
<CityName>Piscataway</CityName>
<ZipCode>088543925</ZipCode>
<PhoneNumber>8489320150</PhoneNumber>
<StreetAddress>33 Knightsbridge Road</StreetAddress>
<StreetAddress2><![CDATA[2nd Floor East Wing]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>06</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ06</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001912864</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>RUTGERS, THE STATE UNIVERSITY OF NEW JERSEY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001912864</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Rutgers University New Brunswick]]></Name>
<CityName>Piscataway</CityName>
<StateCode>NJ</StateCode>
<ZipCode>088543925</ZipCode>
<StreetAddress><![CDATA[33 Knightsbridge Road]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>06</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ06</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>1640</Code>
<Text>Information Technology Researc</Text>
</ProgramElement>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~79107</FUND_OBLG>
<FUND_OBLG>2011~92305</FUND_OBLG>
<FUND_OBLG>2012~99036</FUND_OBLG>
<FUND_OBLG>2013~99990</FUND_OBLG>
<FUND_OBLG>2014~29562</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The goal of this project was to investigate how <strong>transactions</strong>&nbsp;may be used to improve software assurance. The concept of transactions has long been a mainstay in the database community, where they provide atomicity, consistency, integrity and durability of changes to the database. More recently, the computer architecture community has begun investigating transactional memory, which aims to bring similar concepts to memory updates and simplify parallel programming. Motivated by this development, this project set out to investigate whether we could leverage or repurpose the machinery provided by transactional memory to improve software assurance. As we worked on various aspects of the project, upon feedback received from the scientific community, we widened our scope and investigated the use of transactions more generally (and not just limited to transactional memory) to improve software assurance.</p> <p>In this public project outcomes report, we discuss three of the main research highlights that came about as a result of this project.</p> <p>In our first thrust, we investigated the use of hardware transactional memory to protect the integrity of OS kernel data structures from malicious or vulnerable device drivers. Device drivers account for a large fraction of crashes on modern systems, and these crashes happen because device drivers write to memory areas that they should not otherwise. In this project, we used transactional memory to ensure that all updates to kernel data structures would happen within transactions. At the end of each transaction, we would examine the log maintained by the transactional memory system, and determine whether the updates to kernel data structures folllow certain integrity specifications, as specified by the programmer. Only those updates that satisfy the integrity specifications are permitted. If the update does not satisfy the specifications, the entire transaction is aborted, thereby leaving the data structure intact.</p> <p>In our second thrust, we studied how enhancing JavaScript with transactions can be used to improve the security of the Web platform. Most Web applications today are extensible, and use third-party extensions (e.g., widgets, libraries, advertisements) to enhance the core application functionality. These third-party extensions run within the same Web sandbox as the original application, and are therefore not isolated by the Same-origin Policy, which is the workhorse of Web security. Thus, malicious third-party extensions and exploits against vulnerable extensions have been used to compromise the confidentiality and integrity of Web applications. In this project, we proposed extending the JavaScript language with a new transaction construct. The idea is that the Web application can use the transaction construct to confine third-party content. All third-party content would execute within the context of a transaction, and at the end of the transaction, the Web application would have the opportunity to review the actions performed by the third-party components. Only actions that do not violate the confidentiality and integrity policies of the hosting Web application will be permitted.</p> <p>Our third thrust was directly motivated by JavaScript transactions. Our initial implementation of JavaScript transactions showed that, while effective at enforcing security policies, the approach imposed a large runtime overhead on Web applications. We therefore adopted an approach that combined static analysis of JavaScript with transactions. JavaScript has a number of dynamic features (e.g., dynamic code generation) that make static analysis of JavaScript code infeasible. However, purely dynamic approaches to JavaScript analysis impose a large runtime performance penalty. In this project, we adopted a "best-effort" static analysis approach, where we statically analyzed extension JavaScript code for policy compliance. In cases where we could not analyze the code statically (e.g., because of the use of dynamic features such as eval), we automatically instrumented the code to place JavaScript transactions. With this approach, we were able to reduce the load time of transaction-enhanced JavaScript pages to under 30ms.</p> <p>Artifacts (prototype code, benchmarks) produced as a result of this project have been made available to other researchers. Links to these artifacts are available from the PI's Web page.</p> <p>&nbsp;</p><br> <p>            Last Modified: 09/26/2016<br>      Modified by: Vinod&nbsp;Ganapathy</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The goal of this project was to investigate how transactions may be used to improve software assurance. The concept of transactions has long been a mainstay in the database community, where they provide atomicity, consistency, integrity and durability of changes to the database. More recently, the computer architecture community has begun investigating transactional memory, which aims to bring similar concepts to memory updates and simplify parallel programming. Motivated by this development, this project set out to investigate whether we could leverage or repurpose the machinery provided by transactional memory to improve software assurance. As we worked on various aspects of the project, upon feedback received from the scientific community, we widened our scope and investigated the use of transactions more generally (and not just limited to transactional memory) to improve software assurance.  In this public project outcomes report, we discuss three of the main research highlights that came about as a result of this project.  In our first thrust, we investigated the use of hardware transactional memory to protect the integrity of OS kernel data structures from malicious or vulnerable device drivers. Device drivers account for a large fraction of crashes on modern systems, and these crashes happen because device drivers write to memory areas that they should not otherwise. In this project, we used transactional memory to ensure that all updates to kernel data structures would happen within transactions. At the end of each transaction, we would examine the log maintained by the transactional memory system, and determine whether the updates to kernel data structures folllow certain integrity specifications, as specified by the programmer. Only those updates that satisfy the integrity specifications are permitted. If the update does not satisfy the specifications, the entire transaction is aborted, thereby leaving the data structure intact.  In our second thrust, we studied how enhancing JavaScript with transactions can be used to improve the security of the Web platform. Most Web applications today are extensible, and use third-party extensions (e.g., widgets, libraries, advertisements) to enhance the core application functionality. These third-party extensions run within the same Web sandbox as the original application, and are therefore not isolated by the Same-origin Policy, which is the workhorse of Web security. Thus, malicious third-party extensions and exploits against vulnerable extensions have been used to compromise the confidentiality and integrity of Web applications. In this project, we proposed extending the JavaScript language with a new transaction construct. The idea is that the Web application can use the transaction construct to confine third-party content. All third-party content would execute within the context of a transaction, and at the end of the transaction, the Web application would have the opportunity to review the actions performed by the third-party components. Only actions that do not violate the confidentiality and integrity policies of the hosting Web application will be permitted.  Our third thrust was directly motivated by JavaScript transactions. Our initial implementation of JavaScript transactions showed that, while effective at enforcing security policies, the approach imposed a large runtime overhead on Web applications. We therefore adopted an approach that combined static analysis of JavaScript with transactions. JavaScript has a number of dynamic features (e.g., dynamic code generation) that make static analysis of JavaScript code infeasible. However, purely dynamic approaches to JavaScript analysis impose a large runtime performance penalty. In this project, we adopted a "best-effort" static analysis approach, where we statically analyzed extension JavaScript code for policy compliance. In cases where we could not analyze the code statically (e.g., because of the use of dynamic features such as eval), we automatically instrumented the code to place JavaScript transactions. With this approach, we were able to reduce the load time of transaction-enhanced JavaScript pages to under 30ms.  Artifacts (prototype code, benchmarks) produced as a result of this project have been made available to other researchers. Links to these artifacts are available from the PI's Web page.          Last Modified: 09/26/2016       Submitted by: Vinod Ganapathy]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
