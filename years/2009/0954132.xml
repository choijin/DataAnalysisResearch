<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Advanced Decision Procedures forWords, Trees and Lists</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>03/15/2010</AwardEffectiveDate>
<AwardExpirationDate>02/28/2017</AwardExpirationDate>
<AwardTotalIntnAmount>499612.00</AwardTotalIntnAmount>
<AwardAmount>499612</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>As complex computer systems become ever more pervasive in our society, especially with the increasing deployment of multi-core processors and clusters of servers in the nation's cyber infrastructure, the demand to advance techniques on program analysis and verification has ever been more intensive. Logic-based reasoning techniques have played a fundamental role in assurance of correctness, reliability and security of computer systems. These techniques divide into two categories: general-purpose theorem proving and specialized decision algorithms. Theorem provers, enjoying a high degree of inference completeness, can prove sophisticated properties but require human guidance in general. On the other hand, decision algorithms, though confined within specialized domains, can automatically discharge a large amount of constraints. It has long been a challenge to combine the merits of the two kinds of techniques to produce a new generation of analysis tools that can handle a wide range of constraints with a high degree of automation. This research is to answer this challenge by building powerful decision theories as well as practical tools for reasoning about high-level data structures that are widely used in advanced programming languages and algorithms. The results would have wide and immediate applications in system analysis, improving the precision and scope of static and runtime analysis techniques.</AbstractNarration>
<MinAmdLetterDate>03/08/2010</MinAmdLetterDate>
<MaxAmdLetterDate>03/22/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0954132</AwardID>
<Investigator>
<FirstName>Gianfranco</FirstName>
<LastName>Ciardo</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Gianfranco Ciardo</PI_FULL_NAME>
<EmailAddress>ciardo@iastate.edu</EmailAddress>
<PI_PHON>5152943264</PI_PHON>
<NSF_ID>000254304</NSF_ID>
<StartDate>01/20/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Andrew</FirstName>
<LastName>Miner</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Andrew Miner</PI_FULL_NAME>
<EmailAddress>asminer@iastate.edu</EmailAddress>
<PI_PHON>5152944377</PI_PHON>
<NSF_ID>000232634</NSF_ID>
<StartDate>01/20/2015</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Samik</FirstName>
<LastName>Basu</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Samik Basu</PI_FULL_NAME>
<EmailAddress>sbasu@cs.iastate.edu</EmailAddress>
<PI_PHON>5152946045</PI_PHON>
<NSF_ID>000150686</NSF_ID>
<StartDate>01/20/2015</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Ting</FirstName>
<LastName>Zhang</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ting Zhang</PI_FULL_NAME>
<EmailAddress>tingz@cs.iastate.edu</EmailAddress>
<PI_PHON>5152942410</PI_PHON>
<NSF_ID>000530685</NSF_ID>
<StartDate>03/08/2010</StartDate>
<EndDate>01/20/2015</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Iowa State University</Name>
<CityName>AMES</CityName>
<ZipCode>500112207</ZipCode>
<PhoneNumber>5152945225</PhoneNumber>
<StreetAddress>1138 Pearson</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Iowa</StateName>
<StateCode>IA</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IA04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>005309844</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>IOWA STATE UNIVERSITY OF SCIENCE AND TECHNOLOGY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>005309844</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Iowa State University]]></Name>
<CityName>AMES</CityName>
<StateCode>IA</StateCode>
<ZipCode>500112207</ZipCode>
<StreetAddress><![CDATA[1138 Pearson]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Iowa</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IA04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>7798</Code>
<Text>SOFTWARE &amp; HARDWARE FOUNDATION</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~200558</FUND_OBLG>
<FUND_OBLG>2012~97020</FUND_OBLG>
<FUND_OBLG>2013~99900</FUND_OBLG>
<FUND_OBLG>2015~102134</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The main goal of the project was to develop algorithms to verify the correctness of complex hardware/software systems.&nbsp; This is an important problem, because design errors or software bugs can be catastrophic.&nbsp; It is also a difficult problem, because the state space (the set of possible states that the system can reach) grows exponentially large, especially for systems described compositionally (i.e., by composing smaller subsystems in a hierarchical manner, which is how complex systems are usually designed).<br /><br />A conceptually simple but practically very time-and-memory-intensive initial analysis step is state-space generation.&nbsp; Once the state space is known, simple properties can be immediately verified (e.g., can the system reach a state where no further progress is possible?).&nbsp; More intricated "temporal logic" queries about complex behaviors (e.g., is it true that the system will always eventually satisfy a high-priority request, even if there many low-priority requests in the queue?) require more specialized "model checking" algorithms, but still are based upon knowledge of the state space. <br /><br />One contribution from this project relates to advanced algorithms based on "decision diagrams" to generate, encode, and operate on very large state spaces.<br /><br />(1) We have improved the efficiency of this data structure by providing several alternatives for storing decision diagram nodes, resulting in lower memory requirements (the main bottleneck in decision diagram algorithms) and reduced runtimes.&nbsp; This allows users of our software library, MEDDLY, and of our tool, SMART, to tackle larger problems.<br /><br />(2) We have developed new algorithms to more efficiently generate the state space and to dynamically change the order of the decision diagram variables.&nbsp; The collection of these variables describes the state of the system, and it is well-known that the order in which they are considered in the decision diagram definition can greatly affect its size, but finding an optimal order is an "NP-hard" problem, so we proposed heuristics that tend to do well but are of course not guaranteed to be optimal.<br /><br />(3) We have designed algorithms than can find minimal "counterexamples" to arbitrarily nested CTL properties (a particular class of temporal logic queries).&nbsp; This is important because, when a model checking tool finds an error, it is not enough to simply raise an alarm; rather, an explanation of what is wrong with the system, in the form of a complex path describing how things can go wrong starting from the initial state, must be provided to the user, who can then debug and fix the system.&nbsp; This counterexample is essentially a sequence of events demonstrating how the undesirable behavior may happen;&nbsp; since this sequence can contain hundreds or even thousands of steps that must be examined manually by the user, it is desirable that the model checking tool provide a short, ideally minimal, counterexample, among the many possible counterexamples.<br /><br />The second class of contributions relates to the analysis of parallel or concurrent software.&nbsp; Most large software systems developed nowadays are multi-threaded (i.e., they contain multiple tasks running in parallel and occasionally interacting, either indirectly by simply writing and reading shared variables, or directly via the exchange of messages.&nbsp; Debugging either class of parallel program is exceedingly difficult because humans are naturally biased towards sequential thinking, while most errors are due to an unforeseen (and rare) interleaving of steps taken in a particularly unfortunate order by two or more otherwise independent tasks.<br /><br />(1) Traditional "concrete"&nbsp; testing is just unable to explore all the possible interactions between parallel tasks, so the likelihood it discovers a rare error is very low.&nbsp; More advanced "symbolic" testing explores all the possible evolutions, so it is in principle able to find all errors; however, in practice, it usually fails because the number of possible combinations for the values of the variables in each task is enormous.&nbsp; So-called "concolic" testing attempts to combine concrete and symbolic approaches, focusing on a concrete execution while symbolically exploring alternates, while employing some technique to exclude executions that appear possible but are not.&nbsp; We defined a similarly light-weight testing approach that focuses on just a single class of errors, failure to terminate, due to the interleaving of multiple tasks.<br /><br />(2) The automated verification of parallel systems where tasks interact via message-passing is undecidable (i.e., no algorithm can exist to answer this question), even if the tasks are represented as finite-state machines, the simplest form of automata.&nbsp; We showed that even just verifying that all messages sent are eventually consumed is undecidable as well.&nbsp; However, we demonstrated a subclass of systems where verification is decidable: those where each task communicates with only one component.&nbsp; This results is important because several systems of practical relevance fall into this subclass.<br /><br /></p><br> <p>            Last Modified: 06/02/2017<br>      Modified by: Gianfranco&nbsp;Ciardo</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The main goal of the project was to develop algorithms to verify the correctness of complex hardware/software systems.  This is an important problem, because design errors or software bugs can be catastrophic.  It is also a difficult problem, because the state space (the set of possible states that the system can reach) grows exponentially large, especially for systems described compositionally (i.e., by composing smaller subsystems in a hierarchical manner, which is how complex systems are usually designed).  A conceptually simple but practically very time-and-memory-intensive initial analysis step is state-space generation.  Once the state space is known, simple properties can be immediately verified (e.g., can the system reach a state where no further progress is possible?).  More intricated "temporal logic" queries about complex behaviors (e.g., is it true that the system will always eventually satisfy a high-priority request, even if there many low-priority requests in the queue?) require more specialized "model checking" algorithms, but still are based upon knowledge of the state space.   One contribution from this project relates to advanced algorithms based on "decision diagrams" to generate, encode, and operate on very large state spaces.  (1) We have improved the efficiency of this data structure by providing several alternatives for storing decision diagram nodes, resulting in lower memory requirements (the main bottleneck in decision diagram algorithms) and reduced runtimes.  This allows users of our software library, MEDDLY, and of our tool, SMART, to tackle larger problems.  (2) We have developed new algorithms to more efficiently generate the state space and to dynamically change the order of the decision diagram variables.  The collection of these variables describes the state of the system, and it is well-known that the order in which they are considered in the decision diagram definition can greatly affect its size, but finding an optimal order is an "NP-hard" problem, so we proposed heuristics that tend to do well but are of course not guaranteed to be optimal.  (3) We have designed algorithms than can find minimal "counterexamples" to arbitrarily nested CTL properties (a particular class of temporal logic queries).  This is important because, when a model checking tool finds an error, it is not enough to simply raise an alarm; rather, an explanation of what is wrong with the system, in the form of a complex path describing how things can go wrong starting from the initial state, must be provided to the user, who can then debug and fix the system.  This counterexample is essentially a sequence of events demonstrating how the undesirable behavior may happen;  since this sequence can contain hundreds or even thousands of steps that must be examined manually by the user, it is desirable that the model checking tool provide a short, ideally minimal, counterexample, among the many possible counterexamples.  The second class of contributions relates to the analysis of parallel or concurrent software.  Most large software systems developed nowadays are multi-threaded (i.e., they contain multiple tasks running in parallel and occasionally interacting, either indirectly by simply writing and reading shared variables, or directly via the exchange of messages.  Debugging either class of parallel program is exceedingly difficult because humans are naturally biased towards sequential thinking, while most errors are due to an unforeseen (and rare) interleaving of steps taken in a particularly unfortunate order by two or more otherwise independent tasks.  (1) Traditional "concrete"  testing is just unable to explore all the possible interactions between parallel tasks, so the likelihood it discovers a rare error is very low.  More advanced "symbolic" testing explores all the possible evolutions, so it is in principle able to find all errors; however, in practice, it usually fails because the number of possible combinations for the values of the variables in each task is enormous.  So-called "concolic" testing attempts to combine concrete and symbolic approaches, focusing on a concrete execution while symbolically exploring alternates, while employing some technique to exclude executions that appear possible but are not.  We defined a similarly light-weight testing approach that focuses on just a single class of errors, failure to terminate, due to the interleaving of multiple tasks.  (2) The automated verification of parallel systems where tasks interact via message-passing is undecidable (i.e., no algorithm can exist to answer this question), even if the tasks are represented as finite-state machines, the simplest form of automata.  We showed that even just verifying that all messages sent are eventually consumed is undecidable as well.  However, we demonstrated a subclass of systems where verification is decidable: those where each task communicates with only one component.  This results is important because several systems of practical relevance fall into this subclass.         Last Modified: 06/02/2017       Submitted by: Gianfranco Ciardo]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
