<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:  Small:  Directed Testing and Debugging of Concurrent Programs</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2010</AwardEffectiveDate>
<AwardExpirationDate>08/31/2014</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The trend towards multicore processors and graphic processing units is increasing the need for software that can take advantage of parallelism and concurrency.  Unfortunately, concurrent programs have proven to be much more difficult to write and debug than sequential software.  This is because concurrent programs often exhibit incorrect behaviors due to unintended interference among multiple threads.  Such concurrency bugs are often difficult to find because they typically happen under very specific thread interleavings.&lt;br/&gt;&lt;br/&gt;Testing and debugging are important phases of the software development process that help to improve software quality, reliability, and safety.  For sequential software, software developers effectively use testing and debugging techniques in practice.  Unfortunately, testing and debugging become notoriously difficult for concurrent programs compared to their sequential counterparts.  This project investigates automated testing and debugging techniques that can not only find bugs in concurrent programs automatically and quickly, but also help to simplify and pinpoint the cause of bugs.  The proposed techniques will combine practical methods, such as testing, and mathematically rigorous techniques, such as model checking and program analysis.  The project will immediately benefit the software industry, where testing and bug fixing consume more than half of the total software development cost.</AbstractNarration>
<MinAmdLetterDate>07/26/2010</MinAmdLetterDate>
<MaxAmdLetterDate>07/26/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1018729</AwardID>
<Investigator>
<FirstName>Koushik</FirstName>
<LastName>Sen</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Koushik Sen</PI_FULL_NAME>
<EmailAddress>ksen@eecs.berkeley.edu</EmailAddress>
<PI_PHON>5106422420</PI_PHON>
<NSF_ID>000490260</NSF_ID>
<StartDate>07/26/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Berkeley</Name>
<CityName>BERKELEY</CityName>
<ZipCode>947101749</ZipCode>
<PhoneNumber>5106433891</PhoneNumber>
<StreetAddress>Sponsored Projects Office</StreetAddress>
<StreetAddress2><![CDATA[1608 Fourth Street, Suite 220]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA13</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>124726725</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Berkeley]]></Name>
<CityName>BERKELEY</CityName>
<StateCode>CA</StateCode>
<ZipCode>947101749</ZipCode>
<StreetAddress><![CDATA[Sponsored Projects Office]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA13</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~400000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><br /><br />In this project, we have developed active testing, a scalableautomated technique for testing concurrent programs. &nbsp;Active testingcombines the power of imprecise program analysis with the precision ofsoftware testing to quickly discover concurrency bugs and to reproducediscovered bugs on demand. The key idea behind active testing is tocontrol the thread scheduler in order to force the program into astate to expose a concurrency bug, e.g. data race, deadlock, atomicityviolation, or violation of sequential memory consistency. Thetechnique starts with lightweight inexpensive dynamic analysis thatidentifies situations where there is suspicion that a concurrency bugmay exist. This first part of the analysis is imprecise because ittrades-off precision for efficiency and it tries to increase thecoverage of analysis by trying to predict potential bugs in otherexecutions by analyzing a single execution. In the second step, adirected tester executes the program under a controlled threadschedule in an attempt to bring the program in the buggy state. If itsucceeds, it has identified a real concurrency bug; that is, the errorreport is guaranteed not be a false alarm, which is a serious problemwith existing dynamic analyses. The actual method of controlling thethread schedule works as follows: once a thread reaches a state thatresembles the desired state, it is paused as long as possible, givinga chance to other threads to catch up and complete the candidate buggyscenario.<br />We have implemented active testing in extensible and publiclyavailable tools for Java, C/PThreads, and have applied these tools tofind many previously-known and unknown concurrency bugs in a number ofprograms, including several real-world applications containing morethan 600K lines of code. Active testing is an effective and practicaltechnique that exposes a simple testing usage model to programmerswhile using sophisticated program analysis under the hood. &nbsp;A paper onthis work won an ACM SIGSOFT Distinguished Paper Award ICSE'09.<br />During this project, we observed that there is a dire lack of boththeoretical and engineering know-how in the area of finding bugs inhybrid or large scale parallel programs. &nbsp;In hybrid programmingmodels, data races occur easily and are notoriously hard tofind. Existing state-of-the-art data race detectors exhibit 10X-100Xperformance degradation and do not handle hybrid parallelism. We havedeveloped the first complete implementation of data race detection,called UPC-Thrille (http://upc.lbl.gov/thrille.shtml), for distributedmemory programs. Our implementation tracks local and global memoryreferences in the program and it uses two techniques to reduce theoverhead: 1) hierarchical function and instruction level sampling; and2) exploiting the runtime persistence of aliasing and localityspecific to Partitioned Global Address Space applications.<br />The results of our experiments with UPC-Thrille indicate that bothtechniques are required in practice: well optimized instructionsampling introduces overheads as high as 6500% (65X slowdown), whileeach technique in separation is able to reduce it only to 1000%(10X). When applying the optimizations in conjunction our tool findsall previously known data races in our benchmark programs with at most50% overhead when running on 2048 cores. Furthermore, while previousresults illustrate the benefits of function level sampling, ourexperiences show that this technique does not work for scientificprograms: instruction sampling or a hybrid approach is required.<br />While developing active testing, we realized that often timesdevelopers have better understanding of their understanding andtesting could benefit if we enable developer to write tests forconcurrent programs. &nbsp;As part of this project, we developed a unit andsystem testing framework for concurrent programs similar to variousunit testing frameworks (e.g. J...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[   In this project, we have developed active testing, a scalableautomated technique for testing concurrent programs.  Active testingcombines the power of imprecise program analysis with the precision ofsoftware testing to quickly discover concurrency bugs and to reproducediscovered bugs on demand. The key idea behind active testing is tocontrol the thread scheduler in order to force the program into astate to expose a concurrency bug, e.g. data race, deadlock, atomicityviolation, or violation of sequential memory consistency. Thetechnique starts with lightweight inexpensive dynamic analysis thatidentifies situations where there is suspicion that a concurrency bugmay exist. This first part of the analysis is imprecise because ittrades-off precision for efficiency and it tries to increase thecoverage of analysis by trying to predict potential bugs in otherexecutions by analyzing a single execution. In the second step, adirected tester executes the program under a controlled threadschedule in an attempt to bring the program in the buggy state. If itsucceeds, it has identified a real concurrency bug; that is, the errorreport is guaranteed not be a false alarm, which is a serious problemwith existing dynamic analyses. The actual method of controlling thethread schedule works as follows: once a thread reaches a state thatresembles the desired state, it is paused as long as possible, givinga chance to other threads to catch up and complete the candidate buggyscenario. We have implemented active testing in extensible and publiclyavailable tools for Java, C/PThreads, and have applied these tools tofind many previously-known and unknown concurrency bugs in a number ofprograms, including several real-world applications containing morethan 600K lines of code. Active testing is an effective and practicaltechnique that exposes a simple testing usage model to programmerswhile using sophisticated program analysis under the hood.  A paper onthis work won an ACM SIGSOFT Distinguished Paper Award ICSE'09. During this project, we observed that there is a dire lack of boththeoretical and engineering know-how in the area of finding bugs inhybrid or large scale parallel programs.  In hybrid programmingmodels, data races occur easily and are notoriously hard tofind. Existing state-of-the-art data race detectors exhibit 10X-100Xperformance degradation and do not handle hybrid parallelism. We havedeveloped the first complete implementation of data race detection,called UPC-Thrille (http://upc.lbl.gov/thrille.shtml), for distributedmemory programs. Our implementation tracks local and global memoryreferences in the program and it uses two techniques to reduce theoverhead: 1) hierarchical function and instruction level sampling; and2) exploiting the runtime persistence of aliasing and localityspecific to Partitioned Global Address Space applications. The results of our experiments with UPC-Thrille indicate that bothtechniques are required in practice: well optimized instructionsampling introduces overheads as high as 6500% (65X slowdown), whileeach technique in separation is able to reduce it only to 1000%(10X). When applying the optimizations in conjunction our tool findsall previously known data races in our benchmark programs with at most50% overhead when running on 2048 cores. Furthermore, while previousresults illustrate the benefits of function level sampling, ourexperiences show that this technique does not work for scientificprograms: instruction sampling or a hybrid approach is required. While developing active testing, we realized that often timesdevelopers have better understanding of their understanding andtesting could benefit if we enable developer to write tests forconcurrent programs.  As part of this project, we developed a unit andsystem testing framework for concurrent programs similar to variousunit testing frameworks (e.g. JUnit, NUnit) for sequential programs.To diagnose and fix a software bug, a programmer often needs to firstreprod...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
