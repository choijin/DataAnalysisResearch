<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Small: A Unified Many-Core Architecture for Enabling Speculative Multithreading and Transactional Memory</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2010</AwardEffectiveDate>
<AwardExpirationDate>07/31/2014</AwardExpirationDate>
<AwardTotalIntnAmount>351831.00</AwardTotalIntnAmount>
<AwardAmount>351831</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>As multi-core and many-core processors are consensually becoming the de facto standard for all types of computing platforms, two techniques, Speculative Multithreading (SpecMT) and Transactional Memory (TM), have been intensively investigated on such platforms to enhance single-thread performance and to simplify the parallel programming model. These two computing models, proposed separately, share many common features in their underlying implementations. In this research, we give a holistic view and investigate a unified many-core architecture to support both technologies under one implementation. We first map SpecMT onto a hardware-based TM architecture and develop enabling techniques to showcase the performance potential while maintaining the benefit of a TM programming model. Each thread spawned speculatively or non-speculatively is transactified into a transaction. Compilers are used to determine when and where to initiate SpecMT with hardware to dynamically shepherd the decisions and throttle the extent of SpecMT. These transactions, executing different code regions, can be launched out of the sequential program order but must be committed in the original order with hardware support. This research focuses on (1) architectural support for enabling both SpecMT and TM, (2) compiler's support for SpecMT and thread transactification, (3) quantifying the benefits of different types of transactions, and (4) economical and feasible mechanisms to support SpecMT on heterogeneous many-core platforms such as the incoming integrated CPU-GPU systems. The success of such a unified many-core architecture will provide a foundation for delivering high performance for single-thread applications while improving the productivity for software developers substantially.</AbstractNarration>
<MinAmdLetterDate>08/02/2010</MinAmdLetterDate>
<MaxAmdLetterDate>08/02/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1017297</AwardID>
<Investigator>
<FirstName>Hsien-Hsin</FirstName>
<LastName>Lee</LastName>
<PI_MID_INIT>S</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Hsien-Hsin S Lee</PI_FULL_NAME>
<EmailAddress>leehs@gatech.edu</EmailAddress>
<PI_PHON>4048949483</PI_PHON>
<NSF_ID>000319030</NSF_ID>
<StartDate>08/02/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Georgia Tech Research Corporation</Name>
<CityName>Atlanta</CityName>
<ZipCode>303320420</ZipCode>
<PhoneNumber>4048944819</PhoneNumber>
<StreetAddress>Office of Sponsored Programs</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Georgia</StateName>
<StateCode>GA</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>GA05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>097394084</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>GEORGIA TECH RESEARCH CORPORATION</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>097394084</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Georgia Tech Research Corporation]]></Name>
<CityName>Atlanta</CityName>
<StateCode>GA</StateCode>
<ZipCode>303320420</ZipCode>
<StreetAddress><![CDATA[Office of Sponsored Programs]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Georgia</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>GA05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~351831</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span style="text-decoration: underline;"><strong>Activity overview</strong></span></p> <p>The research activity of the past year includes the following two msjot subjects</p> <ul> <li>Enabling efficient conflict resolution with Eager Conflict Serialization (EagerCS)</li> <li>3D-stacked DRAM cache analysis for bandwidth-aware management</li> </ul> <p><strong><span style="text-decoration: underline;">Resarch findings</span></strong></p> <p><strong>Enabling efficient conflict resolution with EagerCS: </strong>To evaluate the benefits we can get from our proposed technique, we analyzed the impact of our technique on abort number and execution time. In our simulation, we used McSim simulator with our designed HTM extension and STAMP benchmark suites with standard configurations. McSim is a manycore simulation infrastructure where a timing simulator and a functional simulator are decoupled. We further extend it with HTM support with multiple configurations.</p> <p>We first analyzed the number of aborts with EagarCS. From the result shown, we can see that as an eager HTM system, EagerCS outperforms baseline eager HTM in all benchmarks. The reduction in abort number can be as high as 80% in vacation. Although lazy HTM is showing fewer aborts in some benchmarks, EagerCS can still approach the better one very closely. We then analyzed the execution time comparison between eager HTM, lazy HTM, and EagerCS. We also showed that EagerCS shows better performance than baseline eager HTM in most benchmarks except kmeans. In kmeans, EagerCS takes little longer execution time of 7%. It is because kmeans has high contention rate and the lazy detection for &ldquo;hard&rdquo; cycle brings extra overhead. Lazy HTM as well shows better performance in benchmark genome and intruder. However, our proposed technique can always approach the better one with small margin. We also performed analysis for impact of speculative commit. Also observed was that total number of speculative commits is relatively small and most of them failed the speculation. This is in&nbsp; accord with our intuition that conflict order usually matches commit order</p> <p>These results in our experiments indicated a great potential of reducing aborts and improving performance with our lightweight EagerCS technique. By decoupling detection for different types of cycles, EagerCS makes order model easier and can be implemented with limited hardware and performance overhead. As an eager HTM system, EagerCS can achieve better abort number and performance than baseline eager HTM systems. The abort number reduction can be as high as 80% while the performance improvement can reach as high as 30% depending on the conflict behavior of benchmark programs. When lazy system can achieve better performance, EagerCS also approaches the&nbsp;better method closely.&nbsp;</p> <p><strong>3D-stacked DRAM cache analysis for bandwidth-aware management:</strong> In our experiments, Multi2Sim, a cycle-level x86 simulator is used for performance evaluation. In order to support 3D-stacked DRAM cache, we port DRAMSim2 and integrate it with Multi2Sim. In the simulations, we model an 8 core processor with 2 levels SRAM caches and a L3 DRAM cache. The 3D-stacked DRAM cache has 4 channels with 128 bits bus and 128 MB size. In the experiments, we SPEC CPU2006 benchmark suites and sample 300M instructions using Simpoint. Due to some applications' low sensitivity to memory hierarchy optimizations, we focus on memory intensive benchmarks. In order to reduce simulation time, we work on the same application across all 8 cores.&nbsp;In our work, we first analyzed the bandwidth pressure of DRAM cache. In the experiment, we compared number of DRAM cache Read/Write and actual DRAM cache requests. As shown in Figure 6, the actual number of DRAM cache requests is significantly higher than number of DRAM cache read/write. From the result, we can see that although 3D-stacked DRAM brings higher bandwidth, it also brings higher bandwidth demand.&nbsp; To achieve better DRAM cache performance, we should also consider bandwidth issue in our DRAM cache management policy. Secondly, we analyzed the impact of unnecessary DRAM cache accesses. We performed experiment to measure the impact of reducing requests generated by cache misses. Figure 7 is the reduction rate of DRAM cache queuing delay normalized to baseline system if avoiding all accesses of cache misses. The result shows huge impact on DRAM cache queuing delay. It implies the great performance potential of doing so. To achieve this target,&nbsp;we not only need a cache hit/miss predictor, but also a solution to dirty block issue.</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 10/22/2017<br>      Modified by: Hsien-Hsin&nbsp;S&nbsp;Lee</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Activity overview  The research activity of the past year includes the following two msjot subjects  Enabling efficient conflict resolution with Eager Conflict Serialization (EagerCS) 3D-stacked DRAM cache analysis for bandwidth-aware management   Resarch findings  Enabling efficient conflict resolution with EagerCS: To evaluate the benefits we can get from our proposed technique, we analyzed the impact of our technique on abort number and execution time. In our simulation, we used McSim simulator with our designed HTM extension and STAMP benchmark suites with standard configurations. McSim is a manycore simulation infrastructure where a timing simulator and a functional simulator are decoupled. We further extend it with HTM support with multiple configurations.  We first analyzed the number of aborts with EagarCS. From the result shown, we can see that as an eager HTM system, EagerCS outperforms baseline eager HTM in all benchmarks. The reduction in abort number can be as high as 80% in vacation. Although lazy HTM is showing fewer aborts in some benchmarks, EagerCS can still approach the better one very closely. We then analyzed the execution time comparison between eager HTM, lazy HTM, and EagerCS. We also showed that EagerCS shows better performance than baseline eager HTM in most benchmarks except kmeans. In kmeans, EagerCS takes little longer execution time of 7%. It is because kmeans has high contention rate and the lazy detection for "hard" cycle brings extra overhead. Lazy HTM as well shows better performance in benchmark genome and intruder. However, our proposed technique can always approach the better one with small margin. We also performed analysis for impact of speculative commit. Also observed was that total number of speculative commits is relatively small and most of them failed the speculation. This is in  accord with our intuition that conflict order usually matches commit order  These results in our experiments indicated a great potential of reducing aborts and improving performance with our lightweight EagerCS technique. By decoupling detection for different types of cycles, EagerCS makes order model easier and can be implemented with limited hardware and performance overhead. As an eager HTM system, EagerCS can achieve better abort number and performance than baseline eager HTM systems. The abort number reduction can be as high as 80% while the performance improvement can reach as high as 30% depending on the conflict behavior of benchmark programs. When lazy system can achieve better performance, EagerCS also approaches the better method closely.   3D-stacked DRAM cache analysis for bandwidth-aware management: In our experiments, Multi2Sim, a cycle-level x86 simulator is used for performance evaluation. In order to support 3D-stacked DRAM cache, we port DRAMSim2 and integrate it with Multi2Sim. In the simulations, we model an 8 core processor with 2 levels SRAM caches and a L3 DRAM cache. The 3D-stacked DRAM cache has 4 channels with 128 bits bus and 128 MB size. In the experiments, we SPEC CPU2006 benchmark suites and sample 300M instructions using Simpoint. Due to some applications' low sensitivity to memory hierarchy optimizations, we focus on memory intensive benchmarks. In order to reduce simulation time, we work on the same application across all 8 cores. In our work, we first analyzed the bandwidth pressure of DRAM cache. In the experiment, we compared number of DRAM cache Read/Write and actual DRAM cache requests. As shown in Figure 6, the actual number of DRAM cache requests is significantly higher than number of DRAM cache read/write. From the result, we can see that although 3D-stacked DRAM brings higher bandwidth, it also brings higher bandwidth demand.  To achieve better DRAM cache performance, we should also consider bandwidth issue in our DRAM cache management policy. Secondly, we analyzed the impact of unnecessary DRAM cache accesses. We performed experiment to measure the impact of reducing requests generated by cache misses. Figure 7 is the reduction rate of DRAM cache queuing delay normalized to baseline system if avoiding all accesses of cache misses. The result shows huge impact on DRAM cache queuing delay. It implies the great performance potential of doing so. To achieve this target, we not only need a cache hit/miss predictor, but also a solution to dirty block issue.             Last Modified: 10/22/2017       Submitted by: Hsien-Hsin S Lee]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
