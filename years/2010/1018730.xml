<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Specifying and Verifying Essential Deterministic Behavior of Concurrent Programs</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2010</AwardEffectiveDate>
<AwardExpirationDate>07/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>475356.00</AwardTotalIntnAmount>
<AwardAmount>475356</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Parallel multi-threaded programs are more difficult to write than their sequential counterparts because while writing parallel programs programmers must consider all possible behaviors due to thread interleavings, in addition to the algorithmic correctness of the program.  A widespread belief is that the only way to make multi-threaded programming accessible to a large number of programmers is to come up with programming paradigms and associated tools that explicitly separate reasoning about functional correctness from reasoning about additional behaviors arising due to parallelism.&lt;br/&gt;&lt;br/&gt;This project investigates strategies for separating the parallelization correctness aspect of a program from its functional correctness. First, for most parallel programs it is desired that the non-determinism introduced by the thread scheduler in a parallel program does not change the intended output of the program.  This project will develop an assertion framework for specifying that regions of a parallel program behave deterministically despite non-deterministic thread interleaving.&lt;br/&gt;&lt;br/&gt;The second strategy is based on the observation that a natural step in the development of a parallel program is to first extend the sequential algorithm with a controlled amount of non-determinism, followed by the actual parallelization, when additional non-determinism is introduced by thread interleavings. This project will investigate the use of non-deterministic sequential programs as a specification mechanism, such that for each execution of a parallel program there exists an equivalent execution of the corresponding non-deterministic sequential program. Such non-deterministic sequential programs decouple parallelization correctness from functional correctness.</AbstractNarration>
<MinAmdLetterDate>07/31/2010</MinAmdLetterDate>
<MaxAmdLetterDate>07/31/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1018730</AwardID>
<Investigator>
<FirstName>George</FirstName>
<LastName>Necula</LastName>
<PI_MID_INIT>C</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>George C Necula</PI_FULL_NAME>
<EmailAddress>necula@cs.berkeley.edu</EmailAddress>
<PI_PHON>5106431481</PI_PHON>
<NSF_ID>000215459</NSF_ID>
<StartDate>07/31/2010</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Koushik</FirstName>
<LastName>Sen</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Koushik Sen</PI_FULL_NAME>
<EmailAddress>ksen@eecs.berkeley.edu</EmailAddress>
<PI_PHON>5106422420</PI_PHON>
<NSF_ID>000490260</NSF_ID>
<StartDate>07/31/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Berkeley</Name>
<CityName>BERKELEY</CityName>
<ZipCode>947101749</ZipCode>
<PhoneNumber>5106433891</PhoneNumber>
<StreetAddress>Sponsored Projects Office</StreetAddress>
<StreetAddress2><![CDATA[1608 Fourth Street, Suite 220]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA13</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>124726725</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Berkeley]]></Name>
<CityName>BERKELEY</CityName>
<StateCode>CA</StateCode>
<ZipCode>947101749</ZipCode>
<StreetAddress><![CDATA[Sponsored Projects Office]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA13</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~475356</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Reasoning about multithreaded programs is significantly more difficultthan for sequential programs due to the nondeterministic interleavingof parallel threads. &nbsp;We believe that the only way to tackle thiscomplexity is to find ways to separately specify, test, and reasonabout the correctness of a program's use of parallelism and aprogram's functional correctness. &nbsp;Driven by this belief, we havedeveloped two fundamental techniques for separating theparallelization correctness aspect of a program from the program'ssequential functional correctness.<br />Our first technique is based on the observation that a key simplifyingassumption available to the developer of sequential code is thedeterminism of the execution model. In contrast, parallel programsexhibit nondeterministic behavior due to the interleaving of parallelthreads. This nondeterminism is essential to harness the power ofparallel chips. &nbsp;But programmers often strive to preserve thedeterminism of their applications in the face of thisnondeterminism---that is, to always compute the same output for thesame input, no matter how the parallel threads of execution arescheduled. &nbsp;We argue that programmers should be provided with aframework that will allow them to express the natural, intendeddeterministic behavior of parallel programs directly and easily. Thus,we proposed extending programming languages with constructs forwriting specifications, called bridge assertions, that focus onrelating outcomes of two parallel executions differing only inthread-interleavings [CACM'10,FSE'09,ICSE'10,ASPLOS'11]. &nbsp;We evaluatedthe utility of these assertions by manually adding deterministicspecifications to a number of parallel Java benchmarks. &nbsp;We found itto be fairly easy to specify the correct deterministic behavior of thebenchmark programs using our assertions, despite being unable in mostcases to write traditional invariants or functional correctnessassertions. &nbsp;Our papers on this work won an ACM SIGSOFT DistinguishedPaper Award at [FSE'09] and the 2010 IFIP TC2 Manfred Paul Award forExcellence in Software: Theory and Practice at [ICSE'10]. &nbsp;Ourresearch has been featured in the CACM's Research Highlights[CACM'10].<br />Our second technique, in the same spirit of decomposing ourcorrectness efforts, is suggested by the observation that manuallyparallelized programs often employ algorithms that are different thanthe sequential versions. In some cases, the algorithm itself isnondeterministic. &nbsp;Examples of such nondeterministic algorithmsinclude branch-and-bound algorithms, which may produce multiple validoutputs for the same input. &nbsp;Such algorithmic nondeterminism is oftentightly coupled with the functional correctness of the code, thusviolating the premise of our determinism checking technique. &nbsp;Toaddress these situations, we proposed to separate the reasoning aboutthe algorithmic and the scheduler sources of nondeterminism. &nbsp;For suchcases, we provide a specification technique in which anondeterministic sequential (NDSEQ) version of a parallel program isthe specification for the program's use of parallelism[HotPar'10,PLDI'11]. Using this technique, the programmer expressesthe intended, algorithmic nondeterminism in his or her program---andthe program's parallelism is correct if the nondeterministic threadscheduling adds no additional program behaviors to those of the NDSEQprogram. &nbsp;Testing, debugging, and reasoning about functionalcorrectness can then be performed on the NDSEQ version, withcontrolled nondeterminism but with no interleaving of parallelthreads. &nbsp;We developed an automatic technique [PLDI'11] to testparallelism correctness, by checking that an observed parallelexecution obeys its nondeterministic sequential specification.<br />In the latter part of this project, we focussed on graphical userinterface testing. &nbsp;The goal of this project is to e...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Reasoning about multithreaded programs is significantly more difficultthan for sequential programs due to the nondeterministic interleavingof parallel threads.  We believe that the only way to tackle thiscomplexity is to find ways to separately specify, test, and reasonabout the correctness of a program's use of parallelism and aprogram's functional correctness.  Driven by this belief, we havedeveloped two fundamental techniques for separating theparallelization correctness aspect of a program from the program'ssequential functional correctness. Our first technique is based on the observation that a key simplifyingassumption available to the developer of sequential code is thedeterminism of the execution model. In contrast, parallel programsexhibit nondeterministic behavior due to the interleaving of parallelthreads. This nondeterminism is essential to harness the power ofparallel chips.  But programmers often strive to preserve thedeterminism of their applications in the face of thisnondeterminism---that is, to always compute the same output for thesame input, no matter how the parallel threads of execution arescheduled.  We argue that programmers should be provided with aframework that will allow them to express the natural, intendeddeterministic behavior of parallel programs directly and easily. Thus,we proposed extending programming languages with constructs forwriting specifications, called bridge assertions, that focus onrelating outcomes of two parallel executions differing only inthread-interleavings [CACM'10,FSE'09,ICSE'10,ASPLOS'11].  We evaluatedthe utility of these assertions by manually adding deterministicspecifications to a number of parallel Java benchmarks.  We found itto be fairly easy to specify the correct deterministic behavior of thebenchmark programs using our assertions, despite being unable in mostcases to write traditional invariants or functional correctnessassertions.  Our papers on this work won an ACM SIGSOFT DistinguishedPaper Award at [FSE'09] and the 2010 IFIP TC2 Manfred Paul Award forExcellence in Software: Theory and Practice at [ICSE'10].  Ourresearch has been featured in the CACM's Research Highlights[CACM'10]. Our second technique, in the same spirit of decomposing ourcorrectness efforts, is suggested by the observation that manuallyparallelized programs often employ algorithms that are different thanthe sequential versions. In some cases, the algorithm itself isnondeterministic.  Examples of such nondeterministic algorithmsinclude branch-and-bound algorithms, which may produce multiple validoutputs for the same input.  Such algorithmic nondeterminism is oftentightly coupled with the functional correctness of the code, thusviolating the premise of our determinism checking technique.  Toaddress these situations, we proposed to separate the reasoning aboutthe algorithmic and the scheduler sources of nondeterminism.  For suchcases, we provide a specification technique in which anondeterministic sequential (NDSEQ) version of a parallel program isthe specification for the program's use of parallelism[HotPar'10,PLDI'11]. Using this technique, the programmer expressesthe intended, algorithmic nondeterminism in his or her program---andthe program's parallelism is correct if the nondeterministic threadscheduling adds no additional program behaviors to those of the NDSEQprogram.  Testing, debugging, and reasoning about functionalcorrectness can then be performed on the NDSEQ version, withcontrolled nondeterminism but with no interleaving of parallelthreads.  We developed an automatic technique [PLDI'11] to testparallelism correctness, by checking that an observed parallelexecution obeys its nondeterministic sequential specification. In the latter part of this project, we focussed on graphical userinterface testing.  The goal of this project is to effectively andefficiently test mobile applications having rich graphical userinterfaces (GUIs).  Smartphones and tablets with rich graphical userinterfa...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
