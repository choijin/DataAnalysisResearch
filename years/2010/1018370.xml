<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF:  Small:  Understanding Fudnamental Data Structures</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2010</AwardEffectiveDate>
<AwardExpirationDate>06/30/2014</AwardExpirationDate>
<AwardTotalIntnAmount>393443.00</AwardTotalIntnAmount>
<AwardAmount>393443</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Tracy Kimbrel</SignBlockName>
<PO_EMAI>tkimbrel@nsf.gov</PO_EMAI>
<PO_PHON>7032927924</PO_PHON>
</ProgramOfficer>
<AbstractNarration>The need to efficiently store and access data is central to modern computing, and the design and analysis of methods to store and access data constitutes the field of data structures. This project will investigate the discovery of provably best data structures for several fundamental problems, including the dictionary and the priority queue. The dictionary supports the efficient insertion, deletion, and search of ordered data. The priority queue supports insertion and the removal of the minimum element.&lt;br/&gt;&lt;br/&gt;Data structures will be designed and analyzed under the paradigm of instance-based optimality. In this model, a data structure's performance on a sequence of operations is evaluated based on how well it compares to the speed of the best structure for that sequence among a naturally-defined class of structures. The classes of structures that will be examined include binary search trees and heaps. Binary search trees and heaps are arguably the most fundamental nontrivial classes of data structures in computer science. Despite their origins at the dawn of computing, a complete understanding of these classes of structures has remained elusive to this day.&lt;br/&gt;&lt;br/&gt;Other operations on fundamental data structures will be investigated. The ability to decrease the value of an item in a heap is vital to some algorithms, notably Dijkstra's algorithm for finding single-source shortest paths in a graph. Yet, it is not completely understood what types of structures can support this operation efficiently. Also, there is no known efficient method to support the splitting and merging of dictionaries; one goal of this project is to design a comparison-based dictionary do this in amortized logarithmic time.</AbstractNarration>
<MinAmdLetterDate>06/28/2010</MinAmdLetterDate>
<MaxAmdLetterDate>06/28/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1018370</AwardID>
<Investigator>
<FirstName>John</FirstName>
<LastName>Iacono</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>John Iacono</PI_FULL_NAME>
<EmailAddress>iacono@nyu.edu</EmailAddress>
<PI_PHON>7182603949</PI_PHON>
<NSF_ID>000211077</NSF_ID>
<StartDate>06/28/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>New York University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100121019</ZipCode>
<PhoneNumber>2129982121</PhoneNumber>
<StreetAddress>70 WASHINGTON SQUARE S</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>041968306</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>NEW YORK UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041968306</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[New York University]]></Name>
<CityName>NEW YORK</CityName>
<StateCode>NY</StateCode>
<ZipCode>100121019</ZipCode>
<StreetAddress><![CDATA[70 WASHINGTON SQUARE S]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7926</Code>
<Text>ALGORITHMS</Text>
</ProgramElement>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~393443</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span id="docs-internal-guid-bd5dadd9-e839-67c2-2610-cba7a4363a93"> <p dir="ltr"><span>The need to efficiently store and access data is central to modern computing, and the design and analysis of methods to store and access data constitutes the field of data structures. This project investigated the discovery of provably best data structures for several fundamental problems, including the dictionary and the priority queue. The dictionary supports the efficient insertion, deletion, and search of ordered data. The priority queue supports insertion and the removal of the minimum element. </span></p> <br /> <p dir="ltr"><span>Binary search trees are one of the fundamental dictionary data structures in computer science, are part of virtually all computing libraries, and are typically one of the first non-trivial structures taught to undergraduates. We discovered a new way of viewing a binary search tree as a simple two-dimensional geometric problem. This new view gave clarity to how binary search trees work, and allowed a simple restatement of many previous results.</span></p> <br /><span>We invented a new method for handling insertions into data structures stored on external memory. This general idea led to two concrete structures, the first was a data structure for hashing in the external memory model. Depending on the exact choice of parameters for memory size, block size, and amount of data, our structure is up to exponentially better than previous ones, and is provably tight in many cases. It is intellectually interesting as it does not store keys as atomic units but rather chops them up and stores varying-sized pieces in different places, surpassing bounds which require indivisibility of keys. Secondly, we also invented a data structure for with the best-possible insertion/deletion time in the cache-oblivious model.</span></span></p> <p>&nbsp;</p><br> <p>            Last Modified: 06/12/2015<br>      Modified by: John&nbsp;Iacono</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  The need to efficiently store and access data is central to modern computing, and the design and analysis of methods to store and access data constitutes the field of data structures. This project investigated the discovery of provably best data structures for several fundamental problems, including the dictionary and the priority queue. The dictionary supports the efficient insertion, deletion, and search of ordered data. The priority queue supports insertion and the removal of the minimum element.    Binary search trees are one of the fundamental dictionary data structures in computer science, are part of virtually all computing libraries, and are typically one of the first non-trivial structures taught to undergraduates. We discovered a new way of viewing a binary search tree as a simple two-dimensional geometric problem. This new view gave clarity to how binary search trees work, and allowed a simple restatement of many previous results.  We invented a new method for handling insertions into data structures stored on external memory. This general idea led to two concrete structures, the first was a data structure for hashing in the external memory model. Depending on the exact choice of parameters for memory size, block size, and amount of data, our structure is up to exponentially better than previous ones, and is provably tight in many cases. It is intellectually interesting as it does not store keys as atomic units but rather chops them up and stores varying-sized pieces in different places, surpassing bounds which require indivisibility of keys. Secondly, we also invented a data structure for with the best-possible insertion/deletion time in the cache-oblivious model.          Last Modified: 06/12/2015       Submitted by: John Iacono]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
