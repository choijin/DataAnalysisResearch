<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF: Small: Long-time coherence protection via dynamical decoupling and encoded control</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/15/2010</AwardEffectiveDate>
<AwardExpirationDate>07/31/2014</AwardExpirationDate>
<AwardTotalIntnAmount>448911.00</AwardTotalIntnAmount>
<AwardAmount>448911</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Dmitri Maslov</SignBlockName>
<PO_EMAI>dmaslov@nsf.gov</PO_EMAI>
<PO_PHON>7032928910</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This award targets the study of the theory of qubit coherence protection combining passive (dynamical decoupling) and active (quantum error correction) techniques. The dynamical decoupling is very frugal as it does not require any additional qubits to work; it will be used at the level of physical qubits as the first stage of coherence protection. For several solid-state qubit implementations, this may suppress the decoherence rate to be dealt with by the quantum error correction by an order of magnitude or more, thus dramatically reducing the hardware requirements. The PI plans to analyze the effectiveness of such a combined coherence protection scheme over long time intervals, when compared to the correlation time of the environment using both analytical and numerical techniques.</AbstractNarration>
<MinAmdLetterDate>08/05/2010</MinAmdLetterDate>
<MaxAmdLetterDate>08/05/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1018935</AwardID>
<Investigator>
<FirstName>Leonid</FirstName>
<LastName>Pryadko</LastName>
<PI_MID_INIT>P</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Leonid P Pryadko</PI_FULL_NAME>
<EmailAddress>leonid.pryadko@ucr.edu</EmailAddress>
<PI_PHON>9518275644</PI_PHON>
<NSF_ID>000490981</NSF_ID>
<StartDate>08/05/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Riverside</Name>
<CityName>RIVERSIDE</CityName>
<ZipCode>925210217</ZipCode>
<PhoneNumber>9518275535</PhoneNumber>
<StreetAddress>Research &amp; Economic Development</StreetAddress>
<StreetAddress2><![CDATA[245 University Office Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>44</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA44</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>627797426</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>REGENTS OF THE UNIVERSITY OF CALIFORNIA AT RIVERSIDE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Riverside]]></Name>
<CityName>RIVERSIDE</CityName>
<StateCode>CA</StateCode>
<ZipCode>925210217</ZipCode>
<StreetAddress><![CDATA[Research &amp; Economic Developm]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>44</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA44</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7928</Code>
<Text>Quantum Computing</Text>
</ProgramElement>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~448911</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><strong>Fault-tolerance of quantum LDPC codes with power-law distance<br /></strong></p> <p>This is the most important result of the supported research.</p> <p>Technically, quantum LDPC codes are just stabilizer codes, but with stabilizer generators (operators to be measured at each error correction cycle) involving only a few qubits each compared to the number of qubits used in the code. Such codes are most often degenerate: some errors have trivial effect and do not require any correction. Compared to general quantum codes, with a quantum LDPC code, each quantum measurement involves fewer qubits, measurements can be done in parallel, and also the classical processing could potentially be enormously simplified.</p> <p>The most famous family of quantum LDPC codes is Kitaev&rsquo;s toric construction: it has a relatively high threshold for scalable quantum computation, around 1% total error probability per quantum gate or a qubit measurement, and only local gates are needed. One disadvantage is that all toric and related surface codes encode very few qubits (in technical terms, they have asymptotically zero rate); thus they require many redundant physical qubits.</p> <p>Finite-rate quantum LDPC codes are also possible. Several large families of such codes are known. An apparent disadvantage is that all known families of quantum LDPC codes have distance scaling like a power law of the number of qubits involved in the code. This means that some errors spanning a vanishing fraction of qubits in a large code are uncorrectable.</p> <p>Using techniques from percolation theory, we established[1] that, in fact, uncorrectable errors are exponentially rare. It follows that below certain threshold error rate, known quantum LDPC codes can protect an arbitrarily large quantum computation. This is the only class of codes where a finite fault-tolerant error correction threshold and a finite rate are known to coexist. Previously, existence of a finite fault-tolerant threshold has only been demonstrated for codes that encode one or just a few qubits per block: concatenated codes and topological codes.</p> <p>In a related subsequent development, Gottesman demonstrated that with finite-rate quantum LDPC codes, a finite fraction of additional qubits compared to what is required by the code is sufficient to implement an arbitrarily large quantum computation [2].</p> <p>Overall, the conclusion is that with finite-rate quantum LDPC codes, fewer redundant qubits may be necessary to build a useful quantum computer.</p> <p><br /><strong>Integration of dynamical decoupling with quantum error correction</strong></p> <p>This is the second major result of the supported research. Dynamical decoupling is a passive coherence-protecting technique which does not require additional qubits: it suppresses errors before they happen. Our work [3] gives a practical way to combine it with quantum error correction. Potentially, this could lead to orders-of-magnitude reduction of the noise at the input of error correction, enabling a much longer error-correction cycle.</p> <p>Further, we analyzed the structure of the systematic errors associated with our construction, and developed an important incite that any related prescription based on the perturbation theory is likely to entail correlated multi-qubit errors, whether or not it incorporates dynamical decoupling. Compared to errors occurring independently on different qubits, correlated errors are more difficult to deal with. Yet, for the toric code, we have been able to prove the existence of a finite error-correction threshold even in the presence of correlated errors [4].</p> <p><br />[1] A. A. Kovalev and L. P. Pryadko, &ldquo;Fault tolerance of quantum low-density parity check codes with sublinear distance scaling,&rdquo; Phys. Rev. A 87, 020304(R) (2013).</p> <p>[2] D. Gottesman, &ldquo;What is the overhead required for fault-tolerant quantum computat...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Fault-tolerance of quantum LDPC codes with power-law distance   This is the most important result of the supported research.  Technically, quantum LDPC codes are just stabilizer codes, but with stabilizer generators (operators to be measured at each error correction cycle) involving only a few qubits each compared to the number of qubits used in the code. Such codes are most often degenerate: some errors have trivial effect and do not require any correction. Compared to general quantum codes, with a quantum LDPC code, each quantum measurement involves fewer qubits, measurements can be done in parallel, and also the classical processing could potentially be enormously simplified.  The most famous family of quantum LDPC codes is KitaevÃ†s toric construction: it has a relatively high threshold for scalable quantum computation, around 1% total error probability per quantum gate or a qubit measurement, and only local gates are needed. One disadvantage is that all toric and related surface codes encode very few qubits (in technical terms, they have asymptotically zero rate); thus they require many redundant physical qubits.  Finite-rate quantum LDPC codes are also possible. Several large families of such codes are known. An apparent disadvantage is that all known families of quantum LDPC codes have distance scaling like a power law of the number of qubits involved in the code. This means that some errors spanning a vanishing fraction of qubits in a large code are uncorrectable.  Using techniques from percolation theory, we established[1] that, in fact, uncorrectable errors are exponentially rare. It follows that below certain threshold error rate, known quantum LDPC codes can protect an arbitrarily large quantum computation. This is the only class of codes where a finite fault-tolerant error correction threshold and a finite rate are known to coexist. Previously, existence of a finite fault-tolerant threshold has only been demonstrated for codes that encode one or just a few qubits per block: concatenated codes and topological codes.  In a related subsequent development, Gottesman demonstrated that with finite-rate quantum LDPC codes, a finite fraction of additional qubits compared to what is required by the code is sufficient to implement an arbitrarily large quantum computation [2].  Overall, the conclusion is that with finite-rate quantum LDPC codes, fewer redundant qubits may be necessary to build a useful quantum computer.   Integration of dynamical decoupling with quantum error correction  This is the second major result of the supported research. Dynamical decoupling is a passive coherence-protecting technique which does not require additional qubits: it suppresses errors before they happen. Our work [3] gives a practical way to combine it with quantum error correction. Potentially, this could lead to orders-of-magnitude reduction of the noise at the input of error correction, enabling a much longer error-correction cycle.  Further, we analyzed the structure of the systematic errors associated with our construction, and developed an important incite that any related prescription based on the perturbation theory is likely to entail correlated multi-qubit errors, whether or not it incorporates dynamical decoupling. Compared to errors occurring independently on different qubits, correlated errors are more difficult to deal with. Yet, for the toric code, we have been able to prove the existence of a finite error-correction threshold even in the presence of correlated errors [4].   [1] A. A. Kovalev and L. P. Pryadko, "Fault tolerance of quantum low-density parity check codes with sublinear distance scaling," Phys. Rev. A 87, 020304(R) (2013).  [2] D. Gottesman, "What is the overhead required for fault-tolerant quantum computation?" (2013), unpublished, arXiv:1310.2984.  [3] A. De and L. P. Pryadko, "Universal set of scalable dynamically corrected gates for quantum error correction with always-on qubit couplings," Phys. Rev. Lett....]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
