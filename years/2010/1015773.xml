<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAPSI:  Automated Refactoring of Legacy Java Frameworks to Annotation Types</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/01/2010</AwardEffectiveDate>
<AwardExpirationDate>05/31/2011</AwardExpirationDate>
<AwardTotalIntnAmount>5617.00</AwardTotalIntnAmount>
<AwardAmount>5617</AwardAmount>
<AwardInstrument>
<Value>Fellowship Award</Value>
</AwardInstrument>
<Organization>
<Code>01090000</Code>
<Directorate>
<Abbreviation>O/D</Abbreviation>
<LongName>Office Of The Director</LongName>
</Directorate>
<Division>
<Abbreviation>OISE</Abbreviation>
<LongName>Office Of Internatl Science &amp;Engineering</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anne Emig</SignBlockName>
<PO_EMAI>aemig@nsf.gov</PO_EMAI>
<PO_PHON>7032927241</PO_PHON>
</ProgramOfficer>
<AbstractNarration/>
<MinAmdLetterDate>06/04/2010</MinAmdLetterDate>
<MaxAmdLetterDate>06/04/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.079</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1015773</AwardID>
<Investigator>
<FirstName>Raffi</FirstName>
<LastName>Khatchadourian</LastName>
<PI_MID_INIT>T</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Raffi T Khatchadourian</PI_FULL_NAME>
<EmailAddress/>
<PI_PHON>6147875547</PI_PHON>
<NSF_ID>000549474</NSF_ID>
<StartDate>06/04/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Khatchadourian          Raffi          T</Name>
<CityName>Columbus</CityName>
<ZipCode>432355552</ZipCode>
<PhoneNumber/>
<StreetAddress/>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Ohio</StateName>
<StateCode>OH</StateCode>
<CONGRESSDISTRICT>15</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>OH15</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM/>
<ORG_LGL_BUS_NAME/>
<ORG_PRNT_DUNS_NUM/>
</Institution>
<Performance_Institution>
<Name><![CDATA[Khatchadourian          Raffi          T]]></Name>
<CityName>Columbus</CityName>
<StateCode>OH</StateCode>
<ZipCode>432355552</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Ohio</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>15</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>OH15</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7316</Code>
<Text>EAPSI</Text>
</ProgramElement>
<ProgramReference>
<Code>5921</Code>
<Text>JAPAN</Text>
</ProgramReference>
<ProgramReference>
<Code>5978</Code>
<Text>EAST ASIA AND PACIFIC PROGRAM</Text>
</ProgramReference>
<ProgramReference>
<Code>7316</Code>
<Text>EAPSI</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~5617</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>My current research deals with issues related to evolving the source code of large and complex software systems. For my JSPS summer project, Mr. Masuhara and I have specifically focused on software evolution issues for programs written in Aspect-Oriented programming languages. Aspect-Oriented programming languages help software developers encapsulate source code that would normally be scattered and tangled throughout many software modules due to the nature of the software&rsquo;s requirements. Such languages facilitate so-called localized reasoning of programs as developers need only to look at a single location of the software system to understand code that affects many parts of the system. This kind of reasoning allows developers to easily change code that, for example, enforces systemwide policies in a single location. On the same note, developers can reason about the core functionality of their systems without concerning themselves with code that affects the entire system.</p> <p>Although building software systems using an Aspect-Oriented programming language can be beneficial to developers in many ways, such systems have potential for new problems unique to these languages. A key construct that allows code to be situated in a single location but affect many system modules is a query-like expression called a pointcut. Pointcuts specify well-defined locations in the execution of the program where the code is to be executed. However, as the source code changes and as new functionality is added to the system, pointcuts may become invalidated. That is, they may fail to capture or inadvertently capture new places in the program&rsquo;s execution. Worse, these errors may go silently undetected in large and complex software systems. The result is that the software product may not function correctly, and the root of the problem may be difficult to discover.</p> <p>Dr. Masuhara and I have created an approach that detects pointcuts that may have become invalidated as software changes. These possibly invalidated pointcuts are subsequently presented to the developer. Along with the pointcut, we associate a degree of confidence, called the change confidence, that we have in the pointcut becoming invalidated given a particular change to the program. Pointcuts with a high change confidence value are presented in the programer&rsquo;s development environment with more emphasis than pointcuts with a lower change confidence value. This ensures that the developer is only alerted when there is a high probability of the pointcut being invalidated. Our approach will enable developers to discover problematic pointcuts early in the development process so that they may be fixed before causing the software to malfunction.</p> <p>Under the program, we have completed a publically available prototype implementation of a tool that realizes our approach. The tool's source code can be downloaded at&nbsp;http://code.google.com/a/eclipselabs.org/p/fraglight.&nbsp;It works as a plug-in to a popular integrated developer&rsquo;s environment (programmers&rsquo; workbench, software that helps developers write programs). We have designed and executed a thorough evaluation to assess the usefulness of our tool in real-world situations. This entailed collecting historical data pertaining to how developers change Aspect-Oriented software from a variety of sources. Particularly, we collected and analyzed data that suggests which program changes lead to invalidated pointcuts in real-world software. Not only do these results have potential to helpi developers evolve software written in Aspect-Oriented programming languages, the tool may also foster future research in this area.</p> <p>&nbsp;</p><br> <p>            Last Modified: 08/31/2011<br>      Modified by: Raffi&nbsp;T&nbsp;Khatchadourian</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ My current research deals with issues related to evolving the source code of large and complex software systems. For my JSPS summer project, Mr. Masuhara and I have specifically focused on software evolution issues for programs written in Aspect-Oriented programming languages. Aspect-Oriented programming languages help software developers encapsulate source code that would normally be scattered and tangled throughout many software modules due to the nature of the softwareÆs requirements. Such languages facilitate so-called localized reasoning of programs as developers need only to look at a single location of the software system to understand code that affects many parts of the system. This kind of reasoning allows developers to easily change code that, for example, enforces systemwide policies in a single location. On the same note, developers can reason about the core functionality of their systems without concerning themselves with code that affects the entire system.  Although building software systems using an Aspect-Oriented programming language can be beneficial to developers in many ways, such systems have potential for new problems unique to these languages. A key construct that allows code to be situated in a single location but affect many system modules is a query-like expression called a pointcut. Pointcuts specify well-defined locations in the execution of the program where the code is to be executed. However, as the source code changes and as new functionality is added to the system, pointcuts may become invalidated. That is, they may fail to capture or inadvertently capture new places in the programÆs execution. Worse, these errors may go silently undetected in large and complex software systems. The result is that the software product may not function correctly, and the root of the problem may be difficult to discover.  Dr. Masuhara and I have created an approach that detects pointcuts that may have become invalidated as software changes. These possibly invalidated pointcuts are subsequently presented to the developer. Along with the pointcut, we associate a degree of confidence, called the change confidence, that we have in the pointcut becoming invalidated given a particular change to the program. Pointcuts with a high change confidence value are presented in the programerÆs development environment with more emphasis than pointcuts with a lower change confidence value. This ensures that the developer is only alerted when there is a high probability of the pointcut being invalidated. Our approach will enable developers to discover problematic pointcuts early in the development process so that they may be fixed before causing the software to malfunction.  Under the program, we have completed a publically available prototype implementation of a tool that realizes our approach. The tool's source code can be downloaded at http://code.google.com/a/eclipselabs.org/p/fraglight. It works as a plug-in to a popular integrated developerÆs environment (programmersÆ workbench, software that helps developers write programs). We have designed and executed a thorough evaluation to assess the usefulness of our tool in real-world situations. This entailed collecting historical data pertaining to how developers change Aspect-Oriented software from a variety of sources. Particularly, we collected and analyzed data that suggests which program changes lead to invalidated pointcuts in real-world software. Not only do these results have potential to helpi developers evolve software written in Aspect-Oriented programming languages, the tool may also foster future research in this area.          Last Modified: 08/31/2011       Submitted by: Raffi T Khatchadourian]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
