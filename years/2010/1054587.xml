<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Looking Glass: Leveraging Mentor Interactions to Create Personalized Programming Help for Independent Learners</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>02/01/2011</AwardEffectiveDate>
<AwardExpirationDate>01/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>499977.00</AwardTotalIntnAmount>
<AwardAmount>561777</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05020000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>IIS</Abbreviation>
<LongName>Div Of Information &amp; Intelligent Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>William Bainbridge</SignBlockName>
<PO_EMAI>wbainbri@nsf.gov</PO_EMAI>
<PO_PHON>7032928930</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This project will amplify the efforts of computer scientists who do outreach to middle school students  by capturing mentor-mentee interactions and using this captured content to create a virtual mentoring system to support independent learners (children without access to computer science experts) within the Looking Glass programming environment. Looking Glass is a novice programming environment that presents programming as a means to the motivating end of creating 3D animated stories. In the system to be developed, mentors will do three things: First, a mentor watches the story-programs his or her mentee created and writes a code suggestion: new or revised functionality that will help to improve the mentees' programs. Next, the mentor edits a draft tutorial that Looking Glass has automatically generated from the mentor's code suggestion. Looking Glass then sends this edited tutorial to the mentee. Finally, the mentor writes rules that help Looking Glass identify contexts in which that code suggestion could be helpful. Looking Glass will use the mentor-contributed code suggestions, personalized tutorials, and rules to provide virtual mentoring for independent learners. Specifically, this project will explore three hypotheses: &lt;br/&gt;&lt;br/&gt;Hypothesis One: The approach of capturing and evaluating mentor-created learning materials will enable the creation of a virtual mentoring system to support independent learners. &lt;br/&gt;&lt;br/&gt;Hypothesis Two: Independent learners who are presented with in-context code suggestions that both further their stories and introduce new programming concepts will develop greater programming skills than those without access to these suggestions. &lt;br/&gt;&lt;br/&gt;Hypothesis Three: Independent learners who are presented with personalized tutorials based on their experience level with each topic presented will perform better than independent learners who are presented with a single level of scaffolding. &lt;br/&gt;&lt;br/&gt;The National Academy of Engineering lists personalized learning as one of the grand challenges for engineering in this century. This project will develop and evaluate the impact of two techniques for personalizing learning: program-specific code suggestions and personalized, multi-level tutorials. The majority of research into educational environments has focused on formal educational settings, but Looking Glass will advance research in how to effectively support independent learning in open-ended software environments.  The enhancement to Looking Glass will provide an environment for exploring computer programming and learning support through virtual mentoring to middle school children without access to computer science learning opportunities.  The project's educational plan uses biographies of computer scientists integrated into Looking Glass and a research blog to help middle school children develop an accurate image of computer science.</AbstractNarration>
<MinAmdLetterDate>01/25/2011</MinAmdLetterDate>
<MaxAmdLetterDate>04/07/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1054587</AwardID>
<Investigator>
<FirstName>Caitlin</FirstName>
<LastName>Kelleher</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Caitlin Kelleher</PI_FULL_NAME>
<EmailAddress>ckelleher@cse.wustl.edu</EmailAddress>
<PI_PHON>3149356119</PI_PHON>
<NSF_ID>000240794</NSF_ID>
<StartDate>01/25/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Washington University</Name>
<CityName>Saint Louis</CityName>
<ZipCode>631304862</ZipCode>
<PhoneNumber>3147474134</PhoneNumber>
<StreetAddress>CAMPUS BOX 1054</StreetAddress>
<StreetAddress2><![CDATA[1 Brookings Drive]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Missouri</StateName>
<StateCode>MO</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MO01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>068552207</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>WASHINGTON UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>068552207</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Washington University]]></Name>
<CityName>Saint Louis</CityName>
<StateCode>MO</StateCode>
<ZipCode>631304862</ZipCode>
<StreetAddress><![CDATA[CAMPUS BOX 1054]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Missouri</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MO01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7367</Code>
<Text>HCC-Human-Centered Computing</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>7367</Code>
<Text>Cyber-Human Systems</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~134370</FUND_OBLG>
<FUND_OBLG>2012~135957</FUND_OBLG>
<FUND_OBLG>2013~114929</FUND_OBLG>
<FUND_OBLG>2014~76967</FUND_OBLG>
<FUND_OBLG>2015~99554</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p class="MsoNormal">Supporting young people in learning computer science is of large and increasing importance. Existing work suggests that enabling learners to focus on personally relevant projects can support interest in computing. However, supporting learners in totally open-ended contexts can be a challenge, both in formal and informal settings. This project has contributed two new kinds of supports for youth programming environments: code puzzles and suggestions.</p> <p class="MsoNormal">&nbsp;Code puzzles reduce the need for learners to focus on interface mechanics while learning how to combine programming statements and constructs to solve problems. Essentially, a code puzzle consists of a set of statements and constructs that can be assembled to create a target animation. Learners then need to figure out how to reconstruct the original program. As the learner&rsquo;s program runs, the interface provides correctness feedback designed to help users focus on where errors are occurring without enabling them to easily game the system. We have done a variety of studies around code puzzles. Some important results include:</p> <p class="MsoNormal">1) Learners who use code puzzles learn 23% more efficiently than learners who use equivalent tutorials and perform 26% better on a novel related problem.</p> <p class="MsoNormal">2) When puzzles include carefully designed unnecessary statements, distractors, learning efficiency decreases by 14%, cognitive load increases, and learners are 26% less successful at completing puzzles. In initial learning settings, this provides experimental evidence that distractor statements are more harmful than helpful.</p> <p class="MsoNormal">3) A qualitative study exploring how youth perceive value in code puzzles and tutorials found that decisions around help resources often include a variety of factors including interest in particular content and expectations of difficulty. Overall, learners felt that completing tutorials was easier than completing puzzles, but that puzzles are more motivating. However, &nbsp;we found that learners prioritized content interest over format interest; some chose to use tutorials in order to access content they thought might be too hard otherwise.</p> <p class="MsoNormal">This work contributes important knowledge to how to design effective code puzzles as well as how to create contexts that support youth in pursuing their own goals within programming environments.</p> <p class="MsoNormal">&nbsp;</p> <p class="MsoNormal">Our code suggestions framework enables a programming environment to identify potentially valuable code examples to suggest to youth programmers by analyzing their current code. Essentially, as learners work, the programming environment looks for opportunities to suggest new skills behind the scenes. The suggestions are offered in two ways through the interface: 1) through light bulb icons added to specific lines of (related) code and 2) via a tips area within the interface that archives all of the suggestions that have been offered. The tips area briefly describes each suggestion, contextualized within the learner&rsquo;s program. So, if they have an alien character a tip say &ldquo;teach alien to dance.&rdquo; When a suggestion is opened, either via the light bulb icon or the tips area, users are shown a pair of contrasting, executable examples. The use of contrasting examples helps users to zero in on the important aspects of each one.</p> <p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;">The Example Guru shows significant promise in supporting children as they learn to program, while working on self-selected projects. Twice as many participants accessed Example Guru suggestions as compared to documentation. Those participants then used more than twice as many new API methods after accessing suggestions than documentation.<span style="font-size: 12.5pt; font-family: &quot;Arial&quot;,sans-serif; mso-fareast-font-family: &quot;Times New Roman&quot;;"></span></p> <p class="MsoNormal" style="margin-bottom: .0001pt; line-height: normal;"><span style="font-size: 12.5pt; font-family: &quot;Arial&quot;,sans-serif; mso-fareast-font-family: &quot;Times New Roman&quot;;">&nbsp;</span></p> <p class="MsoNormal">A longer term study, now in review, looked at the use of suggestions, documentation, tutorials, and puzzles in two weeks of open ended use. We found that suggestions were accessed by more than twice as many participants as other forms of help and that participants were more successful in applying skills learned through suggestions than other forms of help. Qualitative survey data suggests that participants strongly preferred lightweight, in-context help that enabled them to continue working towards their own goals, while also supporting them in developing new skills.</p> <p>&nbsp;</p> <p class="MsoNormal">Current programming environments for youth generally do not include in-content, lightweight help like suggestions. However, our results suggest that these forms of help may be more effective than others, particularly tutorials and puzzles that require learners to stop working on a current project in order to go learn a new skill.&nbsp;</p> <div id="_mcePaste" class="mcePaste" style="position: absolute; left: -10000px; top: 0px; width: 1px; height: 1px; overflow: hidden;"><span style="font-size: 11.0pt; line-height: 107%; font-family: &quot;Calibri&quot;,sans-serif; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-hansi-theme-font: minor-latin; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-bidi-theme-font: minor-bidi; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA;">The suggestions are offered in two ways through the interface: 1) through light bulb icons added to specific lines of (related) code and 2) via a tips area within the interface that archives all of the suggestions that have been offered. The tips area briefly describes each suggestion, contextualized within the learner&rsquo;s program. So, if they have an alien character a tip say &ldquo;teach alien to dance.&rdquo; When a suggestion is opened, either via the light bulb icon or the tips area, users are shown a pair of contrasting, executable examples. The use of contrasting examples helps users to zero in on the important aspects of each one.</span></div><br> <p>            Last Modified: 05/05/2017<br>      Modified by: Caitlin&nbsp;Kelleher</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Supporting young people in learning computer science is of large and increasing importance. Existing work suggests that enabling learners to focus on personally relevant projects can support interest in computing. However, supporting learners in totally open-ended contexts can be a challenge, both in formal and informal settings. This project has contributed two new kinds of supports for youth programming environments: code puzzles and suggestions.  Code puzzles reduce the need for learners to focus on interface mechanics while learning how to combine programming statements and constructs to solve problems. Essentially, a code puzzle consists of a set of statements and constructs that can be assembled to create a target animation. Learners then need to figure out how to reconstruct the original program. As the learner?s program runs, the interface provides correctness feedback designed to help users focus on where errors are occurring without enabling them to easily game the system. We have done a variety of studies around code puzzles. Some important results include: 1) Learners who use code puzzles learn 23% more efficiently than learners who use equivalent tutorials and perform 26% better on a novel related problem. 2) When puzzles include carefully designed unnecessary statements, distractors, learning efficiency decreases by 14%, cognitive load increases, and learners are 26% less successful at completing puzzles. In initial learning settings, this provides experimental evidence that distractor statements are more harmful than helpful. 3) A qualitative study exploring how youth perceive value in code puzzles and tutorials found that decisions around help resources often include a variety of factors including interest in particular content and expectations of difficulty. Overall, learners felt that completing tutorials was easier than completing puzzles, but that puzzles are more motivating. However,  we found that learners prioritized content interest over format interest; some chose to use tutorials in order to access content they thought might be too hard otherwise. This work contributes important knowledge to how to design effective code puzzles as well as how to create contexts that support youth in pursuing their own goals within programming environments.   Our code suggestions framework enables a programming environment to identify potentially valuable code examples to suggest to youth programmers by analyzing their current code. Essentially, as learners work, the programming environment looks for opportunities to suggest new skills behind the scenes. The suggestions are offered in two ways through the interface: 1) through light bulb icons added to specific lines of (related) code and 2) via a tips area within the interface that archives all of the suggestions that have been offered. The tips area briefly describes each suggestion, contextualized within the learner?s program. So, if they have an alien character a tip say "teach alien to dance." When a suggestion is opened, either via the light bulb icon or the tips area, users are shown a pair of contrasting, executable examples. The use of contrasting examples helps users to zero in on the important aspects of each one. The Example Guru shows significant promise in supporting children as they learn to program, while working on self-selected projects. Twice as many participants accessed Example Guru suggestions as compared to documentation. Those participants then used more than twice as many new API methods after accessing suggestions than documentation.   A longer term study, now in review, looked at the use of suggestions, documentation, tutorials, and puzzles in two weeks of open ended use. We found that suggestions were accessed by more than twice as many participants as other forms of help and that participants were more successful in applying skills learned through suggestions than other forms of help. Qualitative survey data suggests that participants strongly preferred lightweight, in-context help that enabled them to continue working towards their own goals, while also supporting them in developing new skills.    Current programming environments for youth generally do not include in-content, lightweight help like suggestions. However, our results suggest that these forms of help may be more effective than others, particularly tutorials and puzzles that require learners to stop working on a current project in order to go learn a new skill.  The suggestions are offered in two ways through the interface: 1) through light bulb icons added to specific lines of (related) code and 2) via a tips area within the interface that archives all of the suggestions that have been offered. The tips area briefly describes each suggestion, contextualized within the learner?s program. So, if they have an alien character a tip say "teach alien to dance." When a suggestion is opened, either via the light bulb icon or the tips area, users are shown a pair of contrasting, executable examples. The use of contrasting examples helps users to zero in on the important aspects of each one.       Last Modified: 05/05/2017       Submitted by: Caitlin Kelleher]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
