<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SI2-SSI: Accelerating the Pace of Research through Implicitly Parallel Programming</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2010</AwardEffectiveDate>
<AwardExpirationDate>03/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>1740214.00</AwardTotalIntnAmount>
<AwardAmount>1740214</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05090000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>OAC</Abbreviation>
<LongName>Office of Advanced Cyberinfrastructure (OAC)</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Today, two trends conspire to slow down the pace of science, engineering, and academic research progress in general.  First, researchers increasingly rely on computation to process ever larger data sets and to perform ever more computationally-intensive simulations.  Second, individual processor speeds are no longer increasing with every computer chip generation as they once were.  To compensate, processor manufacturers have moved to including more processors, or cores, on a chip with each generation.  To obtain peak performance on these multicore chips, software must be implemented so that it can execute in parallel and thereby use the additional processor cores. Unfortunately, writing efficient, explicitly parallel software programs using today's software-development tools takes advanced training in computer science, and even with such training, the task remains extremely difficult, error-prone, and time consuming.  This project will create a new high-level programming platform, called Implicit Parallel Programming (IPP), designed to bring the performance promises of modern multicore machines to scientists and engineers without the costs associated with having to teach these users how to write explicitly parallel programs.  In the short term, this research will provide direct and immediate benefit to researchers in several areas of science as the PIs will pair computer science graduate students with non-computer science graduate students to study, analyze, and develop high-value scientific applications.  In the long term, this research has the potential to fundamentally change the way scientists obtain performance from parallel machines, improve their productivity, and accelerate the overall pace of science.  This work will also have major educational impact by developing courseware and tutorial materials, useable by all scientists and engineers, on the topics of explicit and implicit parallel computing.&lt;br/&gt;&lt;br/&gt;IPP will operate by allowing users to write ordinary sequential programs and then to augment them with logical specifications that expand (or abstract) the set of sequential program behaviors.  This capacity for abstraction will provide parallelizing compilers with the flexibility to more aggressively optimize programs than would otherwise be possible.  In fact, it will enable effective parallelization techniques where they were impossible before.  The language design and compiler implementation will be accompanied by formal semantic analysis that will be used to judge the correctness of compiler transformations, provide a foundation for about reasoning programs, and guide the creation of static analysis and program defect detection algorithms.  Moreover since existing programs and languages can be viewed as (degenerately) implicitly parallel, decades of investment in human expertise, languages, compilers, methods, tools, and applications is preserved.  In particular, it will be possible to upgrade old legacy programs or libraries from slow sequential versions without overhauling the entire system architecture, but merely by adding a few auxiliary specifications.  Compiler technology will help guide scientists and engineers through this process, further simplifying the task.  Conceptually, IPP restores an important layer of abstraction, freeing programmers to write high-level code, designed to be easy to understand, rather than low-level code, architected according to the specific demands of a particular parallel machine.</AbstractNarration>
<MinAmdLetterDate>09/13/2010</MinAmdLetterDate>
<MaxAmdLetterDate>09/13/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1047879</AwardID>
<Investigator>
<FirstName>David</FirstName>
<LastName>August</LastName>
<PI_MID_INIT>I</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>David I August</PI_FULL_NAME>
<EmailAddress>august@cs.princeton.edu</EmailAddress>
<PI_PHON>6092582085</PI_PHON>
<NSF_ID>000192343</NSF_ID>
<StartDate>09/13/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>David</FirstName>
<LastName>Walker</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>David Walker</PI_FULL_NAME>
<EmailAddress>dpw@cs.princeton.edu</EmailAddress>
<PI_PHON>6092587654</PI_PHON>
<NSF_ID>000167001</NSF_ID>
<StartDate>09/13/2010</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Princeton University</Name>
<CityName>Princeton</CityName>
<ZipCode>085442020</ZipCode>
<PhoneNumber>6092583090</PhoneNumber>
<StreetAddress>Off. of Research &amp; Proj. Admin.</StreetAddress>
<StreetAddress2><![CDATA[P.O. Box 36]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ12</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>002484665</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF PRINCETON UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>002484665</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Princeton University]]></Name>
<CityName>Princeton</CityName>
<StateCode>NJ</StateCode>
<ZipCode>085442020</ZipCode>
<StreetAddress><![CDATA[Off. of Research &amp; Proj. Adm]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ12</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>1640</Code>
<Text>Information Technology Researc</Text>
</ProgramElement>
<ProgramElement>
<Code>2878</Code>
<Text>Special Projects - CCF</Text>
</ProgramElement>
<ProgramElement>
<Code>8004</Code>
<Text>Software Institutes</Text>
</ProgramElement>
<ProgramReference>
<Code>1640</Code>
<Text>INFORMATION TECHNOLOGY RESEARC</Text>
</ProgramReference>
<ProgramReference>
<Code>2878</Code>
<Text>SPECIAL PROJECTS - CCF</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~1740214</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><blockquote> <div> <blockquote> <p>The goal of this project is to accelerate the pace of research through implicitly parallel programming. The project began with an extensive survey and analysis of the practice of computer science by computational scientists and researchers at a highly-ranked research university. &nbsp;As part of the survey, project personnel interviewed 114 researchers from diverse fields of natural science, engineering, interdisciplinary sciences, and social sciences. The survey covered three major themes central to scientific computing: (a) programming practices, (b) computational time and resource use, and (c) performance-enhancing methods.</p> <p>The survey yielded several important findings. The most important insight was that scientists typically don't have the time, desire, or skills to write parallel applications. &nbsp;This is a problem because the majority of the sequential applications they do write to conduct research take days, weeks, or months to execute. Consequently, the pace of research is often limited by slow application execution time. &nbsp;The survey revealed that most researchers run their programs only on desktops, even when clusters were available to them, and that almost all of them run single threaded code on these desktops despite the presence of multicore processors. The findings of the survey guided the automatic parallelization techniques developed during this project.</p> <p>Following the survey, the project focused on the development of automatic parallelizations tools that transformed unoptimized sequential programs into efficient, parallel programs. These tools and methods enabled researchers to focus on the core of their algorithm without having to worry about the low-level details of the program, thereby improving their productivity.</p> <p>The project also resulted in the integration of several new techniques into a maturing automatic parallelization framework. The Fast DAG_SCC algorithm improved the scalability of key algorithms in parallelizing compilers, enabling the compiler to analyze larger program scopes and more efficiently use stronger, more computationally expensive program analyses. The concept of context-sensitive speculation allowed for more efficient parallelization of complex programs. Development of runtime and hardware support for multi-threaded transactions enabled support for efficient speculation on both desktops and clusters. This allowed for faster and more scalable parallelization of existing workloads. Another new automatic technique called CGCM (CPU-GPU Communication Manager) enhanced GPU execution by optimizing CPU-GPU communication. Finally, the development of the implicitly parallel programming model enabled the compiler to leverage programmer insights to transform sequential code into well-performing parallel versions.</p> <p>The project team applied various combinations of these techniques to real programs used by researchers to make a broader impact. For instance, the survey found the use of scripting languages to be very common among researchers. Consequently, project personnel developed and applied aggressive optimizations to frequently used scripting languages such as Python, Perl, and Lua. The results, deployed in real programs, helped researchers in various disciples such as epidemiology, hardware verification, and computational biology. For example, the application of these techniques to epidemiology enabled scientists there to better gain an understanding of the spread of diseases and ways to control them.</p> <p>Beyond the application of project artifacts to scientific research, the project also contributed in several ways to human resource development. &nbsp;A new graduate course on parallelism taught students how to develop high-performance applications using state-of-the-art language and compiler technology--an often under-taught part of common computer science curricula. Additionally, the project also funded several outreach activities that aimed to popularize the appeal of STEM fields among elementary school students.</p> </blockquote> </div> </blockquote><br> <p>            Last Modified: 08/18/2016<br>      Modified by: David&nbsp;I&nbsp;August</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[    The goal of this project is to accelerate the pace of research through implicitly parallel programming. The project began with an extensive survey and analysis of the practice of computer science by computational scientists and researchers at a highly-ranked research university.  As part of the survey, project personnel interviewed 114 researchers from diverse fields of natural science, engineering, interdisciplinary sciences, and social sciences. The survey covered three major themes central to scientific computing: (a) programming practices, (b) computational time and resource use, and (c) performance-enhancing methods.  The survey yielded several important findings. The most important insight was that scientists typically don't have the time, desire, or skills to write parallel applications.  This is a problem because the majority of the sequential applications they do write to conduct research take days, weeks, or months to execute. Consequently, the pace of research is often limited by slow application execution time.  The survey revealed that most researchers run their programs only on desktops, even when clusters were available to them, and that almost all of them run single threaded code on these desktops despite the presence of multicore processors. The findings of the survey guided the automatic parallelization techniques developed during this project.  Following the survey, the project focused on the development of automatic parallelizations tools that transformed unoptimized sequential programs into efficient, parallel programs. These tools and methods enabled researchers to focus on the core of their algorithm without having to worry about the low-level details of the program, thereby improving their productivity.  The project also resulted in the integration of several new techniques into a maturing automatic parallelization framework. The Fast DAG_SCC algorithm improved the scalability of key algorithms in parallelizing compilers, enabling the compiler to analyze larger program scopes and more efficiently use stronger, more computationally expensive program analyses. The concept of context-sensitive speculation allowed for more efficient parallelization of complex programs. Development of runtime and hardware support for multi-threaded transactions enabled support for efficient speculation on both desktops and clusters. This allowed for faster and more scalable parallelization of existing workloads. Another new automatic technique called CGCM (CPU-GPU Communication Manager) enhanced GPU execution by optimizing CPU-GPU communication. Finally, the development of the implicitly parallel programming model enabled the compiler to leverage programmer insights to transform sequential code into well-performing parallel versions.  The project team applied various combinations of these techniques to real programs used by researchers to make a broader impact. For instance, the survey found the use of scripting languages to be very common among researchers. Consequently, project personnel developed and applied aggressive optimizations to frequently used scripting languages such as Python, Perl, and Lua. The results, deployed in real programs, helped researchers in various disciples such as epidemiology, hardware verification, and computational biology. For example, the application of these techniques to epidemiology enabled scientists there to better gain an understanding of the spread of diseases and ways to control them.  Beyond the application of project artifacts to scientific research, the project also contributed in several ways to human resource development.  A new graduate course on parallelism taught students how to develop high-performance applications using state-of-the-art language and compiler technology--an often under-taught part of common computer science curricula. Additionally, the project also funded several outreach activities that aimed to popularize the appeal of STEM fields among elementary school students.          Last Modified: 08/18/2016       Submitted by: David I August]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
