<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Making Threads More Deterministic by Memoizing Schedules</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>02/01/2011</AwardEffectiveDate>
<AwardExpirationDate>01/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>641640.00</AwardTotalIntnAmount>
<AwardAmount>350702</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Multithreaded programs are becoming increasingly critical driven by the&lt;br/&gt;rise of multicore hardware and the coming storm of cloud computing.&lt;br/&gt;Unfortunately, these programs remain difficult to write, test, and debug.&lt;br/&gt;A key reason for this difficulty is nondeterminism: different runs of a&lt;br/&gt;multithreaded program may show different behaviors depending on how the&lt;br/&gt;threads interleave.  Nondeterminism complicates almost every development&lt;br/&gt;step of multithreaded programs.  For instance, it weakens testing because&lt;br/&gt;the schedules tested may not be the ones run in the field; it complicates&lt;br/&gt;debugging because reproducing a buggy schedule is hard.&lt;br/&gt;&lt;br/&gt;In the past three decades, researchers have developed many techniques to&lt;br/&gt;address nondeterminism.  Despite these efforts, it remains an open&lt;br/&gt;challenge to achieve both efficiency and determinism for general&lt;br/&gt;multithreaded programs on commodity multiprocessors.&lt;br/&gt;&lt;br/&gt;This project aims to address this fundamental challenge.  Its key insight&lt;br/&gt;is that one can reuse a small number of schedules to process a large&lt;br/&gt;number of inputs.  Based on this insight, it takes an approach called&lt;br/&gt;schedule memoization that memoizes past schedules and, when possible,&lt;br/&gt;reuses them for future runs.  This approach amortizes the high overhead of&lt;br/&gt;making one schedule deterministic over many reuses and makes a program&lt;br/&gt;repeat familiar behaviors whenever possible.  A real-world analogy to this&lt;br/&gt;approach is animals' natural tendencies to follow familiar routes to avoid&lt;br/&gt;hazards and discovery overhead of unknown routes.&lt;br/&gt;&lt;br/&gt;The greatest impact of this project will be a novel approach and new,&lt;br/&gt;effective systems and technologies to improving software reliability, thus&lt;br/&gt;benefiting every business, government, and individual.</AbstractNarration>
<MinAmdLetterDate>01/21/2011</MinAmdLetterDate>
<MaxAmdLetterDate>01/14/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1054906</AwardID>
<Investigator>
<FirstName>Junfeng</FirstName>
<LastName>Yang</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Junfeng Yang</PI_FULL_NAME>
<EmailAddress>junfeng@cs.columbia.edu</EmailAddress>
<PI_PHON>2128546851</PI_PHON>
<NSF_ID>000509381</NSF_ID>
<StartDate>01/21/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Columbia University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100276902</ZipCode>
<PhoneNumber>2128546851</PhoneNumber>
<StreetAddress>2960 Broadway</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049179401</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049179401</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Columbia University]]></Name>
<CityName>NEW YORK</CityName>
<StateCode>NY</StateCode>
<ZipCode>100276902</ZipCode>
<StreetAddress><![CDATA[2960 Broadway]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~79589</FUND_OBLG>
<FUND_OBLG>2012~82380</FUND_OBLG>
<FUND_OBLG>2013~92913</FUND_OBLG>
<FUND_OBLG>2016~95820</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Multithreaded programs are becoming increasingly critical driven by the&nbsp;rise of multicore hardware and the coming storm of cloud computing.&nbsp;Unfortunately, these programs remain difficult to write, test, and debug.&nbsp;A key reason for this difficulty is nondeterminism: different runs of a&nbsp;multithreaded program may show different behaviors depending on how the&nbsp;threads interleave. Nondeterminism complicates almost every development&nbsp;step of multithreaded programs. For instance, it weakens testing because&nbsp;the schedules tested may not be the ones run in the field; it complicates&nbsp;debugging because reproducing a buggy schedule is hard.<br /><br />In the past three decades, researchers have developed many techniques to&nbsp;address nondeterminism. Despite these efforts, it remains an open&nbsp;challenge to achieve both efficiency and determinism for general&nbsp;multithreaded programs on commodity multiprocessors.</p> <p>This project aims to address this fundamental challenge. Its key insight&nbsp;is that one can reuse a small number of schedules to process a large&nbsp;number of inputs. Based on this insight, it takes an approach called&nbsp;schedule memoization that memoizes past schedules and, when possible,&nbsp;reuses them for future runs. This approach amortizes the high overhead of&nbsp;making one schedule deterministic over many reuses and makes a program&nbsp;repeat familiar behaviors whenever possible. A real-world analogy to this&nbsp;approach is animals' natural tendencies to follow familiar routes to avoid&nbsp;hazards and discovery overhead of unknown routes.</p> <p>The greatest impact of this project is a novel approach and new,&nbsp;effective systems and technologies to improving software reliability, thus&nbsp;benefiting every business, government, and individual. &nbsp;This work leads to many publications at the top venues such as SOSP, OSDI, PLDI, and POPL, a Communications of ACM invited paper, several open-source software releases, more than 20 invited talks worldwide, and coverage by premier presses including The Register. &nbsp;It also inspires much follow-up work by others in the field.</p><br> <p>            Last Modified: 05/12/2017<br>      Modified by: Junfeng&nbsp;Yang</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Multithreaded programs are becoming increasingly critical driven by the rise of multicore hardware and the coming storm of cloud computing. Unfortunately, these programs remain difficult to write, test, and debug. A key reason for this difficulty is nondeterminism: different runs of a multithreaded program may show different behaviors depending on how the threads interleave. Nondeterminism complicates almost every development step of multithreaded programs. For instance, it weakens testing because the schedules tested may not be the ones run in the field; it complicates debugging because reproducing a buggy schedule is hard.  In the past three decades, researchers have developed many techniques to address nondeterminism. Despite these efforts, it remains an open challenge to achieve both efficiency and determinism for general multithreaded programs on commodity multiprocessors.  This project aims to address this fundamental challenge. Its key insight is that one can reuse a small number of schedules to process a large number of inputs. Based on this insight, it takes an approach called schedule memoization that memoizes past schedules and, when possible, reuses them for future runs. This approach amortizes the high overhead of making one schedule deterministic over many reuses and makes a program repeat familiar behaviors whenever possible. A real-world analogy to this approach is animals' natural tendencies to follow familiar routes to avoid hazards and discovery overhead of unknown routes.  The greatest impact of this project is a novel approach and new, effective systems and technologies to improving software reliability, thus benefiting every business, government, and individual.  This work leads to many publications at the top venues such as SOSP, OSDI, PLDI, and POPL, a Communications of ACM invited paper, several open-source software releases, more than 20 invited talks worldwide, and coverage by premier presses including The Register.  It also inspires much follow-up work by others in the field.       Last Modified: 05/12/2017       Submitted by: Junfeng Yang]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
