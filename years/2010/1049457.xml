<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER: Technologies for Elastic OS Services in fos</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2010</AwardEffectiveDate>
<AwardExpirationDate>09/30/2013</AwardExpirationDate>
<AwardTotalIntnAmount>194177.00</AwardTotalIntnAmount>
<AwardAmount>194177</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>As the number of cores per chip scales to 1000s by the middle of the next decade, a fundamentally different set of constraints governs software design, including the operating system. However, recent research has demonstrated problems with scaling monolithic OS designs. In monolithic OSs, OS code executes in the kernel on the same core, which makes an OS service request.  That has led to significant performance degradation and exhibits severe scalability problems. Efforts to improve scalability of these services have been difficult and marginally successful.  The primary question facing OS research over the next decade is: How can the operating system services be designed such that they scale to hundreds or thousands of cores?  To answer this question, the research community needs to rethink operating system design from the ground up in light of current and future multicore architectures.&lt;br/&gt;&lt;br/&gt;One solution is to provide a factored operating system that scales over the increasing number of cores.  A factored operating system (called "fos") factors out the system services of a monolithic OS into a set of individual services. fos further factors and parallelizes each system service into an Internet-style collection, or fleet, of cooperating servers that are distributed across the multicore chip and bound to specific cores. To maintain good performance and efficient utilization in the face of varying system resources and application demand, the fleets need to employ elasticity.  The PIs propose an elastic version of fos (dubbed "e-fos") which provides technologies to allow system services to be scaled up or down at run-time. The primary goal of e-fos is to scale to a large numbers of cores while meeting the varying demand in resources and services, i.e., discover and evaluate how a factored operating system can leverage elasticity to maintain performance and efficiency. e-fos demonstrates elastic fleets and mechanisms to manage the elasticity for future multicores. These techniques replace the outdated "static OS components", which currently hinder contemporary monolithic OSs from scaling to hundreds or thousands of cores. For further information, see the project webpage: http://groups.csail.mit.edu/carbon/fos.</AbstractNarration>
<MinAmdLetterDate>09/22/2010</MinAmdLetterDate>
<MaxAmdLetterDate>09/22/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1049457</AwardID>
<Investigator>
<FirstName>Anant</FirstName>
<LastName>Agarwal</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Anant Agarwal</PI_FULL_NAME>
<EmailAddress>agarwal@cag.csail.mit.edu</EmailAddress>
<PI_PHON>6172531448</PI_PHON>
<NSF_ID>000439628</NSF_ID>
<StartDate>09/22/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[NE18-901]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001425594</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>MASSACHUSETTS INSTITUTE OF TECHNOLOGY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001425594</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Massachusetts Institute of Technology]]></Name>
<CityName>Cambridge</CityName>
<StateCode>MA</StateCode>
<ZipCode>021394301</ZipCode>
<StreetAddress><![CDATA[77 MASSACHUSETTS AVE]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7793</Code>
<Text>DATA-INTENSIVE COMPUTING</Text>
</ProgramElement>
<ProgramReference>
<Code>7793</Code>
<Text>DATA-INTENSIVE COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~194177</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Current computer operating systems were designed in an era when computation was the most critical resource in a machine. In the multicore era, the landscape has fundamentally changed. &nbsp;With the expected exponential increase in number of cores per processor, the question is no longer how to cope with limited resources, but rather how to make the most of the abundant computation available. &nbsp;This project investigated some of the design decisions and challenges that will be encountered as operating systems evolve for this new computing landscape.&nbsp; Specifically, we sought to answer the following high-level questions:</p> <ul> <li>Can an operating system service be effectively implemented using a set (or "fleet") of cooperating server processes running on different cores within a large multicore processor?</li> <li>How should that fleet adapt to changes in workload or availability of resources?</li> </ul> <p>Our initial explorations were made in the context of the experimental "fos" operating system.&nbsp; We designed a new naming service that is used by applications to find a particular service they need.&nbsp; Having this layer of indirection between the applications and services allows the fleets of servers to dynamically grow, shrink, migrate or reconfigure themselves as needed.&nbsp; We call this ability to adapt "elasticity."&nbsp; We prototyped an elastic filesystem in fos and showed that it was able to respond well to changes in demand using only simple heuristics to grow and shrink the filesystem fleet.&nbsp; Finally, we designed an elastic networking service for fos by refactoring and partitioning the work it performs in novel ways.&nbsp; It distributes the workload across a parallel fleet of servers that is capable of growing and shrinking as required.&nbsp; More details on these can be found in the academic papers published under the fos project.</p> <p>In the second half of this project, we turned our attention towards applying some of the lessons we had learned to a more mainstream operating system. &nbsp;We chose to implement a new networking service (called Pika) within the Linux operating system that would have greater scalability and elasticity than the default network stack. &nbsp;Pika employs dedicated cores for running the network stack which are distinct from application cores. Furthermore, Pika splits the network stack into various conceptual component servers based on functionality. The design of PIKA allows each of these components to either be run as stand-alone servers or combined with other components into a composite server (see Pika Architecture images). An instance of PIKA consists of one or more servers, each of which may encapsulate one or more of these components.&nbsp;This gives Pika the flexibility to run on both small and large machines and adapt to changes in load by adding or removing servers.</p> <p>We evaluated Pika on a modern server machine with four 10-core Intel Xeon processors and compared it to the stock Linux networking stack. &nbsp;Pika is able to significantly outperform stock Linux when it is allowed to run on large numbers of cores.&nbsp;Pika is able to achieve near-optimal scaling as the number of cores are increased, showing that it is well-equiped to handle the highly-parallel machines of the future.&nbsp;In addition, its performance is competitive with Linux when both are restricted to small numbers of cores (simulating a less parallel machine). This shows that Pika elastic design is able to handle a wide range of situations gracefully.</p> <p>One of the keys to its excellent performance is Pika's load balancing algorithm. We evaluated several algorithms and found that a Tournament scheme with a tariff of 2 had the best ability to maintain short services times when faced with highly asymmetric application response times. &nbsp;Our results show that global coordinated load balancing is crucial for effe...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Current computer operating systems were designed in an era when computation was the most critical resource in a machine. In the multicore era, the landscape has fundamentally changed.  With the expected exponential increase in number of cores per processor, the question is no longer how to cope with limited resources, but rather how to make the most of the abundant computation available.  This project investigated some of the design decisions and challenges that will be encountered as operating systems evolve for this new computing landscape.  Specifically, we sought to answer the following high-level questions:  Can an operating system service be effectively implemented using a set (or "fleet") of cooperating server processes running on different cores within a large multicore processor? How should that fleet adapt to changes in workload or availability of resources?   Our initial explorations were made in the context of the experimental "fos" operating system.  We designed a new naming service that is used by applications to find a particular service they need.  Having this layer of indirection between the applications and services allows the fleets of servers to dynamically grow, shrink, migrate or reconfigure themselves as needed.  We call this ability to adapt "elasticity."  We prototyped an elastic filesystem in fos and showed that it was able to respond well to changes in demand using only simple heuristics to grow and shrink the filesystem fleet.  Finally, we designed an elastic networking service for fos by refactoring and partitioning the work it performs in novel ways.  It distributes the workload across a parallel fleet of servers that is capable of growing and shrinking as required.  More details on these can be found in the academic papers published under the fos project.  In the second half of this project, we turned our attention towards applying some of the lessons we had learned to a more mainstream operating system.  We chose to implement a new networking service (called Pika) within the Linux operating system that would have greater scalability and elasticity than the default network stack.  Pika employs dedicated cores for running the network stack which are distinct from application cores. Furthermore, Pika splits the network stack into various conceptual component servers based on functionality. The design of PIKA allows each of these components to either be run as stand-alone servers or combined with other components into a composite server (see Pika Architecture images). An instance of PIKA consists of one or more servers, each of which may encapsulate one or more of these components. This gives Pika the flexibility to run on both small and large machines and adapt to changes in load by adding or removing servers.  We evaluated Pika on a modern server machine with four 10-core Intel Xeon processors and compared it to the stock Linux networking stack.  Pika is able to significantly outperform stock Linux when it is allowed to run on large numbers of cores. Pika is able to achieve near-optimal scaling as the number of cores are increased, showing that it is well-equiped to handle the highly-parallel machines of the future. In addition, its performance is competitive with Linux when both are restricted to small numbers of cores (simulating a less parallel machine). This shows that Pika elastic design is able to handle a wide range of situations gracefully.  One of the keys to its excellent performance is Pika's load balancing algorithm. We evaluated several algorithms and found that a Tournament scheme with a tariff of 2 had the best ability to maintain short services times when faced with highly asymmetric application response times.  Our results show that global coordinated load balancing is crucial for effective use of parallel resources.  Finally, we evaluated both split and combined configurations of Pika and found that the combined approach is better on current high-performance cores.  However, our...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
