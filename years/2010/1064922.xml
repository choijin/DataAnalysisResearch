<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Medium: Collaborative Research: Semantics Engineering for Scripting Languages</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2011</AwardEffectiveDate>
<AwardExpirationDate>06/30/2015</AwardExpirationDate>
<AwardTotalIntnAmount>406548.00</AwardTotalIntnAmount>
<AwardAmount>406548</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Over the last decade, scripting languages have assumed a huge role. Initially web developers used Perl and Python to enrich the content of web servers; later Ruby on Rails took the scene by storm. Over the same period, JavaScript has become the dominant language on the client side of the web. Additionally, the popularity of scripting language has inspired developers to use them for the construction of many other kinds of systems, including mission-critical real-time systems. &lt;br/&gt;&lt;br/&gt;While scripting languages are productive tools for the exploration of design ideas, their use also introduces several new kinds of problems into the software cycle. Most basically, scripting languages tend to lack a type system, which tends to raise the debugging and maintenance costs for systems. Worse, even though scripting languages tend to be safe, their flexible primitive operations induce difficult-to-predict behavior in programs and thus creates novel kinds of security holes. At the same time, scripting languages do not come with a well-defined semantics, making it nearly impossible to validate the soundness of a program analysis for safety or security properties.&lt;br/&gt;&lt;br/&gt;In response to these observations, this proposal promises to re-engineer the semantics of scripting languages. Specifically, the PIs propose to investigate the construction of executable semantics for three scripting languages: JavaScript, Python, and Racket. They will use the language-level test suites to check that the semantics model the implementations adequately. In addition, the PIs will use the semantics to design and validate type systems and program analyses for these scripting languages. &lt;br/&gt;&lt;br/&gt;Over the long run, the proposal should impact the world at large in three ways. First, the type systems and analyses for scripting languages should help software developers improve the safety of their software and reduce their maintenance cost. Second, the semantics for the scripting languages will help researchers validate their ideas concerning program analyses. Finally, the PIs will develop a process for semantic re-engineering that should be useful to many additional scripting language communities.</AbstractNarration>
<MinAmdLetterDate>03/21/2011</MinAmdLetterDate>
<MaxAmdLetterDate>03/21/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1064922</AwardID>
<Investigator>
<FirstName>Matthias</FirstName>
<LastName>Felleisen</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Matthias Felleisen</PI_FULL_NAME>
<EmailAddress>matthias@ccs.neu.edu</EmailAddress>
<PI_PHON>6173732462</PI_PHON>
<NSF_ID>000286813</NSF_ID>
<StartDate>03/21/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Northeastern University</Name>
<CityName>BOSTON</CityName>
<ZipCode>021155005</ZipCode>
<PhoneNumber>6173733004</PhoneNumber>
<StreetAddress>360 HUNTINGTON AVE</StreetAddress>
<StreetAddress2><![CDATA[177-500]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001423631</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>NORTHEASTERN UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001423631</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Northeastern University]]></Name>
<CityName>BOSTON</CityName>
<StateCode>MA</StateCode>
<ZipCode>021155005</ZipCode>
<StreetAddress><![CDATA[360 HUNTINGTON AVE]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~406548</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><br />A practical programming language is an organically grown, highly complexartifact. This statement is particularly true for so-called scriptinglanguages, say Python and JavaScript, which emerged with and for the web.Most programmers therefore have a difficult time understand code in theselanguages after some time has passed and explaining it to others.</p> <p><br />This grant supported the process of re-engineering models from theselanguages. In other words, the goal was to create a framework and tools foranalyzing such scripting languages and modeling them in a concisemanner. Based on such models, the principal investigators wanted to developvariants of these scripting languages that were more like ordinary, typedmainstream programming languages. In particular, the goal was to develop atype system for the kinds of class systems that come with scriptinglanguages.&nbsp;</p> <p><br />Felleisen and his Northeastern team of PhD students focused on two aspectsof the project. On one hand, they used Findler's Redex tool to modelparticularly difficult-to-understand parts of scripting languages. Forexample, they were able to model a class system in which classes themselvesare objects, that is, instances of classes. Python and Racket fall intothis class of languages. On the other hand, they used models of first-classclasses to create a gradual type system for such class systems. A gradualtype system allows programmers to attach type annotations to one classmodule at a time; run-time checks guarantee the soundness of interactionbetween classes with types and those without. Programmers can use thesetypes to reduce the maintenance costs for scripts as well as to improvetheir security.&nbsp;</p> <p><br />While the project team realized the set goals of the project, their workalso exposes potential problems in both fields, scripting languagere-engineering with Redex as well as gradual type systems for scriptinglanguages. The work shows that Redex is a useful tool, but it has too manyshort-comings for scientists who are unfamiliar with itsimplementation. Similarly, our current work on gradual type systems revealsthat the run-time checks between typed and untyped classes are tooexpensive for any practical use. Additional work is needed to solve thesenew problems.&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 08/03/2015<br>      Modified by: Matthias&nbsp;Felleisen</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  A practical programming language is an organically grown, highly complexartifact. This statement is particularly true for so-called scriptinglanguages, say Python and JavaScript, which emerged with and for the web.Most programmers therefore have a difficult time understand code in theselanguages after some time has passed and explaining it to others.   This grant supported the process of re-engineering models from theselanguages. In other words, the goal was to create a framework and tools foranalyzing such scripting languages and modeling them in a concisemanner. Based on such models, the principal investigators wanted to developvariants of these scripting languages that were more like ordinary, typedmainstream programming languages. In particular, the goal was to develop atype system for the kinds of class systems that come with scriptinglanguages.    Felleisen and his Northeastern team of PhD students focused on two aspectsof the project. On one hand, they used Findler's Redex tool to modelparticularly difficult-to-understand parts of scripting languages. Forexample, they were able to model a class system in which classes themselvesare objects, that is, instances of classes. Python and Racket fall intothis class of languages. On the other hand, they used models of first-classclasses to create a gradual type system for such class systems. A gradualtype system allows programmers to attach type annotations to one classmodule at a time; run-time checks guarantee the soundness of interactionbetween classes with types and those without. Programmers can use thesetypes to reduce the maintenance costs for scripts as well as to improvetheir security.    While the project team realized the set goals of the project, their workalso exposes potential problems in both fields, scripting languagere-engineering with Redex as well as gradual type systems for scriptinglanguages. The work shows that Redex is a useful tool, but it has too manyshort-comings for scientists who are unfamiliar with itsimplementation. Similarly, our current work on gradual type systems revealsthat the run-time checks between typed and untyped classes are tooexpensive for any practical use. Additional work is needed to solve thesenew problems.           Last Modified: 08/03/2015       Submitted by: Matthias Felleisen]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
