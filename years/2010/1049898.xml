<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER: Rapid Updates and Snapshot-Based Queries Using Multicore Processors</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2010</AwardEffectiveDate>
<AwardExpirationDate>08/31/2013</AwardExpirationDate>
<AwardTotalIntnAmount>150000.00</AwardTotalIntnAmount>
<AwardAmount>150000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05020000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>IIS</Abbreviation>
<LongName>Div Of Information &amp; Intelligent Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Frank Olken</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>Applications such as traffic monitoring, mobile user management, and sensor networks need to process large volumes of updates while supporting on-line analytic queries.  With large amounts of RAM, single machines are potentially able to manage hundreds of millions of items.  With multiple hardware threads, as many as 64 on modern commodity multicore chips, many operations can be processed concurrently.&lt;br/&gt;&lt;br/&gt;Processing queries and updates concurrently can cause interference. Queries need to see a consistent database state, meaning that at least some of the time, updates will need to wait for queries to complete. To address this problem, a variety of solutions are explored in which a RAM-resident snapshot of the database is taken at various points in time.  Analytic queries operate over the snapshot, eliminating interference, but allowing answers to be slightly out of date. Several different snapshot creation methods are being developed and studied, with the goal of being able to create snapshots rapidl(e.g., in fractions of a second) while minimizing the overhead on update processing.&lt;br/&gt;&lt;br/&gt;These problems are studied both for traditional server machines, as well as for multicore mobile devices.  By keeping personalized, up to date data on a user's mobile device, a wide range of potential new applications could be supported while avoiding the privacy concerns of widely distributing one's location.  The research focus is on how to efficiently utilize the many processing cores available on modern machines, both traditional and mobile devices.  A primary goal is to allow performance to scale as additional cores become available in newer generations of hardware.&lt;br/&gt;&lt;br/&gt;The website for this project can be found at http://www.cs.columbia.edu/~kar/snapshot.html</AbstractNarration>
<MinAmdLetterDate>08/24/2010</MinAmdLetterDate>
<MaxAmdLetterDate>08/24/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1049898</AwardID>
<Investigator>
<FirstName>Kenneth</FirstName>
<LastName>Ross</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Kenneth A Ross</PI_FULL_NAME>
<EmailAddress>kar@cs.columbia.edu</EmailAddress>
<PI_PHON>2129397058</PI_PHON>
<NSF_ID>000446976</NSF_ID>
<StartDate>08/24/2010</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Columbia University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100276902</ZipCode>
<PhoneNumber>2128546851</PhoneNumber>
<StreetAddress>2960 Broadway</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049179401</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049179401</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Columbia University]]></Name>
<CityName>NEW YORK</CityName>
<StateCode>NY</StateCode>
<ZipCode>100276902</ZipCode>
<StreetAddress><![CDATA[2960 Broadway]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7364</Code>
<Text>Info Integration &amp; Informatics</Text>
</ProgramElement>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2010~150000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Modern computers have many processor cores that are able to perform computation in parallel. In applications such as database systems, there are many concurrent activities that access and modify shared data. &nbsp;To make sure that different activites do not over-write each other's data, access to shared data must be controlled. &nbsp;For example, one activity (e.g., a query) may be held up until another (e.g., a transaction that updates some data) is done with the modified data. &nbsp;The different activites can therefore interfere with each other, causing delays. &nbsp;A large number of stalls of this kind can hinder performance and reduce the utilization of the machine.</p> <p>This project aims to design data-processing algorithms that reduce these delays. &nbsp;For example, one may allow queries to look at very slightly out-of-date data in order to decouple two activities (a reader and an updater) that would otherwise interfere. &nbsp;We focus on applications motivated by databases of moving objects, such as vehicles in a geographic area. &nbsp;Updates correspond to moving vehicles, and queries can measure traffic densities and other features relevant to route planning.</p> <p>In a series of papers, we provide a variety of techniques that allow high concurrent update rates and query volumes. &nbsp;At the same time, the "staleness" of the queried data is minimal; typically the queried data is within a few tens of milliseconds of being current. &nbsp;Using the proposed methods, very frequent snapshots of the entire database can be achieved.</p> <p>Another performance sensitive aspect of query processing on multicore machines is aggregation, where some total measure (e.g., count, sum of sales) of a large dataset is computed. &nbsp;We provide aggregation techniques that allow many cores to cooperatively compute a common aggregation query with minimal interference. &nbsp;We also show how a specialized aggregation method can be much more efficient if one is interested only in categories with the highest counts.</p> <p>&nbsp;</p><br> <p>            Last Modified: 10/29/2013<br>      Modified by: Kenneth&nbsp;A&nbsp;Ross</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Modern computers have many processor cores that are able to perform computation in parallel. In applications such as database systems, there are many concurrent activities that access and modify shared data.  To make sure that different activites do not over-write each other's data, access to shared data must be controlled.  For example, one activity (e.g., a query) may be held up until another (e.g., a transaction that updates some data) is done with the modified data.  The different activites can therefore interfere with each other, causing delays.  A large number of stalls of this kind can hinder performance and reduce the utilization of the machine.  This project aims to design data-processing algorithms that reduce these delays.  For example, one may allow queries to look at very slightly out-of-date data in order to decouple two activities (a reader and an updater) that would otherwise interfere.  We focus on applications motivated by databases of moving objects, such as vehicles in a geographic area.  Updates correspond to moving vehicles, and queries can measure traffic densities and other features relevant to route planning.  In a series of papers, we provide a variety of techniques that allow high concurrent update rates and query volumes.  At the same time, the "staleness" of the queried data is minimal; typically the queried data is within a few tens of milliseconds of being current.  Using the proposed methods, very frequent snapshots of the entire database can be achieved.  Another performance sensitive aspect of query processing on multicore machines is aggregation, where some total measure (e.g., count, sum of sales) of a large dataset is computed.  We provide aggregation techniques that allow many cores to cooperatively compute a common aggregation query with minimal interference.  We also show how a specialized aggregation method can be much more efficient if one is interested only in categories with the highest counts.          Last Modified: 10/29/2013       Submitted by: Kenneth A Ross]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
