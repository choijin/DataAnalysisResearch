<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: System-Wide Intrusion Recovery Using Selective Re-execution</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/01/2011</AwardEffectiveDate>
<AwardExpirationDate>03/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>450000.00</AwardTotalIntnAmount>
<AwardAmount>450000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Virtually any computer system can be compromised.  New software vulnerabilities are discovered and exploited daily, and even if software were bug-free, unaware users may install malware along with free screensavers or greeting cards they download online. Cleaning up after these inevitable compromises leads to days of wasted effort by users or system administrators, with no conclusive guarantee that all traces of the attack are gone, or that no legitimate changes are lost.&lt;br/&gt;&lt;br/&gt;This research project automates recovery from intrusions by developing a system-wide undo mechanism, so that an administrator can undo an attacker's break-in attempt, along with all of its side-effects, while preserving all other legitimate operations. The key idea is to log all computations, such as processes or system calls, and the dependencies between them, so that if one operation needs to be undone, the system can both undo its direct effects, and recursively track down and re-execute other operations that may have been indirectly affected.  Building on this basic approach, the project explores how computer systems must change to securely and efficiently provide system-wide undo, from operating system kernels, to programming languages, to applications and user interfaces.&lt;br/&gt;&lt;br/&gt;If successful, this project will provide a principled approach to recovering from intrusions in computer systems.  More broadly, system-wide undo may help in many situations, such as users that realize they changed the wrong setting a week ago, students that want to learn a new system by exploring and undoing, or application developers that want to experiment with a large-scale system.</AbstractNarration>
<MinAmdLetterDate>01/25/2011</MinAmdLetterDate>
<MaxAmdLetterDate>04/28/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1053143</AwardID>
<Investigator>
<FirstName>Nickolai</FirstName>
<LastName>Zeldovich</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Nickolai Zeldovich</PI_FULL_NAME>
<EmailAddress>nickolai@csail.mit.edu</EmailAddress>
<PI_PHON>6172536005</PI_PHON>
<NSF_ID>000520788</NSF_ID>
<StartDate>01/25/2011</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[NE18-901]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001425594</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>MASSACHUSETTS INSTITUTE OF TECHNOLOGY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001425594</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Massachusetts Institute of Technology]]></Name>
<CityName>Cambridge</CityName>
<StateCode>MA</StateCode>
<ZipCode>021394301</ZipCode>
<StreetAddress><![CDATA[77 MASSACHUSETTS AVE]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2011~82070</FUND_OBLG>
<FUND_OBLG>2012~85893</FUND_OBLG>
<FUND_OBLG>2013~89661</FUND_OBLG>
<FUND_OBLG>2014~94139</FUND_OBLG>
<FUND_OBLG>2015~98237</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Despite our best efforts to build secure computer systems, intrusions are nearly unavoidable in practice. &nbsp;When faced with an intrusion, a user is typically forced to reinstall their system from scratch, and to manually recover any documents and settings they might have had. &nbsp;Even if the user diligently makes a complete backup of their system every day, recovering from the attack requires rolling back to the most recent backup before the attack, thereby losing any changes made since then. &nbsp;Since many adversaries go to great lengths to prevent the compromise from being discovered, it can take days or weeks for a user to discover that their machine has been broken into, resulting in a loss of all user work from that period of time.</p> <p>This project developed system-wide intrusion recovery using the idea of selective re-execution. &nbsp;In this approach, the system periodically takes checkpoints of the system state, and continuously records all inputs (such as incoming requests from the network or a user's keyboard input) as well as internal dependencies between different programs (such as a user's text editor, mail client, and web browser). &nbsp;When an administrator determines that an attack has taken place, the system rolls back the affected parts of the system, and re-executes any programs that might have been affected, using the recorded inputs and dependencies. &nbsp;This allows an administrator to remove the effects of an attack while preserving legitimate user changes.</p> <p>To make system-wide intrusion recovery possible, this project explored two main research directions: first, how to build secure systems that can prevent an adversary from tampering with a system-wide log, and second, how to use this log to recover from different types of attacks.</p> <p>On the secure systems front, this project developed several bug-finding tools (KINT and STACK) that can analyze existing C and C++ source code to discover common types of security errors. &nbsp;This work led to hundreds of security bugs being fixed in widely used open-source software, including the Linux kernel, the Chrome and Firefox web browsers, the Python runtime, the Kerberos security protocol implementation, and many others. &nbsp;The tools developed as part of this effort have been picked up in parts by several organizations, including Google, Intel, Dropbox, and Mozilla. &nbsp;Finally, the C++ standards committee started to re-examine a subtle issue in their language specification, called ``undefined behavior'', which we demonstrated leads to serious security issues.</p> <p>To build systems without the possibility of programming mistakes, this project developed formally verified kernel subsystems that are accompanied by machine-checked proofs of their correctness. &nbsp;In particular, we developed a formally verified BPF interpreter for the Linux kernel, which is used by the SECCOMP subsystem to isolate untrusted processes, and we developed the FSCQ file system, which comes with a proof that the file system will remain intact even if the computer crashes and reboots at any time. &nbsp;The formal proofs guarantee that the implementation meets the formal specification of that kernel subsystem, and eliminates the possibility of bugs like the ones we discovered using KINT and STACK.</p> <p>On top of a tamper-proof logging system, this project demonstrated how intrusion recovery can be used to restore the integrity of an operating system, web application, or distributed system after an attack, and how intrusion recovery can also be used to identify what confidential user data may have been disclosed.</p> <p>A key technique developed in this project was the idea of retroactive patching, which conceptually allows an administrator to apply security patches in the past. &nbsp;When the software developer discovers a vulnerability in their application code, they develop a patch and distribute this patch to all users of their software. &nbsp;Retroactive patching re-runs all past operations (such as network requests to a server) using the newly patched code. &nbsp;If some request runs the same way with the patched code as it did with the original code, then the request did not exploit the bug fixed by the software developer, and no further action is needed. &nbsp;On the other hand, if the request runs differently with the patched code, this indicates a possible attack, and intrusion recovery can be used to undo its effects.</p><br> <p>            Last Modified: 07/16/2017<br>      Modified by: Nickolai&nbsp;Zeldovich</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Despite our best efforts to build secure computer systems, intrusions are nearly unavoidable in practice.  When faced with an intrusion, a user is typically forced to reinstall their system from scratch, and to manually recover any documents and settings they might have had.  Even if the user diligently makes a complete backup of their system every day, recovering from the attack requires rolling back to the most recent backup before the attack, thereby losing any changes made since then.  Since many adversaries go to great lengths to prevent the compromise from being discovered, it can take days or weeks for a user to discover that their machine has been broken into, resulting in a loss of all user work from that period of time.  This project developed system-wide intrusion recovery using the idea of selective re-execution.  In this approach, the system periodically takes checkpoints of the system state, and continuously records all inputs (such as incoming requests from the network or a user's keyboard input) as well as internal dependencies between different programs (such as a user's text editor, mail client, and web browser).  When an administrator determines that an attack has taken place, the system rolls back the affected parts of the system, and re-executes any programs that might have been affected, using the recorded inputs and dependencies.  This allows an administrator to remove the effects of an attack while preserving legitimate user changes.  To make system-wide intrusion recovery possible, this project explored two main research directions: first, how to build secure systems that can prevent an adversary from tampering with a system-wide log, and second, how to use this log to recover from different types of attacks.  On the secure systems front, this project developed several bug-finding tools (KINT and STACK) that can analyze existing C and C++ source code to discover common types of security errors.  This work led to hundreds of security bugs being fixed in widely used open-source software, including the Linux kernel, the Chrome and Firefox web browsers, the Python runtime, the Kerberos security protocol implementation, and many others.  The tools developed as part of this effort have been picked up in parts by several organizations, including Google, Intel, Dropbox, and Mozilla.  Finally, the C++ standards committee started to re-examine a subtle issue in their language specification, called ``undefined behavior'', which we demonstrated leads to serious security issues.  To build systems without the possibility of programming mistakes, this project developed formally verified kernel subsystems that are accompanied by machine-checked proofs of their correctness.  In particular, we developed a formally verified BPF interpreter for the Linux kernel, which is used by the SECCOMP subsystem to isolate untrusted processes, and we developed the FSCQ file system, which comes with a proof that the file system will remain intact even if the computer crashes and reboots at any time.  The formal proofs guarantee that the implementation meets the formal specification of that kernel subsystem, and eliminates the possibility of bugs like the ones we discovered using KINT and STACK.  On top of a tamper-proof logging system, this project demonstrated how intrusion recovery can be used to restore the integrity of an operating system, web application, or distributed system after an attack, and how intrusion recovery can also be used to identify what confidential user data may have been disclosed.  A key technique developed in this project was the idea of retroactive patching, which conceptually allows an administrator to apply security patches in the past.  When the software developer discovers a vulnerability in their application code, they develop a patch and distribute this patch to all users of their software.  Retroactive patching re-runs all past operations (such as network requests to a server) using the newly patched code.  If some request runs the same way with the patched code as it did with the original code, then the request did not exploit the bug fixed by the software developer, and no further action is needed.  On the other hand, if the request runs differently with the patched code, this indicates a possible attack, and intrusion recovery can be used to undo its effects.       Last Modified: 07/16/2017       Submitted by: Nickolai Zeldovich]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
