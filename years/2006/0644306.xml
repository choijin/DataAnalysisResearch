<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Automatically Generating and Processing Program Analyses and Optimizations</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/15/2007</AwardEffectiveDate>
<AwardExpirationDate>03/31/2012</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>John Reppy</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>Developing efficient, scalable, correct, and precise program analyzers and optimizers is difficult. There is a long time, often up to a decade, before a new optimizing compiler is mature enough to be widely used. These difficulties hinder the development of new languages and new architectures, and can also discourage end-user programmers from extending compilers with domain-specific checkers or optimizers.&lt;br/&gt;&lt;br/&gt;Techniques will be investigated for automatically generating efficient, scalable, correct, and precise dataflow analyzers and optimizers from a very high-level specification. The overarching theme is to understand the underlying principles behind designing program analyses and optimizations, and use this understanding to automate as much as possible the analyzer- and optimizer-writing process. Attempting to automate the process of writing analyzers and optimizers enables many new kinds of usage models for compilers, including: allowing end-user programmers to easily extend the compiler with domain-specific checkers or optimizers; allowing end-user programmers to continuously train the compiler, even after it is deployed, based on additional input-output examples; and automatically generating additional analyses when the optimizer discovers the need for new dataflow information, and linking these new analyses into the optimizer while in execution.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>04/12/2007</MinAmdLetterDate>
<MaxAmdLetterDate>04/11/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0644306</AwardID>
<Investigator>
<FirstName>Sorin</FirstName>
<LastName>Lerner</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Sorin Lerner</PI_FULL_NAME>
<EmailAddress>lerner@cs.ucsd.edu</EmailAddress>
<PI_PHON>8585348883</PI_PHON>
<NSF_ID>000068847</NSF_ID>
<StartDate>04/12/2007</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-San Diego</Name>
<CityName>La Jolla</CityName>
<ZipCode>920930934</ZipCode>
<PhoneNumber>8585344896</PhoneNumber>
<StreetAddress>Office of Contract &amp; Grant Admin</StreetAddress>
<StreetAddress2><![CDATA[9500 Gilman Drive, 0934]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>49</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA49</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>804355790</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CALIFORNIA, SAN DIEGO</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-San Diego]]></Name>
<CityName>La Jolla</CityName>
<StateCode>CA</StateCode>
<ZipCode>920930934</ZipCode>
<StreetAddress><![CDATA[Office of Contract &amp; Grant A]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>49</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA49</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7352</Code>
<Text>COMPUTING PROCESSES &amp; ARTIFACT</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0107</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2007~80000</FUND_OBLG>
<FUND_OBLG>2008~80000</FUND_OBLG>
<FUND_OBLG>2009~80000</FUND_OBLG>
<FUND_OBLG>2010~80000</FUND_OBLG>
<FUND_OBLG>2011~80000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The compiler is a tool that is central to the development of software. Its role is to translate the human-readable code written by a programmer into machine code that a computer can understand. In the process of doing this translation, the compiler performs many important improvements to the code so that the final code runs as fast as possible. These improvements are commonly referered to as "optimizations", and they play a critical role in the compiler.&nbsp;</p> <p>Where do optimizations come from? Currently, the programmer who develops the compiler writes these optimizations via a process that is laborious, error-prone, and often considered an art. The intellectual merit of this project is to investigate and develop new techniques for making this optimization-writing process not only less laborious but also less error-prone.</p> <p>In particular, advances made under this project now provide compiler programmers with a much easier path to writing optimizations: instead of engineering an optimization by manually writing every single detail of the optimization, programmers can instead "train" the compiler by showing examples of what it should be doing. The compiler can learn from these examples, and automatically come up with a general optimization, without programmers having to specify the details.</p> <p>The broader impact of this research is that it will reduce the cost of developing good and reliable optimizations, which in the end will lead to better compilers, and ultimately more reliable and efficient software.</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modified: 07/03/2012<br>      Modified by: Sorin&nbsp;Lerner</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The compiler is a tool that is central to the development of software. Its role is to translate the human-readable code written by a programmer into machine code that a computer can understand. In the process of doing this translation, the compiler performs many important improvements to the code so that the final code runs as fast as possible. These improvements are commonly referered to as "optimizations", and they play a critical role in the compiler.   Where do optimizations come from? Currently, the programmer who develops the compiler writes these optimizations via a process that is laborious, error-prone, and often considered an art. The intellectual merit of this project is to investigate and develop new techniques for making this optimization-writing process not only less laborious but also less error-prone.  In particular, advances made under this project now provide compiler programmers with a much easier path to writing optimizations: instead of engineering an optimization by manually writing every single detail of the optimization, programmers can instead "train" the compiler by showing examples of what it should be doing. The compiler can learn from these examples, and automatically come up with a general optimization, without programmers having to specify the details.  The broader impact of this research is that it will reduce the cost of developing good and reliable optimizations, which in the end will lead to better compilers, and ultimately more reliable and efficient software.                Last Modified: 07/03/2012       Submitted by: Sorin Lerner]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
