<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Hybrid Atomicity Checking</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/15/2007</AwardEffectiveDate>
<AwardExpirationDate>03/31/2013</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>John Reppy</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>The construction and validation of reliable multi-threaded programs is extremely difficult.  Threads can improve performance on multi-processor machines and multi-core processors by enabling a program to execute more than one routine simultaneously, but unintended interactions between threads are hard to recognize during testing and are a common source of errors in deployed systems.&lt;br/&gt;&lt;br/&gt;This research develops hybrid checkers that prevent unintended thread interactions by ensuring that a program's routines are atomic.  A routine is atomic if its execution is not affected by and does not interfere with concurrently-executing threads.  Previous work on static atomicity checkers (that inspect source code) and dynamic atomicity checkers (that monitor running programs) demonstrate the potential advantages of enforcing atomicity requirements.  However, these approaches have precision or coverage limitations that reduce their ability to check large systems effectively.  Hybrid checkers synthesize the best aspects of both techniques without suffering from these limitations.&lt;br/&gt;&lt;br/&gt;The impacts of hybrid atomicity checkers, and their integration into a broad educational program, include improved software quality and better software engineering practices.  Specifically, hybrid checkers provide a cost-effective mechanism for finding errors resistant to testing, are more usable and scalable than existing tools, and support a design methodology that encourages precisely specifying interactions between threads.&lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>04/13/2007</MinAmdLetterDate>
<MaxAmdLetterDate>04/06/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0644130</AwardID>
<Investigator>
<FirstName>Stephen</FirstName>
<LastName>Freund</LastName>
<PI_MID_INIT>N</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephen N Freund</PI_FULL_NAME>
<EmailAddress>freund@cs.williams.edu</EmailAddress>
<PI_PHON>4135974260</PI_PHON>
<NSF_ID>000110974</NSF_ID>
<StartDate>04/13/2007</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Williams College</Name>
<CityName>Williamstown</CityName>
<ZipCode>012672600</ZipCode>
<PhoneNumber>4135974352</PhoneNumber>
<StreetAddress>880 Main St.</StreetAddress>
<StreetAddress2><![CDATA[Hopkins Hall]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>020665972</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PRESIDENT &amp; TRUSTEES OF WILLIAMS COLLEGE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>020665972</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Williams College]]></Name>
<CityName>Williamstown</CityName>
<StateCode>MA</StateCode>
<ZipCode>012672600</ZipCode>
<StreetAddress><![CDATA[880 Main St.]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7352</Code>
<Text>COMPUTING PROCESSES &amp; ARTIFACT</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0107</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2007~75414</FUND_OBLG>
<FUND_OBLG>2008~98793</FUND_OBLG>
<FUND_OBLG>2009~75925</FUND_OBLG>
<FUND_OBLG>2010~73872</FUND_OBLG>
<FUND_OBLG>2011~75996</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><br />Computers now play a central role in virtually all parts of society,<br />and we rely on computing systems to correctly perform many tasks on<br />our behalf.&nbsp; At the same time, however, designing and implementing<br />reliable software systems remains perhaps the greatest challenge<br />facing the computing industry today.&nbsp; Despite great efforts to ensure<br />reliability, software errors still occur, sometimes with costly<br />consequences.&nbsp; Defects may be costly to find and fix, result in loss<br />of data, enable security breaches, and even endanger lives.<br /><br />The problem of ensuring software reliability has been made even more<br />challenging by the widespread adoption of multi-processor computers<br />and multi-core processors.&nbsp; These hardware architectures enable<br />programs to perform multiple tasks at the same time, and designing<br />software to have such multiple threads of control running concurrency<br />is widely believed to be the most promising way to achieve further<br />performance improvements for many computer systems.&nbsp; <br /><br />However, threads may interfere with each other in subtle ways if the<br />programmer does not properly coordinate (or synchronize) their<br />behavior.&nbsp; Errors caused by unanticipated thread interactions are<br />common but particularly difficult to discover during testing since<br />they typically happen only intermittently and are discovered only long<br />after the damaging interference actually occurs.<br /><br />In this grant, we examined automated software validation tools for<br />finding concurrency defects.&nbsp; Programmers can use such tools to<br />identify problems in software during development before they are<br />experienced by users.&nbsp; Automated checking tools have proven quite<br />useful at finding and eliminating other kinds of software defects, but<br />they have traditionally been difficult to use and ineffective for<br />finding synchronization defects in concurrent software.<br /><br />Our basic validation approach is to have programmers place "atomic"<br />specifications on regions of source code that should be free of<br />interference with all other threads.&nbsp; Those specifications, as well as<br />other specifications describing how threads are coordinated, are then<br />verified for correctness by an automated checker.&nbsp; If a code fragment<br />does not exhibit the specified property, a warning is reported to the<br />programmer.&nbsp; We focused on a synthesis of complementary analyses from<br />static checkers (that inspect source code) and dynamic checkers (that<br />monitor running programs) to enforce this type of requirement.&nbsp; This<br />hybrid approach scales better and increases precision over previous<br />work, as shown when we applied our techniques to validate a variety of<br />programs.<br /><br />The intellectual merit and scientific contributions of this work<br />include the development of techniques pushing forward the state of the<br />art on how to check for interference errors in concurrent programs.<br />The techniques studied are able to find concurrency defects ranging<br />from the most-basic type of conflict when two threads access a<br />specific memory location simultaneously without coordination to more<br />subtle atomicity or <span><span>serializability</span></span> problems that require enforcing<br />proper thread synchronization across much longer sequences of<br />operations.&nbsp; <br /><br />We have also built and now distribute an open source analysis<br />framework that serves as a test bed for new ideas in concurrency<br />analyses. This framework has already been used extensively by both us<br />and others.<br /><br />This work has contributed to computer science education in several<br />ways. Numerous undergraduate students were trained to perform<br />scientific research as part of this...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  Computers now play a central role in virtually all parts of society, and we rely on computing systems to correctly perform many tasks on our behalf.  At the same time, however, designing and implementing reliable software systems remains perhaps the greatest challenge facing the computing industry today.  Despite great efforts to ensure reliability, software errors still occur, sometimes with costly consequences.  Defects may be costly to find and fix, result in loss of data, enable security breaches, and even endanger lives.  The problem of ensuring software reliability has been made even more challenging by the widespread adoption of multi-processor computers and multi-core processors.  These hardware architectures enable programs to perform multiple tasks at the same time, and designing software to have such multiple threads of control running concurrency is widely believed to be the most promising way to achieve further performance improvements for many computer systems.    However, threads may interfere with each other in subtle ways if the programmer does not properly coordinate (or synchronize) their behavior.  Errors caused by unanticipated thread interactions are common but particularly difficult to discover during testing since they typically happen only intermittently and are discovered only long after the damaging interference actually occurs.  In this grant, we examined automated software validation tools for finding concurrency defects.  Programmers can use such tools to identify problems in software during development before they are experienced by users.  Automated checking tools have proven quite useful at finding and eliminating other kinds of software defects, but they have traditionally been difficult to use and ineffective for finding synchronization defects in concurrent software.  Our basic validation approach is to have programmers place "atomic" specifications on regions of source code that should be free of interference with all other threads.  Those specifications, as well as other specifications describing how threads are coordinated, are then verified for correctness by an automated checker.  If a code fragment does not exhibit the specified property, a warning is reported to the programmer.  We focused on a synthesis of complementary analyses from static checkers (that inspect source code) and dynamic checkers (that monitor running programs) to enforce this type of requirement.  This hybrid approach scales better and increases precision over previous work, as shown when we applied our techniques to validate a variety of programs.  The intellectual merit and scientific contributions of this work include the development of techniques pushing forward the state of the art on how to check for interference errors in concurrent programs. The techniques studied are able to find concurrency defects ranging from the most-basic type of conflict when two threads access a specific memory location simultaneously without coordination to more subtle atomicity or serializability problems that require enforcing proper thread synchronization across much longer sequences of operations.    We have also built and now distribute an open source analysis framework that serves as a test bed for new ideas in concurrency analyses. This framework has already been used extensively by both us and others.  This work has contributed to computer science education in several ways. Numerous undergraduate students were trained to perform scientific research as part of this grant.  Four of these students are now pursuing graduate degrees in computer science.  In addition, we have participated in a number of curricular efforts to improve computer science education, particularly in the area of programming languages and concurrent programming.  As part of these efforts, we developed several new models for an undergraduate curriculum in our discipline.  Those curricular ideas, as well as results from this research agenda, have been inte...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
