<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Achieving Self-Tunability of Peer-to-Peer Streaming Service through User-Level QoS Inference</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>01/01/2007</AwardEffectiveDate>
<AwardExpirationDate>12/31/2012</AwardExpirationDate>
<AwardTotalIntnAmount>319371.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Joseph Lyles</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>This project aims to build a self-tuning multimedia streaming service that optimizes the user viewing experience by analyzing user behavior, inferring personalized quality of service (QoS) requirements, and tuning system and network resources to maximize utilities of all users. The advent of peer-to-peer (P2P) technology has provided the ideal playground for this research. Traces from operating P2P streaming systems provide rich datasets with which to study the influence of QoS factors on users' viewing experience. In addition, the affordability of a P2P streaming testbed provides both the sandbox to test research ideas and a general educational platform accessible to a large Internet user base.&lt;br/&gt;&lt;br/&gt;This CAREER project has two complementary tracks: use-level QoS modeling and QoS-aware resource allocation. On the modeling track, the user utility function is formulated using statistical tools such as regression analysis to infer the influence of individual network- and system-level QoS factors on the user behaviors (e.g., skipping, changing channel, or premature leave), which reflect the subjective user viewing experience. On the resource allocation track, the problem is studied using a time-aware multi-dimensional optimization framework, which helps address the unique challenges posed by the semantics of a P2P system, e.g., how to inclusively optimize the resource allocation under heterogeneous user utility functions. &lt;br/&gt;&lt;br/&gt;Broader Impact:&lt;br/&gt;&lt;br/&gt;This research plan is expected to incubate the emergence of an extremely cost-effective and scalable P2P service platform as the innovation hotbed to significantly lower the entry barrier for new media-rich applications. The analytical outcome from user behavior study will also bring strategic insights and design guidelines applicable to all multimedia service paradigms beyond P2P.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>12/21/2006</MinAmdLetterDate>
<MaxAmdLetterDate>01/14/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0643488</AwardID>
<Investigator>
<FirstName>Yi</FirstName>
<LastName>Cui</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Yi Cui</PI_FULL_NAME>
<EmailAddress>yi.cui@vanderbilt.edu</EmailAddress>
<PI_PHON>6153222631</PI_PHON>
<NSF_ID>000302234</NSF_ID>
<StartDate>12/21/2006</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Vanderbilt University</Name>
<CityName>Nashville</CityName>
<ZipCode>372350002</ZipCode>
<PhoneNumber>6153222631</PhoneNumber>
<StreetAddress>Sponsored Programs Administratio</StreetAddress>
<StreetAddress2><![CDATA[PMB 407749 2301 Vanderbilt Place]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Tennessee</StateName>
<StateCode>TN</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TN05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>965717143</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>VANDERBILT UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>004413456</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Vanderbilt University]]></Name>
<CityName>Nashville</CityName>
<StateCode>TN</StateCode>
<ZipCode>372350002</ZipCode>
<StreetAddress><![CDATA[Sponsored Programs Administratio]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Tennessee</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TN05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>4090</Code>
<Text>ADVANCED NET INFRA &amp; RSCH</Text>
</ProgramElement>
<ProgramElement>
<Code>7363</Code>
<Text>Networking Technology and Syst</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>7363</Code>
<Text>RES IN NETWORKING TECH &amp; SYS</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0107</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2007~78848</FUND_OBLG>
<FUND_OBLG>2008~79237</FUND_OBLG>
<FUND_OBLG>2009~160548</FUND_OBLG>
<FUND_OBLG>2011~81367</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><h2>Background</h2> <p>Towards the beginning of this project, we were searching for a P2P solution with minimum intrusion to the user experience. At the time, the mainstream P2P streaming solution were desktop rich applications such as PPStreaming, PPLive, etc. But users had already spending increasing amount of time on YouTube among other web portals. So we thought there should be some light-weight approaches that deal with transportation of the videos as plain data objects, and let those websites and their Flash players worry about the rest.</p> <p><a href="https://github.com/downloads/yicui/BitTube/architecture.jpg" target="_blank"><img src="https://github.com/downloads/yicui/BitTube/architecture.jpg" alt="BitTube architecture" /></a></p> <h2><a class="anchor" name="architecture" href="https://github.com/yicui/BitTube#architecture"></a>Architecture</h2> <p>Hence we created the architecture as above, the downloading stub sits on user's desktop machine and intercepts all HTTP GET requests destined to the port(s) it listens on. It then turns to the P2P world to download the requested data and wraps it in a HTTP response back to the requester, that's it. Also given the fact that BitTorrent was already the de facto standard for P2P content sharing, we decided to make our software interoperable with other programs of the&nbsp;<a href="http://en.wikipedia.org/wiki/Comparison_of_BitTorrent_software">BiTorrent family</a>, hence the name BitTube.</p> <p>Our first version was adapted from the Python source code of the original BitTorrent client, then we quickly realized that this doesn't fit the video&nbsp;<strong>streaming</strong>&nbsp;scenario, where you must sequentially download the video and return any downloaded piece to your player ASAP. With this regard, the sophisticated "rarest first" and "tit-for-tat" policies of BitTorrent have little relevance in our context, so we replaced it with our own C++ implementation, now open sourced at <a href="https://github.com/yicui/BitTube-on-Flash">https://github.com/yicui/BitTube</a>.</p> <p>BitTube runs as a single-threaded event loop. In each cycle, it relies on the select() function (we choose non-blocking) to monitor all of its connections (tracker, other peers, its own listening port for requests from the browser, etc.) for any connect/read/write action. Also in case you are the only peer online or other peers cannot send you data fast enough to sustain your streaming, you have to fall back to the HTTP server of the original content provider. It's rather easier to consider the HTTP server as a super peer which never goes offline. But a peer behaves a lot different from a server: instead of retrieving the whole chunk of video file which is slow and wasteful, we only need get distinct pieces of the file from time to time. Here we achieve this by turning on the partial-get and keep-alive of the HTTP protocol. Looking back from now, it looks quite familar to the popular Node.js+Socket.io combination in today's realtime web applications.</p> <p><a href="https://github.com/downloads/yicui/BitTube/federation.jpg" target="_blank"><img src="https://github.com/downloads/yicui/BitTube/federation.jpg" alt="BitTube federation" /></a></p> <p>In today's standard, this design is still quite intrusive, First, you need to download and install our program, which required a great deal of trust and effort from users. We considered Firefox plugin but still couldn't get around the downloading part. Second, we required the content publisher to change URLs of their videos as depicted above. The&nbsp;<em>localhost</em>&nbsp;prefix is crucially important, otherwise our software is unable to catch the requests. The actual URL of the video and BitTorrent tracker follow this prefix. Again, this was the best we can achieve back then. We used to argue that this is the ONLY thing you have to do (in exchange for A LOT of bandwidth saving). Plus, if you don't...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Background  Towards the beginning of this project, we were searching for a P2P solution with minimum intrusion to the user experience. At the time, the mainstream P2P streaming solution were desktop rich applications such as PPStreaming, PPLive, etc. But users had already spending increasing amount of time on YouTube among other web portals. So we thought there should be some light-weight approaches that deal with transportation of the videos as plain data objects, and let those websites and their Flash players worry about the rest.   Architecture  Hence we created the architecture as above, the downloading stub sits on user's desktop machine and intercepts all HTTP GET requests destined to the port(s) it listens on. It then turns to the P2P world to download the requested data and wraps it in a HTTP response back to the requester, that's it. Also given the fact that BitTorrent was already the de facto standard for P2P content sharing, we decided to make our software interoperable with other programs of the BiTorrent family, hence the name BitTube.  Our first version was adapted from the Python source code of the original BitTorrent client, then we quickly realized that this doesn't fit the video streaming scenario, where you must sequentially download the video and return any downloaded piece to your player ASAP. With this regard, the sophisticated "rarest first" and "tit-for-tat" policies of BitTorrent have little relevance in our context, so we replaced it with our own C++ implementation, now open sourced at https://github.com/yicui/BitTube.  BitTube runs as a single-threaded event loop. In each cycle, it relies on the select() function (we choose non-blocking) to monitor all of its connections (tracker, other peers, its own listening port for requests from the browser, etc.) for any connect/read/write action. Also in case you are the only peer online or other peers cannot send you data fast enough to sustain your streaming, you have to fall back to the HTTP server of the original content provider. It's rather easier to consider the HTTP server as a super peer which never goes offline. But a peer behaves a lot different from a server: instead of retrieving the whole chunk of video file which is slow and wasteful, we only need get distinct pieces of the file from time to time. Here we achieve this by turning on the partial-get and keep-alive of the HTTP protocol. Looking back from now, it looks quite familar to the popular Node.js+Socket.io combination in today's realtime web applications.    In today's standard, this design is still quite intrusive, First, you need to download and install our program, which required a great deal of trust and effort from users. We considered Firefox plugin but still couldn't get around the downloading part. Second, we required the content publisher to change URLs of their videos as depicted above. The localhost prefix is crucially important, otherwise our software is unable to catch the requests. The actual URL of the video and BitTorrent tracker follow this prefix. Again, this was the best we can achieve back then. We used to argue that this is the ONLY thing you have to do (in exchange for A LOT of bandwidth saving). Plus, if you don't like our tracker, feel free to use anyone's or host your own.   Epilogue  BitTube has been used to help broadcasting a few events for KTSF 26, and live broadasting of Chinese Spring Festival Gala on bigtvusa.com. Besides its C++ implementation, we also port it to the Flash player platform by utilizing Adobe's RTMFP protocol. It is also open souced to https://github.com/yicui/BitTube-on-Flash.   What's next? One thing we do know is technology of this kind needs to head to the mobile space, and it doesn't have to be restrained to streaming. Games, chat, any scenario requiring distribution of digital content to vast number of users. As of now, proprietary apps rule the mobile braodcasting domain, e.g., Qik and UStream, but we think the entry barrier will be gre...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
