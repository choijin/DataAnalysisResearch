<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER: Semi-automated Type-directed Programming</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2016</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>159991.00</AwardTotalIntnAmount>
<AwardAmount>159991</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Type-directed programming is a powerful programming paradigm found in strongly-typed functional languages where the types of a program are used to guide its development. Users of such languages frequently comment that their programs "write themselves" once they declare the appropriate types. In reality, the actual development process is far from automatic; developers still must apply manual reasoning principles to derive their program even though many of their choices are forced by the language's type system. This project aims to mechanize the type-directed programming process by leveraging techniques from program synthesis and type theory. The intellectual merits of this project are twofold: (1) the expansion of the theoretical foundations of program synthesis with types and (2) the application of these foundations towards program assistance tools that aid in type-directed programming. Beyond merely providing a tool that enhances the productivity of current functional programmers, the project's broader significance and importance is the crystallization of the benefits of type-directed programming in a form that allow non-functional programmers to understand, appreciate, and directly benefit from this programming paradigm.&lt;br/&gt;&lt;br/&gt;The project extends prior work in the foundations of program synthesis with types, addressing issues of expressiveness and scalability encountered when adopting these foundations into synthesis tools. Notably, the project unifies type-based and verification-based approaches to program synthesis, allowing rich support for both algebraic and primitive data types as well as providing a common framework for understanding both styles of synthesis.  In addition, the project investigates semi-automated, rather than fully-automated, program synthesis where the user interacts with the synthesis tool throughout the synthesis process. The basis of this approach lies in adopting the refinement tree, a data structure that captures the potential shapes of programs that a synthesizer can produce, into a useful data structure for visualizing and interacting with this tool. By pursuing semi-automated synthesis, these tools scale up to real-world programming environments by using the developer as an oracle whenever the tool would otherwise take too long or get stuck searching for a solution.</AbstractNarration>
<MinAmdLetterDate>08/12/2016</MinAmdLetterDate>
<MaxAmdLetterDate>08/12/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1651817</AwardID>
<Investigator>
<FirstName>Peter-Michael</FirstName>
<LastName>Osera</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Peter-Michael Osera</PI_FULL_NAME>
<EmailAddress>osera@cs.grinnell.edu</EmailAddress>
<PI_PHON>6412694010</PI_PHON>
<NSF_ID>000702113</NSF_ID>
<StartDate>08/12/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Grinnell College</Name>
<CityName>Grinnell</CityName>
<ZipCode>501121690</ZipCode>
<PhoneNumber>6412694983</PhoneNumber>
<StreetAddress>1121 Park Street</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Iowa</StateName>
<StateCode>IA</StateCode>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IA01</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>062763016</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF GRINNELL COLLEGE, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>062763016</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Grinnell College]]></Name>
<CityName/>
<StateCode>IA</StateCode>
<ZipCode>501121690</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Iowa</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>01</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IA01</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~159991</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software developers often balance seemingly opposing desires when choosing tools: building systems quickly and efficiently and building correct systems. This balance is especially evident in the developer's choice of programming language. Modern programming languages fall decidedly into the latter camp with features that ensure correctness but sacrifice ease of use and approachability. One such feature is a language's type system, which checks some aspects of a program's behavior before it is executed. While advanced type systems check more behavior, they can become decidedly more difficult for the programmer to use.<br />However, users of these languages have noticed a counterintuitive phenomenon with rich type systems. They comment that once they have understood how to program within the system, their programs "write themselves," a process known as type-directed programming. While true to some extent, this process is far from automatic. The developer must still write their program by hand even though the type system mostly forces their program design.<br />In this project, we studied how to automate this type-directed programming process. We identified a vital connection between the areas of program synthesis and type inference&mdash;the constraint&mdash;which allows us to use techniques from the former to implement the latter. We then built a theory of program synthesis with constraints that allowed us to extend prior techniques in the space towards synthesizing programs in languages with advanced type systems. This theory also generalized several synthesis and inference-related techniques in the field that were previously studied in isolation, allowing for further cross-pollination of ideas and methods within programming language theory. Finally, we made this theory practical by building a tool for the Haskell programming language that helps developers perform type-directed programming in a more automated fashion than what was previously possible. This tool will be made publicly available and will hopefully encourage the development of similar tools for other languages, helping spur forward the adoption of more modern programming languages in the ecosystem.</p><br> <p>            Last Modified: 12/29/2019<br>      Modified by: Peter-Michael&nbsp;Osera</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Software developers often balance seemingly opposing desires when choosing tools: building systems quickly and efficiently and building correct systems. This balance is especially evident in the developer's choice of programming language. Modern programming languages fall decidedly into the latter camp with features that ensure correctness but sacrifice ease of use and approachability. One such feature is a language's type system, which checks some aspects of a program's behavior before it is executed. While advanced type systems check more behavior, they can become decidedly more difficult for the programmer to use. However, users of these languages have noticed a counterintuitive phenomenon with rich type systems. They comment that once they have understood how to program within the system, their programs "write themselves," a process known as type-directed programming. While true to some extent, this process is far from automatic. The developer must still write their program by hand even though the type system mostly forces their program design. In this project, we studied how to automate this type-directed programming process. We identified a vital connection between the areas of program synthesis and type inference&mdash;the constraint&mdash;which allows us to use techniques from the former to implement the latter. We then built a theory of program synthesis with constraints that allowed us to extend prior techniques in the space towards synthesizing programs in languages with advanced type systems. This theory also generalized several synthesis and inference-related techniques in the field that were previously studied in isolation, allowing for further cross-pollination of ideas and methods within programming language theory. Finally, we made this theory practical by building a tool for the Haskell programming language that helps developers perform type-directed programming in a more automated fashion than what was previously possible. This tool will be made publicly available and will hopefully encourage the development of similar tools for other languages, helping spur forward the adoption of more modern programming languages in the ecosystem.       Last Modified: 12/29/2019       Submitted by: Peter-Michael Osera]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
