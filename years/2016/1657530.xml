<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CRII: SaTC: Repairing Code from Inferred Specifications of Information Flow Security</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>03/01/2017</AwardEffectiveDate>
<AwardExpirationDate>02/28/2019</AwardExpirationDate>
<AwardTotalIntnAmount>174974.00</AwardTotalIntnAmount>
<AwardAmount>182974</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>As more software computes using sensitive user data, it increasingly important to ensure that data flows only where it is permitted. Protecting sensitive data often involves reasoning about how sensitive values and policies are interacting with functionality across the program. The need to reason across the code base makes it difficult not only for programmers to implement computations using sensitive data, but also to make existing code adhere to new policies. This project investigates an approach for (1) inferring information flow policies from potentially buggy code and (2) performing program repair to ensure programs adhere to the specified policies. Not only does this approach help identify potential misuses of sensitive information, but it also helps prevent leaks in code from well-intentioned programmers, and provides a mechanism for modifying arbitrary code to satisfy a given policy.&lt;br/&gt;&lt;br/&gt;Enabling this approach is a policy-agnostic semantic model, developed to disentangle information flow concerns from other functionality. Using policy-agnostic programming, the programmer may implement information flow policies by specifying them alongside sensitive data values, rather than implementing them as conditional access checks across the program. Prior work on Lifty supports policy-agnostic programming using type-driven repair, based on program synthesis for liquid types, which are value-dependent refinement types. Previously, programs could only benefit from policy-agnostic programming if the policies are known, but this is not always the case with existing code. We propose an approach for inferring liquid types from potentially buggy code. The inferred types now make it possible to perform sound repair. Representing the inferred policies as liquid types also facilitates modification of the policies. The proposal describes both a strategy for inferring a set of possible policies, and a solution for choosing which policies to use for repair.</AbstractNarration>
<MinAmdLetterDate>02/22/2017</MinAmdLetterDate>
<MaxAmdLetterDate>10/20/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1657530</AwardID>
<Investigator>
<FirstName>Jean</FirstName>
<LastName>Yang</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Jean Yang</PI_FULL_NAME>
<EmailAddress>jyang2@cs.cmu.edu</EmailAddress>
<PI_PHON>4122688851</PI_PHON>
<NSF_ID>000704214</NSF_ID>
<StartDate>02/22/2017</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Carnegie-Mellon University</Name>
<CityName>PITTSBURGH</CityName>
<ZipCode>152133815</ZipCode>
<PhoneNumber>4122688746</PhoneNumber>
<StreetAddress>5000 Forbes Avenue</StreetAddress>
<StreetAddress2><![CDATA[WQED Building]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<StateCode>PA</StateCode>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>PA18</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>052184116</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CARNEGIE MELLON UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>052184116</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Carnegie-Mellon University]]></Name>
<CityName/>
<StateCode>PA</StateCode>
<ZipCode>152133890</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Pennsylvania</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>18</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>PA18</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>026Y</Code>
<Text>CRII CISE Research Initiation</Text>
</ProgramElement>
<ProgramElement>
<Code>1714</Code>
<Text>Special Projects - CNS</Text>
</ProgramElement>
<ProgramReference>
<Code>025Z</Code>
<Text>SaTC: Secure and Trustworthy Cyberspace</Text>
</ProgramReference>
<ProgramReference>
<Code>8228</Code>
<Text>CISE Resrch Initiatn Initiatve</Text>
</ProgramReference>
<ProgramReference>
<Code>9178</Code>
<Text>UNDERGRADUATE EDUCATION</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0117</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0118</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2017~174974</FUND_OBLG>
<FUND_OBLG>2018~8000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The goal of this project was to make progress towards characterizing the information flow security properties of legacy systems. The problem setup is this: given a piece of software that has already been written, we want to be able to automatically infer the information flow security policies it may be enforcing on sensitive values in the program. There are two reasons to do this. First, software is often the only documentation of desired data usage policies, so characterizing the implemented policies is helpful for uniformity of policy enforcement across a system. Second, inferring policies&nbsp;</p> <p>In pursuing this project, we focused on developing approaches for verifying programs for information flow security properties using liquid types, a kind of refinement type that supports decidable type-checking and type inference. Refinement types are types that depend on program terms: a simple type is something like "integer," while a refinement type can mean something like "an integer such that Alice is allowed to see it." In prior work, we showed that we can use liquid types to encode high-level information flow security properties. For this project, we became interested in liquid types because of the decidable type inference property: being able to decidably infer types representing information flow security policies means that we can extract meaningful high-level security properties from existing code.</p> <p>Towards supporting the inference of information security properties for realistic programs, we focused on two dimensions of reality: 1) imperative programs and 2) database-backed programs. For the first direction, we developed an information flow type system for a simple imperative language and demonstrated the practicality by implementing it on top of Flow, Facebook's type-checker for JavaScript. For the second direction, we developed an approach for automated, decidable verification of information flow properties across the application and database. We implemented this approach in Haskell, on top of Liquid Haskell and the Yesod web framework. We are preparing a paper on the first direction and finishing up work on the second direction.</p> <p>While there are many more questions to answer, this work lays the foundation for automatically inferring high-level information flow security properties from existing software programs using refinement types. We've shown that it's possible to infer information flow security policies from more realistic programs than purely functional, strongly statically typed programs. The next step would be to develop heuristics for automatically identifying sensitive values and identifying potentially buggy policy implementations. Once we have all this, we will be closer to automated solutions for ensuring that software properly protects sensitive data.</p> <p>This project involved the training of one PhD student and three undergraduate students. Two of the undergraduate students came from underrepresented groups.</p><br> <p>            Last Modified: 05/12/2019<br>      Modified by: Jean&nbsp;Yang</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The goal of this project was to make progress towards characterizing the information flow security properties of legacy systems. The problem setup is this: given a piece of software that has already been written, we want to be able to automatically infer the information flow security policies it may be enforcing on sensitive values in the program. There are two reasons to do this. First, software is often the only documentation of desired data usage policies, so characterizing the implemented policies is helpful for uniformity of policy enforcement across a system. Second, inferring policies   In pursuing this project, we focused on developing approaches for verifying programs for information flow security properties using liquid types, a kind of refinement type that supports decidable type-checking and type inference. Refinement types are types that depend on program terms: a simple type is something like "integer," while a refinement type can mean something like "an integer such that Alice is allowed to see it." In prior work, we showed that we can use liquid types to encode high-level information flow security properties. For this project, we became interested in liquid types because of the decidable type inference property: being able to decidably infer types representing information flow security policies means that we can extract meaningful high-level security properties from existing code.  Towards supporting the inference of information security properties for realistic programs, we focused on two dimensions of reality: 1) imperative programs and 2) database-backed programs. For the first direction, we developed an information flow type system for a simple imperative language and demonstrated the practicality by implementing it on top of Flow, Facebook's type-checker for JavaScript. For the second direction, we developed an approach for automated, decidable verification of information flow properties across the application and database. We implemented this approach in Haskell, on top of Liquid Haskell and the Yesod web framework. We are preparing a paper on the first direction and finishing up work on the second direction.  While there are many more questions to answer, this work lays the foundation for automatically inferring high-level information flow security properties from existing software programs using refinement types. We've shown that it's possible to infer information flow security policies from more realistic programs than purely functional, strongly statically typed programs. The next step would be to develop heuristics for automatically identifying sensitive values and identifying potentially buggy policy implementations. Once we have all this, we will be closer to automated solutions for ensuring that software properly protects sensitive data.  This project involved the training of one PhD student and three undergraduate students. Two of the undergraduate students came from underrepresented groups.       Last Modified: 05/12/2019       Submitted by: Jean Yang]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
