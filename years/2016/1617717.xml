<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Semantics, Static Analysis, and Refencing of Concurrent Programs with Weak Memory Models</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2016</AwardEffectiveDate>
<AwardExpirationDate>08/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>481399.00</AwardTotalIntnAmount>
<AwardAmount>481399</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Modern computers have parallel multicore architectures sharing a&lt;br/&gt;hierarchy of caches and memories from fast and expensive ones to large&lt;br/&gt;and cheaper ones. The consequence is that not all cores running&lt;br/&gt;concurrently see the shared memory in the same way: some see newly&lt;br/&gt;stored values while others see older ones. This is called weak&lt;br/&gt;consistency models for shared memory on a single chip or memory&lt;br/&gt;distributed on several chips or on networks. This modern design makes &lt;br/&gt;the task of designing and programming parallel computers very complex. &lt;br/&gt;In particular the same program may have very different behaviors when running &lt;br/&gt;on different architectures whereas the same program had the same effect on all&lt;br/&gt;machines of the previous generation. &lt;br/&gt;&lt;br/&gt;This project define a generic formal semantics of parallel programs with weak &lt;br/&gt;consistency models parameterized by a formal definition of the computer &lt;br/&gt;architecture. Based on this parameterized semantics, the project investigates &lt;br/&gt;invariance proof methods to be used by programmers and verification tools to &lt;br/&gt;prove properties of parallel programs with weak consistency models. The project &lt;br/&gt;contributes to formal methods and tools for concurrent programming which, by &lt;br/&gt;the foreseeable evolution of hardware design, will be inevitable in the future.&lt;br/&gt;The publications and prototypes from this project are widely disseminated.</AbstractNarration>
<MinAmdLetterDate>05/19/2016</MinAmdLetterDate>
<MaxAmdLetterDate>05/19/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1617717</AwardID>
<Investigator>
<FirstName>Patrick</FirstName>
<LastName>Cousot</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Patrick Cousot</PI_FULL_NAME>
<EmailAddress>pcousot@cs.nyu.edu</EmailAddress>
<PI_PHON>2129982121</PI_PHON>
<NSF_ID>000504419</NSF_ID>
<StartDate>05/19/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>New York University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100121019</ZipCode>
<PhoneNumber>2129982121</PhoneNumber>
<StreetAddress>70 WASHINGTON SQUARE S</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>041968306</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>NEW YORK UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041968306</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[New York University]]></Name>
<CityName>New York</CityName>
<StateCode>NY</StateCode>
<ZipCode>100121110</ZipCode>
<StreetAddress><![CDATA[251 Mercer Street]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~481399</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span>Modern computers have parallel multicore architectures sharing a&nbsp;</span>hierarchy of caches and memories from fast and expensive ones to large and cheaper ones. The consequence is that not all cores running concurrently see the shared memory in the same way: some see newly stored values while others see older ones. This is called weak consistency models (for shared memory on a single chip or memory distributed on several chips or on networks).</p> <div><span> <p><span>The consequence of this modern design is a huge complexification of the&nbsp;</span>semantics of parallel programs, their compilation, verification, and static analysis.</p> <p><span>Using abstract interpretation, we have established foundations of dependency analysis, graphs analysis, the soundness of model checking and dataflow analysis, the formalization of dynamic analysis, and the application of static analysis to improve static analysis algorithms.</span></p> <div><span>The more widely applicable result is on dependency analysis. &nbsp;</span>Dependency is a prevalent notion in computer science. There have been numerous informal or formal attempts to define viable syntactic and semantic concepts of dependency in programming languages with subtle variations and limitations. We have developed a new value dependency analysis defined by abstract interpretation of a trace semantics. A sound approximate dependency algorithm is formally derived by calculational design. Further abstractions provide information flow, slicing, non- interference, dye, and taint analyses. The key idea is that a precise dependency must take values of data into account not only the operations on data. This is achieved via a reduced product of a dependency and a value analysis which interact to reach more precision&nbsp;<span> <div><span><br /></span></div> </span></div> <p>&nbsp;</p> <div><span><br /></span></div> <br /></span></div><br> <p>            Last Modified: 10/04/2020<br>      Modified by: Patrick&nbsp;Cousot</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Modern computers have parallel multicore architectures sharing a hierarchy of caches and memories from fast and expensive ones to large and cheaper ones. The consequence is that not all cores running concurrently see the shared memory in the same way: some see newly stored values while others see older ones. This is called weak consistency models (for shared memory on a single chip or memory distributed on several chips or on networks).   The consequence of this modern design is a huge complexification of the semantics of parallel programs, their compilation, verification, and static analysis.  Using abstract interpretation, we have established foundations of dependency analysis, graphs analysis, the soundness of model checking and dataflow analysis, the formalization of dynamic analysis, and the application of static analysis to improve static analysis algorithms. The more widely applicable result is on dependency analysis.  Dependency is a prevalent notion in computer science. There have been numerous informal or formal attempts to define viable syntactic and semantic concepts of dependency in programming languages with subtle variations and limitations. We have developed a new value dependency analysis defined by abstract interpretation of a trace semantics. A sound approximate dependency algorithm is formally derived by calculational design. Further abstractions provide information flow, slicing, non- interference, dye, and taint analyses. The key idea is that a precise dependency must take values of data into account not only the operations on data. This is achieved via a reduced product of a dependency and a value analysis which interact to reach more precision                  Last Modified: 10/04/2020       Submitted by: Patrick Cousot]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
