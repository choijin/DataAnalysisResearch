<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>EAGER: Dryads - Next Generation Tree Algorithms</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2016</AwardEffectiveDate>
<AwardExpirationDate>07/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>299815.00</AwardTotalIntnAmount>
<AwardAmount>299815</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Many data sets can be represented via a natural hierarchical ordering, which can be easily represented programmatically by using tree data structures. For example, two-dimensional spatial data can be organized by using quad-trees, while three-dimensional data can be organized by using oct-trees. As data volumes continue to increase, compact representations of the extremely large data become increasingly important since the representations can enable much more efficient data selection, transportation, and processing. Yet the development of standardized, generic and efficient tree data structures that both scale to massive data and leverage the capabilities of modern computer architectures remains an unmet need. This research effort addresses this need by designing and implementing a library of generic implicit tree abstractions that will provide the foundation for next generation analysis codes in data driven sciences. By working with the C++ standardization committee, this research will potentially impact millions of software developers, worldwide, since this low level language is implicitly used by many high-level language analysis tools and libraries.&lt;br/&gt;&lt;br/&gt;This research will investigate generic and high performance tree building blocks by exploring two key elements. First, low-level bit manipulation techniques will be created that can be optimized for specific computer architectures (such as the Intel Haswell). These techniques will be developed in conjunction with the international C++ standardization committee as an open source library and will impact a wide range of applications areas including arbitrary precision arithmetic, cryptography, and tree indexing strategies. Second, a generic library of implicit tree structures will be developed, by using the previously developed bit manipulation techniques, and submitted as a new, open-source library to the Boost community for broader dissemination. Finally, to demonstrate the efficacy of these new software libraries, two example tree applications will be developed and published: an oct-tree used for numerical simulations and a decision trees used for machine learning.</AbstractNarration>
<MinAmdLetterDate>07/28/2016</MinAmdLetterDate>
<MaxAmdLetterDate>07/28/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1647432</AwardID>
<Investigator>
<FirstName>Robert</FirstName>
<LastName>Brunner</LastName>
<PI_MID_INIT>J</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Robert J Brunner</PI_FULL_NAME>
<EmailAddress>bigdog@illinois.edu</EmailAddress>
<PI_PHON>2172446099</PI_PHON>
<NSF_ID>000290047</NSF_ID>
<StartDate>07/28/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Vincent</FirstName>
<LastName>Reverdy</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vincent Reverdy</PI_FULL_NAME>
<EmailAddress>vreverdy@illinois.edu</EmailAddress>
<PI_PHON/>
<NSF_ID>000696018</NSF_ID>
<StartDate>07/28/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Illinois at Urbana-Champaign</Name>
<CityName>Champaign</CityName>
<ZipCode>618207406</ZipCode>
<PhoneNumber>2173332187</PhoneNumber>
<StreetAddress>1901 South First Street</StreetAddress>
<StreetAddress2><![CDATA[Suite A]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<StateCode>IL</StateCode>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IL13</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>041544081</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF ILLINOIS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041544081</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Illinois at Urbana-Champaign]]></Name>
<CityName/>
<StateCode>IL</StateCode>
<ZipCode>618207473</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>13</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IL13</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7916</Code>
<Text>EAGER</Text>
</ProgramReference>
<ProgramReference>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~299815</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>From physics simulations to machine learning algorithms, tree data structures constitute a fundamental component of many scientific computing applications. Yet the wide variety of tree types that exist have prevented many programming languages from providing a generic tree data structure in their standard library. In this context, the main goal of the Dryads project was to design, develop, and implement some of the building blocks shared by all these trees.<br /><br />At the most fundamental level, bit manipulation algorithms and bit-centered data structures are amongst the most critical of these building blocks. From implicit trees where the structure emerges from hash indices to adjacency matrices, being able to manipulate individual and groups of bits as efficiently as possible is central to the question of performance.<br />&nbsp;<br />In the context of the Dryads project, we developed the idea of universal bit abstractions under the form of bit iterators as a way to achieve genericity, performance, and ease-of-use at the same time. The idea was implemented in C++. It led to a standardization effort to bring it to the standard C++ library to make it available by default in C++ compilers. The tools have been accepted to be part of an official Technical Specification and are likely to be available in C++23. The new  header file, however, will be released as soon as C++20 in order to provide a few low-level bit manipulation functions. Because it lies at such fundamental level of the software stack, bit abstractions are expected to serve as one of the foundational component of the Numeric Technical Specification that will provide, amongst other things, a whole new range of numeric types for arbitrary precision and fixed-point arithmetic in C++.<br /><br />Bit abstractions were then leveraged to develop bit algorithms and bit-based data structures. The entire library of standard C++ algorithms was reimplemented to make bit manipulation as efficient as possible. It is now publicly available and provides all the algorithmic building blocks for applications that can leverage bit manipulation including trees, bioinformatics, and signal processing. In parallel, we developed a new generation of bitsets relying on union types and the so-called "small buffer optimization", capable of exhibiting a dual static and dynamic behavior while minimizing the memory footprint. Some of these components have been pushed into GCC as experimental features for compiler writers.<br /><br />On the tree side, tens of different design approaches were tested. Some of these approaches were put into application in two different contexts: general game playing through game trees and Monte-Carlo Tree Search algorithms, and symbolic calculus both at runtime and compile-time through Abstract Syntax Trees. These applications allowed us to better identify the generic programming flaws in each of the tested design. Slowly the Dryads project led to the conclusion that new and more generic levels of abstraction were necessary: proxy types and multidimensional iterators. By combining those two in different ways, one can obtain the abstractions of trees, graphs, linear algebra and much more. This opens the door to further research on the more theoretical computer science side of things, including applied category theory and type theory.<br /><br />For now, the Dryads project contributed to the creation the Study Group 19 on Machine Learning as part of the ISO C++ Standards Committee who will, amongst other things, pursue the long term efforts initiated by our team to provide fundamental building blocks of tree data structures, at the bottom of the software stack, and for as many researchers and developers as possible.<br /><br /></p><br> <p>            Last Modified: 11/30/2019<br>      Modified by: Vincent&nbsp;Reverdy</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ From physics simulations to machine learning algorithms, tree data structures constitute a fundamental component of many scientific computing applications. Yet the wide variety of tree types that exist have prevented many programming languages from providing a generic tree data structure in their standard library. In this context, the main goal of the Dryads project was to design, develop, and implement some of the building blocks shared by all these trees.  At the most fundamental level, bit manipulation algorithms and bit-centered data structures are amongst the most critical of these building blocks. From implicit trees where the structure emerges from hash indices to adjacency matrices, being able to manipulate individual and groups of bits as efficiently as possible is central to the question of performance.   In the context of the Dryads project, we developed the idea of universal bit abstractions under the form of bit iterators as a way to achieve genericity, performance, and ease-of-use at the same time. The idea was implemented in C++. It led to a standardization effort to bring it to the standard C++ library to make it available by default in C++ compilers. The tools have been accepted to be part of an official Technical Specification and are likely to be available in C++23. The new  header file, however, will be released as soon as C++20 in order to provide a few low-level bit manipulation functions. Because it lies at such fundamental level of the software stack, bit abstractions are expected to serve as one of the foundational component of the Numeric Technical Specification that will provide, amongst other things, a whole new range of numeric types for arbitrary precision and fixed-point arithmetic in C++.  Bit abstractions were then leveraged to develop bit algorithms and bit-based data structures. The entire library of standard C++ algorithms was reimplemented to make bit manipulation as efficient as possible. It is now publicly available and provides all the algorithmic building blocks for applications that can leverage bit manipulation including trees, bioinformatics, and signal processing. In parallel, we developed a new generation of bitsets relying on union types and the so-called "small buffer optimization", capable of exhibiting a dual static and dynamic behavior while minimizing the memory footprint. Some of these components have been pushed into GCC as experimental features for compiler writers.  On the tree side, tens of different design approaches were tested. Some of these approaches were put into application in two different contexts: general game playing through game trees and Monte-Carlo Tree Search algorithms, and symbolic calculus both at runtime and compile-time through Abstract Syntax Trees. These applications allowed us to better identify the generic programming flaws in each of the tested design. Slowly the Dryads project led to the conclusion that new and more generic levels of abstraction were necessary: proxy types and multidimensional iterators. By combining those two in different ways, one can obtain the abstractions of trees, graphs, linear algebra and much more. This opens the door to further research on the more theoretical computer science side of things, including applied category theory and type theory.  For now, the Dryads project contributed to the creation the Study Group 19 on Machine Learning as part of the ISO C++ Standards Committee who will, amongst other things, pursue the long term efforts initiated by our team to provide fundamental building blocks of tree data structures, at the bottom of the software stack, and for as many researchers and developers as possible.         Last Modified: 11/30/2019       Submitted by: Vincent Reverdy]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
