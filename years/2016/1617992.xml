<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Small: Running the Kernel Continuously with Simultaneous Multi-Threading</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2016</AwardEffectiveDate>
<AwardExpirationDate>09/30/2020</AwardExpirationDate>
<AwardTotalIntnAmount>500000.00</AwardTotalIntnAmount>
<AwardAmount>500000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Since 2002, many commodity computer processors include a feature called simultaneous multi-threading (SMT), marketed by Intel as Hyperthreading (tm). SMT enables a single processor core to perform two or more tasks in parallel. Until now, operating systems researchers have focused on accommodating SMT in existing operating system designs, investigating topics such as SMT-aware resource allocation, scheduling and synchronization methods. In this project, rather than merely accommodate SMT, we investigate a new low-level operating system design that is enabled by SMT hardware. In modern operating systems, the processor switches between the safe but quite limited 'user mode' which is used to run applications, and the unsafe but all-powerful 'supervisor mode' which is available only to the operating system. Sometimes, these switches occur millions of times per second, providing an illusion of parallel operation. In our new design, the user and supervisor modes are actually active simultaneously, but on separate SMT threads. This avoids the often high cost of frequent mode switches, and enables new efficiency and design improvements throughout the operating system. &lt;br/&gt;&lt;br/&gt;Based on preliminary measurements, we find that the throughput gains provided by conventional SMT diminishes rapidly with the number of processor cores in a system, as a result of sub-linear scalability in the application. To counter this, and to make better use of existing hardware, we propose the "cokernel" operating system design principle, where one hardware thread per CPU is dedicated to continuously executing the kernel. By offloading kernel duties from the other hardware thread(s), a cokernel operating system enables higher per-thread application throughput, avoiding  scalability concerns. In addition, having a continuously executing kernel thread on each core enables a wide range of improvements to other aspects of the kernel, such as replacing most system calls with message passing, hybrid cooperative-preemptive process scheduling, kernel-assisted asynchronous inter-core and inter-socket communication and true kernel background tasks.</AbstractNarration>
<MinAmdLetterDate>08/08/2016</MinAmdLetterDate>
<MaxAmdLetterDate>08/08/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1617992</AwardID>
<Investigator>
<FirstName>Jakob</FirstName>
<LastName>Eriksson</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Jakob Eriksson</PI_FULL_NAME>
<EmailAddress>jakob@uic.edu</EmailAddress>
<PI_PHON>3124132103</PI_PHON>
<NSF_ID>000537836</NSF_ID>
<StartDate>08/08/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Illinois at Chicago</Name>
<CityName>Chicago</CityName>
<ZipCode>606124305</ZipCode>
<PhoneNumber>3129962862</PhoneNumber>
<StreetAddress>809 S. Marshfield Avenue</StreetAddress>
<StreetAddress2><![CDATA[MB 502, M/C 551]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<StateCode>IL</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IL07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>098987217</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF ILLINOIS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041544081</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Illinois at Chicago]]></Name>
<CityName>Chicago</CityName>
<StateCode>IL</StateCode>
<ZipCode>606077042</ZipCode>
<StreetAddress><![CDATA[851 S Morgan St]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IL07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~500000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This project explores new approaches for using the increasing number of cores available in modern CPUs. With more cores available, traditional approaches, such as locks for mutual exclusion, and mode-changing system calls, may not offer the most scalable solution.</p> <p>While the project explored a range of research ideas around this central theme, the most fruitful direction, and eventually the primary focus of the project, was the idea of delegation as an alternative to shared memory for communication between cores running an application. In layman terms, conventional shared memory communication requires a CPU core to first acquire exclusive use of a shared data structure before accessing it, a process which sometimes requires considerable coordination between cores. This is analogous to a shared pen and dry-erase board, that several people huddle around to write on. Delegation, meanwhile, designates one core as solely responsible for any given shared data structure, and other cores request work to be performed through a dedicated communication channel. To continue the board analogy, this corresponds to one person exclusively writing on the shared board, according to the wishes of others. Under many circumstances, this is significantly more efficient.&nbsp;</p> <p>The findings of the project include highly efficient communication channels for delegation, which have been shown to substantially outperform the conventional model on a range of applications. The project also demonstrated means by which individual cores rapidly switch between the "client" and "server" roles - alternately performing work as directed by others, and asking others to do work (on other data structures) on their behalf. Finally, looking into the future, delegation has the potential to seamlessly connect multiple individual computers, allowing a single application to efficiently run on much larger systems than what is possible with shared-memory communication.&nbsp;</p><br> <p>            Last Modified: 02/12/2021<br>      Modified by: Jakob&nbsp;Eriksson</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This project explores new approaches for using the increasing number of cores available in modern CPUs. With more cores available, traditional approaches, such as locks for mutual exclusion, and mode-changing system calls, may not offer the most scalable solution.  While the project explored a range of research ideas around this central theme, the most fruitful direction, and eventually the primary focus of the project, was the idea of delegation as an alternative to shared memory for communication between cores running an application. In layman terms, conventional shared memory communication requires a CPU core to first acquire exclusive use of a shared data structure before accessing it, a process which sometimes requires considerable coordination between cores. This is analogous to a shared pen and dry-erase board, that several people huddle around to write on. Delegation, meanwhile, designates one core as solely responsible for any given shared data structure, and other cores request work to be performed through a dedicated communication channel. To continue the board analogy, this corresponds to one person exclusively writing on the shared board, according to the wishes of others. Under many circumstances, this is significantly more efficient.   The findings of the project include highly efficient communication channels for delegation, which have been shown to substantially outperform the conventional model on a range of applications. The project also demonstrated means by which individual cores rapidly switch between the "client" and "server" roles - alternately performing work as directed by others, and asking others to do work (on other data structures) on their behalf. Finally, looking into the future, delegation has the potential to seamlessly connect multiple individual computers, allowing a single application to efficiently run on much larger systems than what is possible with shared-memory communication.        Last Modified: 02/12/2021       Submitted by: Jakob Eriksson]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
