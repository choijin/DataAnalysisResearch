<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>III: Small: Reducing The Graphical User Interface's Consumption of Power on Mobile Devices</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2016</AwardEffectiveDate>
<AwardExpirationDate>09/30/2020</AwardExpirationDate>
<AwardTotalIntnAmount>384297.00</AwardTotalIntnAmount>
<AwardAmount>384297</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Mobile devices have increased their energy demand as they have acquired new capabilities. A decade ago, users might have had to re-charge their mobile devices once a week; now it is common to have to re-charge them daily. This increased energy demand is in part due to the constant polling that a mobile device performs to determine whether an input, such as a gesture, an email message, or a cellular call, has been received. The polling, even when the device is idle and in the user's pocket, constantly rouses the CPU and prevents it from being put into low power, energy-conserving states. This energy inefficient 'pull' model has been necessitated by the fact that input devices traditionally have been 'mute' when they receive an input. Thus in order to ensure that an input is promptly processed, the CPU is forced to query each input device multiple times per second to determine if the device is holding an input. Recent technological advances now enable input devices to immediately notify the CPU when an input has arrived. This advance allows us to investigate an alternative 'push' model that puts the CPU to sleep while no inputs are present and awakens the CPU only when an input is actually received. Hence the CPU no longer needs to consume power while the mobile device sits idle in the user's pocket. Additionally, newer mobile devices have multiple CPU cores, some of which are slower, lower power consuming cores that awaken faster when the CPU has been asleep. We can place the software that directs inputs to apps on one of these lower power consuming cores and the apps themselves on the faster, higher power consuming cores. This placement has two benefits. First, some inputs can be ignored, and if an input can be handled and discarded on the lower power core, then the higher power consuming cores do not need to be awakened. Second, if the input must be handled by an app, the higher power core can be warmed up while information about the input is gathered and staged for the app on the lower power core.&lt;br/&gt;&lt;br/&gt;In order to realize this push model, the locus of control for event handling will move from the application into the kernel. This new placement will necessitate 1) the development of kernel routines for event dispatching, 2) the development of a kernel-level display server that allows the process scheduler to know which processes are input driven, and 3) the modification of the process scheduler so that it can de-schedule input-driven processes as needed. We will first develop a push model for inputs received by graphical user interfaces and then extend it to generic system I/O such as sensors and GPS signals. We plan to modify the Android runtime (ART) to work with the push model in order to profile actual apps to determine how much power savings, and potentially reduced latency, can be achieved with our proposed model. Our research should have the desirable broader impact of both reducing the frequency with which mobile devices need to be recharged and reducing the environmental impact of mobile devices by reducing the amount of energy they consume. Another broader impact is that the proposed techniques should work for cellular and Wi-Fi handling apps and for desktop computers as well.</AbstractNarration>
<MinAmdLetterDate>08/08/2016</MinAmdLetterDate>
<MaxAmdLetterDate>09/05/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1617198</AwardID>
<Investigator>
<FirstName>Bradley</FirstName>
<LastName>Vander Zanden</LastName>
<PI_MID_INIT>T</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Bradley T Vander Zanden</PI_FULL_NAME>
<EmailAddress>bvz@eecs.utk.edu</EmailAddress>
<PI_PHON>8659745067</PI_PHON>
<NSF_ID>000269551</NSF_ID>
<StartDate>08/08/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Wei</FirstName>
<LastName>Gao</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Wei Gao</PI_FULL_NAME>
<EmailAddress>weigao@pitt.edu</EmailAddress>
<PI_PHON>4126248002</PI_PHON>
<NSF_ID>000627623</NSF_ID>
<StartDate>08/08/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Tennessee Knoxville</Name>
<CityName>Knoxville</CityName>
<ZipCode>379163801</ZipCode>
<PhoneNumber>8659743466</PhoneNumber>
<StreetAddress>1331 CIR PARK DR</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Tennessee</StateName>
<StateCode>TN</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TN02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>003387891</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF TENNESSEE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>003387891</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Tennessee Knoxville]]></Name>
<CityName>Knoxville</CityName>
<StateCode>TN</StateCode>
<ZipCode>379960003</ZipCode>
<StreetAddress><![CDATA[1 Circle Park Dr]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Tennessee</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TN02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7367</Code>
<Text>Cyber-Human Systems</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~384297</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><strong>Where we were</strong>: Many mobile devices deplete their battery even when they are seemingly idle, such as when a user is reading a social media post or when the device is resting in their pocket. There are three software-related reasons for why this depletion occurs:</p> <ol> </ol> <p style="padding-left: 30px;">1) Many apps actively check for user activity, such as finger taps or finger gestures, even when such activity does not exist. The reason for this constant checking is that older input devices could not tell the central processing unit (CPU) when an event had arrived. Instead the CPU had to periodically poll the devices to determine if those devices had received an input event. This constant checking keeps rousing the CPU and depleting the battery.</p> <p style="padding-left: 30px;">2) The display server, which manages event handling and drawing to the screen, has been kept in the application layer since the inception of graphical user interfaces (GUIs) in the 1980s to give the user the flexibility to choose their own display server--this flexiblity comes at the expense of duplicate data about events and drawing being stored in the application and the operating system (OS) since the OS is ultimately responsible for receiving/dispatching events and drawing shapes on the screen. This duplication creates extra work for the CPU and depletes the battery.</p> <p style="padding-left: 30px;">3) The scheduling algorithm that the OS uses to assign apps to the CPU cannot determine when they might be idle and hence keeps scheduling them, which depletes the battery.</p> <p><strong>What has changed</strong></p> <ol> </ol> <p style="padding-left: 30px;">1) Newer input devices can immediately notify the CPU when they receive an event. However, operating systems have not been rewritten to take advantage of this advance.</p> <p style="padding-left: 30px;">2) Operating systems such as Android, Windows, and MacOS provide a custom display server that you cannot change; however you still pay the cost for duplicated data and activities.</p> <p style="padding-left: 30px;">3) Most apps on mobile devices have a strong GUI component. A GUI-oriented app performs 4 principal tasks--event handling, display, foreground tasks such as video decoding, and background tasks such as downloading newspaper articles. Existing OS schedulers do not know which of these tasks an app needs to perform and hence keep scheduling the app because even if the app has been swiped off the screen, it might need to perform a background task.</p> <p><strong>Our advances</strong>: Our project innovated software techniques to take advantage of each of the three changes cited above and thus reduce the power consumption of mobile devices:</p> <ol> </ol> <p style="padding-left: 30px;">1) It developed software in the OS that eliminates the input device polling loop and instead only rouses the CPU when an event arrives at an input device. This software then directs the event to the appropriate app and schedules only that app.</p> <p style="padding-left: 30px;">2) It demonstrated how the display server can be moved from the application layer into the OS, showed how this integration reduced the amount of data being exchanged between the application and the OS, and showed how communication was simplified between the application and the OS.</p> <p style="padding-left: 30px;">3) It devised a scheduler that divides GUI-related tasks into the four categories cited above. When an app is covered, our new scheduler stops scheduling all but the background tasks for that app. Since many background tasks are executed infrequently, the scheduler can often place the CPU in the lowest possible power consuming sleep state if all apps are otherwise inactive, such as when a phone is sitting in your pocket.</p> <p><strong>Our results</strong>: Our experiments have shown that these combined approaches yield power savings approaching 30% in social-media type apps that alternate periods of "bursty" event activity with long idle periods and 5-15% in game-type and video-type apps that are more computationally intensive. In social-media type apps, the removal of polling loops is the main contribution to this power consumption by allowing our scheduler to place the CPU in deep sleep states for extended periods of time. In game or video playing apps, the main reduction in power consumption occurs by allowing the CPU to remain focused on one task rather than having to context switch to polling tasks. The ability to stay on task both reduces memory cache misses and keeps the CPU from having to go to higher power states to make up for "lost time".<br /><br /><strong>Broader social impacts</strong></p> <ol> </ol> <p style="padding-left: 30px;">1) Mobile devices' demand for electricity was deemed considerable enough that the Natural Resources Defense Council published a paper detailing the ways in which cellular phones waste power. Hence reducing the power consumption of mobile devices is an important societal concern.</p> <p style="padding-left: 30px;">2) Our work targeted GUI-oriented applications on mobile devices but our techniques can also be used to reduce power consumption caused by polling for sensor devices (e.g., one that measures your steps) and can also be used to rewrite the OS's on laptop/desktop computers to achieve similar power consumption savings.</p> <p><br /><br /></p><br> <p>            Last Modified: 12/26/2020<br>      Modified by: Bradley&nbsp;T&nbsp;Vander Zanden</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Where we were: Many mobile devices deplete their battery even when they are seemingly idle, such as when a user is reading a social media post or when the device is resting in their pocket. There are three software-related reasons for why this depletion occurs:   1) Many apps actively check for user activity, such as finger taps or finger gestures, even when such activity does not exist. The reason for this constant checking is that older input devices could not tell the central processing unit (CPU) when an event had arrived. Instead the CPU had to periodically poll the devices to determine if those devices had received an input event. This constant checking keeps rousing the CPU and depleting the battery. 2) The display server, which manages event handling and drawing to the screen, has been kept in the application layer since the inception of graphical user interfaces (GUIs) in the 1980s to give the user the flexibility to choose their own display server--this flexiblity comes at the expense of duplicate data about events and drawing being stored in the application and the operating system (OS) since the OS is ultimately responsible for receiving/dispatching events and drawing shapes on the screen. This duplication creates extra work for the CPU and depletes the battery. 3) The scheduling algorithm that the OS uses to assign apps to the CPU cannot determine when they might be idle and hence keeps scheduling them, which depletes the battery.  What has changed   1) Newer input devices can immediately notify the CPU when they receive an event. However, operating systems have not been rewritten to take advantage of this advance. 2) Operating systems such as Android, Windows, and MacOS provide a custom display server that you cannot change; however you still pay the cost for duplicated data and activities. 3) Most apps on mobile devices have a strong GUI component. A GUI-oriented app performs 4 principal tasks--event handling, display, foreground tasks such as video decoding, and background tasks such as downloading newspaper articles. Existing OS schedulers do not know which of these tasks an app needs to perform and hence keep scheduling the app because even if the app has been swiped off the screen, it might need to perform a background task.  Our advances: Our project innovated software techniques to take advantage of each of the three changes cited above and thus reduce the power consumption of mobile devices:   1) It developed software in the OS that eliminates the input device polling loop and instead only rouses the CPU when an event arrives at an input device. This software then directs the event to the appropriate app and schedules only that app. 2) It demonstrated how the display server can be moved from the application layer into the OS, showed how this integration reduced the amount of data being exchanged between the application and the OS, and showed how communication was simplified between the application and the OS. 3) It devised a scheduler that divides GUI-related tasks into the four categories cited above. When an app is covered, our new scheduler stops scheduling all but the background tasks for that app. Since many background tasks are executed infrequently, the scheduler can often place the CPU in the lowest possible power consuming sleep state if all apps are otherwise inactive, such as when a phone is sitting in your pocket.  Our results: Our experiments have shown that these combined approaches yield power savings approaching 30% in social-media type apps that alternate periods of "bursty" event activity with long idle periods and 5-15% in game-type and video-type apps that are more computationally intensive. In social-media type apps, the removal of polling loops is the main contribution to this power consumption by allowing our scheduler to place the CPU in deep sleep states for extended periods of time. In game or video playing apps, the main reduction in power consumption occurs by allowing the CPU to remain focused on one task rather than having to context switch to polling tasks. The ability to stay on task both reduces memory cache misses and keeps the CPU from having to go to higher power states to make up for "lost time".  Broader social impacts   1) Mobile devices' demand for electricity was deemed considerable enough that the Natural Resources Defense Council published a paper detailing the ways in which cellular phones waste power. Hence reducing the power consumption of mobile devices is an important societal concern. 2) Our work targeted GUI-oriented applications on mobile devices but our techniques can also be used to reduce power consumption caused by polling for sensor devices (e.g., one that measures your steps) and can also be used to rewrite the OS's on laptop/desktop computers to achieve similar power consumption savings.           Last Modified: 12/26/2020       Submitted by: Bradley T Vander Zanden]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
