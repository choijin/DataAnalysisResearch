<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>AF: Small: Dynamic Reasoning</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2016</AwardEffectiveDate>
<AwardExpirationDate>06/30/2020</AwardExpirationDate>
<AwardTotalIntnAmount>399734.00</AwardTotalIntnAmount>
<AwardAmount>407034</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>A. Funda Ergun</SignBlockName>
<PO_EMAI>fergun@nsf.gov</PO_EMAI>
<PO_PHON>7032922216</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Descriptive Complexity measures the richness of a language needed to describe a given property. The languages are variants of first-order logic describing finite structures.  All major complexity classes have been shown to have natural descriptive characterizations, providing a deep and profound relationship between the traditional computational complexity of a problem and the descriptive complexity of the problem.  Thus complexity can be understood entirely from a logical point of view. Important new understandings about complexity have arisen from the descriptive point of view.  In particular, the trade-off between parallel time and amount of hardware, a fundamental issue in computation, has been characterized as the trade-off between formula size and number of variables. There are four broader impacts from the above work. (1) This project will extend knowledge concerning the complexity of problems as well as providing new methods to automatically check the correctness of programs.  This work will lead to tools useful for teaching logic and complexity. (2) The project will improve the understanding of the fundamental nature of computation.  (3) Results from this project will be widely distributed and will be presented at conferences, published in journals, and taught in seminars. (4) The PI will also train graduate students to do research in this combination of pure and applied theory.&lt;br/&gt;&lt;br/&gt;In this project, the PI will continue to extend the understanding of computational complexity using descriptive complexity.  The PI will also expand the recent use of modern SAT solvers to automatically prove that programs meet their correctness conditions or find runs on which they do not. The intellectual merit of this project is that it will extend the understanding of computational complexity and it will improve the ability and understanding of how to automatically reason about the correctness of programs. The research in this project has several specific thrusts: (1) The PI will extend the methodology for automatically generating correctness conditions for programs in simple languages which are automatically checkable, (2) The PI will extend the current understanding of dynamic complexity, especially for reachability properties, (3) The PI will develop a theory of dynamic reasoning, identifying when it is possible to reason about program states in an essentially propositional way and when it is not, (4) The PI will study the dichotomy phenomon from a descriptive point of view. In particular, starting with binary Constraint Satisfaction Problems, the PI will explain where dichotomies lie and in particular why natural computational problems tend to be complete for a small number of important complexity classes.</AbstractNarration>
<MinAmdLetterDate>06/28/2016</MinAmdLetterDate>
<MaxAmdLetterDate>05/16/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1617498</AwardID>
<Investigator>
<FirstName>Neil</FirstName>
<LastName>Immerman</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Neil Immerman</PI_FULL_NAME>
<EmailAddress>immerman@cs.umass.edu</EmailAddress>
<PI_PHON>4135451862</PI_PHON>
<NSF_ID>000178321</NSF_ID>
<StartDate>06/28/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Massachusetts Amherst</Name>
<CityName>Hadley</CityName>
<ZipCode>010359450</ZipCode>
<PhoneNumber>4135450698</PhoneNumber>
<StreetAddress>Research Administration Building</StreetAddress>
<StreetAddress2><![CDATA[100 Venture Way, Suite 201]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>153926712</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF MASSACHUSETTS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>079520631</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Massachusetts Amherst]]></Name>
<CityName>Amherst</CityName>
<StateCode>MA</StateCode>
<ZipCode>010039264</ZipCode>
<StreetAddress><![CDATA[140 Governors Drive]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7796</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7927</Code>
<Text>COMPLEXITY &amp; CRYPTOGRAPHY</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0117</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~399734</FUND_OBLG>
<FUND_OBLG>2017~7300</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>In older papers, we introduced the resilience of a boolean query. The resilience of a query with respect to a database, D, is the minimum number of tuples that must be removed from D to make the query false.&nbsp; Computing resilience is important for understanding why a tuple is present in a query or view, and to compute how to change it in the simplest way. For conjunctive queries without self joins, we developed a natural criterion that classifies queries according to the complexity of their resilience problem, showing that this problem exhibits a dichotomy.&nbsp; We defined the triad and showed that resilience is NP complete in the presence of a triad; whereas in the absence of a triad resilience is efficiently computable: it is reducible to Network Flow and thus well inside P.</p> <p>As for most questions about conjunctive queries, this classification problem becomes much more subtle in the presence of self joins. In the above paper, we extended our previous results to allow the presence of self joins.&nbsp; We explain most of the ensuing complications and we prove a characterization of the resilience of conjunctive queries with self-joins, in a restricted case.&nbsp; We show that in this case a similar dichtomy holds as in the sj-free case. The main value of this paper is in explaining how the problem gets significantly more complicated in the presence of self joins -- a very common phenomenon -- but laying out a roadmap to completely solve the reslience problem in the presence of self joins.<br /><br />Much promising work, including some of ours, employs SAT solvers to automatically check whether or not given programs meet certain correctness conditions. In order to do this, we need to be given a program that includes loop or program invariants.&nbsp; We describe progress that we made on the problem of automatically computing such invariants.</p> <p>Quantified first-order formulas, with alternating quantifiers are often needed as program invariants. There had been no way to infer them automatically.&nbsp; In this paper we consider the problem of finding a first-order separator for two sets of structures, P, N, namely a formula of a given quantifier depth, d, that is true for all the positive structures and false for all the negative ones.&nbsp; We show that for each fixed d, this problem is NP complete.&nbsp; We also show a practical algorithm using a SAT solver which finds such separators and thus infers quantified program invariants.&nbsp; We have thus introduced a promising new method of infering quantified program invariants.&nbsp;</p> <p>In a second paper on inductive inference we address the complexity of SAT-based invariant inference.&nbsp; We consider the problem of inferring an inductive invariant of polynomial length given a transition system and a safety property. We analyze the complexity of this problem in a black-box model, called the Hoare-query model, which is general enough to capture algorithms such as IC3/PDR and its variants, We show that any algorithm that uses the Hoare-query model requires exponentially many queries in the worst case to derive a polynomial-length invariant.</p> <p>We then show, that approaches such as PDR which use Hoare queries, can be exponentially more efficient than approaches such as ICE learning which only utilize inductiveness checks of candidates.&nbsp; These results shed light on the general complexity of invariant inference.</p> <p>In a third paper on inductive inference, we consider the important practical problem of proving that a proposed invariant is inductive for a block of code.&nbsp; The formula is inductive if it follows from the initial conditions, is preserved by the code, and it also implies a given safety condition.&nbsp; In general, when the proposed invariant is a first-order formula with quantifier alternation, checking if it is inductive is undecidable.&nbsp; However we show that when we restrict the possible terms to be instantiated to have bounded depth (of nesting of skolem functions), the procedure becomes decidable and it turns out to be practical in some interesting settings.&nbsp; In fact, we show the striking fact that depth one suffices to automatically simulate a natural class of instrumentations -- rewritings of formulas which are often used by hand to transform such invariants to universal invariants. The advantage of universal invariants is that it is decidable to check that they are inductive.</p> <p>&nbsp;</p><br> <p>            Last Modified: 11/25/2020<br>      Modified by: Neil&nbsp;Immerman</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ In older papers, we introduced the resilience of a boolean query. The resilience of a query with respect to a database, D, is the minimum number of tuples that must be removed from D to make the query false.  Computing resilience is important for understanding why a tuple is present in a query or view, and to compute how to change it in the simplest way. For conjunctive queries without self joins, we developed a natural criterion that classifies queries according to the complexity of their resilience problem, showing that this problem exhibits a dichotomy.  We defined the triad and showed that resilience is NP complete in the presence of a triad; whereas in the absence of a triad resilience is efficiently computable: it is reducible to Network Flow and thus well inside P.  As for most questions about conjunctive queries, this classification problem becomes much more subtle in the presence of self joins. In the above paper, we extended our previous results to allow the presence of self joins.  We explain most of the ensuing complications and we prove a characterization of the resilience of conjunctive queries with self-joins, in a restricted case.  We show that in this case a similar dichtomy holds as in the sj-free case. The main value of this paper is in explaining how the problem gets significantly more complicated in the presence of self joins -- a very common phenomenon -- but laying out a roadmap to completely solve the reslience problem in the presence of self joins.  Much promising work, including some of ours, employs SAT solvers to automatically check whether or not given programs meet certain correctness conditions. In order to do this, we need to be given a program that includes loop or program invariants.  We describe progress that we made on the problem of automatically computing such invariants.  Quantified first-order formulas, with alternating quantifiers are often needed as program invariants. There had been no way to infer them automatically.  In this paper we consider the problem of finding a first-order separator for two sets of structures, P, N, namely a formula of a given quantifier depth, d, that is true for all the positive structures and false for all the negative ones.  We show that for each fixed d, this problem is NP complete.  We also show a practical algorithm using a SAT solver which finds such separators and thus infers quantified program invariants.  We have thus introduced a promising new method of infering quantified program invariants.   In a second paper on inductive inference we address the complexity of SAT-based invariant inference.  We consider the problem of inferring an inductive invariant of polynomial length given a transition system and a safety property. We analyze the complexity of this problem in a black-box model, called the Hoare-query model, which is general enough to capture algorithms such as IC3/PDR and its variants, We show that any algorithm that uses the Hoare-query model requires exponentially many queries in the worst case to derive a polynomial-length invariant.  We then show, that approaches such as PDR which use Hoare queries, can be exponentially more efficient than approaches such as ICE learning which only utilize inductiveness checks of candidates.  These results shed light on the general complexity of invariant inference.  In a third paper on inductive inference, we consider the important practical problem of proving that a proposed invariant is inductive for a block of code.  The formula is inductive if it follows from the initial conditions, is preserved by the code, and it also implies a given safety condition.  In general, when the proposed invariant is a first-order formula with quantifier alternation, checking if it is inductive is undecidable.  However we show that when we restrict the possible terms to be instantiated to have bounded depth (of nesting of skolem functions), the procedure becomes decidable and it turns out to be practical in some interesting settings.  In fact, we show the striking fact that depth one suffices to automatically simulate a natural class of instrumentations -- rewritings of formulas which are often used by hand to transform such invariants to universal invariants. The advantage of universal invariants is that it is decidable to check that they are inductive.          Last Modified: 11/25/2020       Submitted by: Neil Immerman]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
