<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: (TF/TOC) Efficient Computation of Approximate Solutions</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>02/15/2009</AwardEffectiveDate>
<AwardExpirationDate>01/31/2015</AwardExpirationDate>
<AwardTotalIntnAmount>363491.00</AwardTotalIntnAmount>
<AwardAmount>449807</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Balasubramanian Kalyanasundaram</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>The ever increasing amount of data that is being communicated and stored in our information reliant world poses unique challenges to the traditional notions of efficient data processing.  For example, as we pack more data into physical media such as a transmission cable or a hard disk, errors will occur more frequently than can currently be handled by such devices.  Additionally, as we transmit more data through our routers, they will have less resources available per packet for processing.  As a final example, large number of buyers in an online market will try to ``game" the system for their selfish gain.  It has become clear that the traditional notions of efficient computation are not capable of handling these growing complexities.  In particular, it is provably impossible to compute solutions under these new requirements that are as good as those that were possible with the previous lax notions of efficient computation.  Thus, these new obstacles necessitate designing algorithms to compute approximate solutions.  This project will consider fundamental open questions in and applications of ``list decoding" (an approximation of the traditional ``unique" decoding that can handle more errors than before), ``sub-linear" algorithms (algorithms that scale well with data by using amounts of resources that are sub-linear in the input size) and pricing algorithms (which deal with input data that are controlled by selfish agents).&lt;br/&gt;&lt;br/&gt;Course material developed in the educational component of this project will be made freely available on the Internet and will be used to update/create relevant Wikipedia pages.  The PI will also take advantage of the geographical proximity of active theory research groups to Buffalo by organizing annual workshops to promote and foster regional interaction among researchers in theory of computation.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>02/06/2009</MinAmdLetterDate>
<MaxAmdLetterDate>02/05/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0844796</AwardID>
<Investigator>
<FirstName>Atri</FirstName>
<LastName>Rudra</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Atri Rudra</PI_FULL_NAME>
<EmailAddress>atri@buffalo.edu</EmailAddress>
<PI_PHON>7166455000</PI_PHON>
<NSF_ID>000505466</NSF_ID>
<StartDate>02/06/2009</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>SUNY at Buffalo</Name>
<CityName>Buffalo</CityName>
<ZipCode>142282567</ZipCode>
<PhoneNumber>7166452634</PhoneNumber>
<StreetAddress>520 Lee Entrance</StreetAddress>
<StreetAddress2><![CDATA[Suite 211]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>26</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY26</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>038633251</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>RESEARCH FOUNDATION FOR THE STATE UNIVERSITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>020657151</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[SUNY at Buffalo]]></Name>
<CityName>Buffalo</CityName>
<StateCode>NY</StateCode>
<ZipCode>142282567</ZipCode>
<StreetAddress><![CDATA[520 Lee Entrance]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>26</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY26</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>1640</Code>
<Text>Information Technology Researc</Text>
</ProgramElement>
<ProgramElement>
<Code>7796</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramElement>
<Code>7926</Code>
<Text>ALGORITHMS</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2009~169169</FUND_OBLG>
<FUND_OBLG>2011~89744</FUND_OBLG>
<FUND_OBLG>2012~93679</FUND_OBLG>
<FUND_OBLG>2013~97215</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Error-correcting codes are clever ways of introducing redundancy in data to protect from errors. For example, <span><span>CDs</span></span> and <span><span>DVDs</span></span> work correctly in the presence of scratches since they use a specific family of codes called Reed-Solomon codes. These codes have been used for decades in various applications such as communication from outer space, handling errors in storage disks and even bar codes. Surprisingly, we still do not understand the limits of how many errors these Reed-Solomon codes can handle. The first major result of this project showed that Reed-Solomon codes can handle many more errors than previously known. In particular, we show that one can correct significantly more errors than the theoretically best known error recovery algorithm for Reed-Solomon codes from 1998. However, our results only show the possibility of correcting more errors: we do not yet have an efficient error recovery algorithm to do so.<br /><br />One of the central algorithmic tasks in a database system is to synthesize information from various sources and present a consolidated view. A fundamental operator that achieves this task is the database join. Given its central place in database systems, researchers and engineers over multiple decades have proposed and implemented many algorithms and heuristics to solve the database join problem. Our second main result is the first provably optimal algorithms to compute the database join. It can be shown that all of the previously known techniques are provably not optimal.&nbsp; Our algorithm also outperforms several existing database join implements in practice.<br /><br />This project supported the training of two Ph.D. students as well as writing of a draft of a textbook on error-correcting codes. (The current draft is available here: <span><span>http</span></span>://<span><span>www</span></span>.<span><span>cse</span></span>.buffalo.<span><span>edu</span></span>/<span><span>~atri</span></span>/courses/coding-theory/book/index.<span><span>html</span></span>)</p><br> <p>            Last Modified: 04/23/2015<br>      Modified by: Atri&nbsp;Rudra</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Error-correcting codes are clever ways of introducing redundancy in data to protect from errors. For example, CDs and DVDs work correctly in the presence of scratches since they use a specific family of codes called Reed-Solomon codes. These codes have been used for decades in various applications such as communication from outer space, handling errors in storage disks and even bar codes. Surprisingly, we still do not understand the limits of how many errors these Reed-Solomon codes can handle. The first major result of this project showed that Reed-Solomon codes can handle many more errors than previously known. In particular, we show that one can correct significantly more errors than the theoretically best known error recovery algorithm for Reed-Solomon codes from 1998. However, our results only show the possibility of correcting more errors: we do not yet have an efficient error recovery algorithm to do so.  One of the central algorithmic tasks in a database system is to synthesize information from various sources and present a consolidated view. A fundamental operator that achieves this task is the database join. Given its central place in database systems, researchers and engineers over multiple decades have proposed and implemented many algorithms and heuristics to solve the database join problem. Our second main result is the first provably optimal algorithms to compute the database join. It can be shown that all of the previously known techniques are provably not optimal.  Our algorithm also outperforms several existing database join implements in practice.  This project supported the training of two Ph.D. students as well as writing of a draft of a textbook on error-correcting codes. (The current draft is available here: http://www.cse.buffalo.edu/~atri/courses/coding-theory/book/index.html)       Last Modified: 04/23/2015       Submitted by: Atri Rudra]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
