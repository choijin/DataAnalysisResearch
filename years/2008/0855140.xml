<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CI-ADDO-EN: Infrastructure for the Production of Languages</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2009</AwardEffectiveDate>
<AwardExpirationDate>08/31/2014</AwardExpirationDate>
<AwardTotalIntnAmount>660000.00</AwardTotalIntnAmount>
<AwardAmount>660000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>In response to a strong demand from its users, the PLT infrastructure project aims to equip the PLT Scheme software infrastructure with four key components. Objective one is to reduce the running time of PLT Scheme object code; the PIs intend to accomplish this with the addition of a just- in-time compiler. The second objective calls for an enhanced ability to embed foreign code into PLT Scheme and vice versa; the plan calls for the implementation of a dynamic foreign function interface that allows programmers to develop and embed C code in an incremental manner. The project's third objective is to integrate a web repository for software libraries directly into the programming language. Objective four is to assist educational users (middle schools, high schools, colleges, and some graduate courses) with additional teaching libraries; to this end, the PIs are designing a framework for plugging special-purpose functional languages into the PLT Scheme framework.</AbstractNarration>
<MinAmdLetterDate>08/28/2009</MinAmdLetterDate>
<MaxAmdLetterDate>06/25/2012</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0855140</AwardID>
<Investigator>
<FirstName>Matthias</FirstName>
<LastName>Felleisen</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Matthias Felleisen</PI_FULL_NAME>
<EmailAddress>matthias@ccs.neu.edu</EmailAddress>
<PI_PHON>6173732462</PI_PHON>
<NSF_ID>000286813</NSF_ID>
<StartDate>08/28/2009</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Northeastern University</Name>
<CityName>BOSTON</CityName>
<ZipCode>021155005</ZipCode>
<PhoneNumber>6173733004</PhoneNumber>
<StreetAddress>360 HUNTINGTON AVE</StreetAddress>
<StreetAddress2><![CDATA[177-500]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001423631</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>NORTHEASTERN UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001423631</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Northeastern University]]></Name>
<CityName>BOSTON</CityName>
<StateCode>MA</StateCode>
<ZipCode>021155005</ZipCode>
<StreetAddress><![CDATA[360 HUNTINGTON AVE]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7359</Code>
<Text>CCRI-CISE Cmnty Rsrch Infrstrc</Text>
</ProgramElement>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2009~250000</FUND_OBLG>
<FUND_OBLG>2010~180000</FUND_OBLG>
<FUND_OBLG>2011~130000</FUND_OBLG>
<FUND_OBLG>2012~100000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><br />Software engineers use programming languages to give instructions to a computer (running, for example, the Windows operating system) or a platform (say, a web browser) but also to communicate with each other. For both tasks, the chosen language dictates how easily a programmer can articulate his/her thoughts about a problem and its solution. For the latter task, the choice of language also determines how quickly an engineer other than the creator of some code can comprehend.&nbsp;</p> <p>More recently, software engineers have also created special programmingl anguages for domain specialists without (or little) training inprogramming such as biologists, doctors or musicians. With such languages, a biologist may describe the pathway into a cell or amusician may express parts of a drum solo. This project inspired a doctor at Northwestern to articulate opiate prescriptions as programs to reduce the number of accidental deaths. These languages are successful if domain specialists can ``think'' in them and software engineers can easily connect this code to the surrounding software infrastructure.&nbsp;</p> <p>Because of these needs, researchers are in need of new tools for rapidly creating programming languages of all kinds and shapes. This NSF Infrastructure grant financed the production of tools for the Racket programming language, which is a language for creating languages.Northeastern University was the lead institution, while Brown University, Northwestern University, and the University of Utah were subcontractors.</p> <p>I<strong>NTELLECTUAL MERIT</strong> With the construction of the Racket infrastructure, the team confirmed the basic thesis of the proposal, namely, that with Racket, programmers can produce languages as libraries. Once a language is just a library, other programmers can easily reuse it for many projects and, moreimportantly, can reuse the vast number of existing tools for the hostlanguage to program in it. In the case of Racket, a programming language produced in Racket can reuse the IDE (DrRacket), its syntax annotation system, its stepper, its debugger, its profiler, and other, smaller tools. For example, within the Racket code base, 40 Racket-derived languages coexist.</p> <p><strong>BROADER IMPACT</strong> One of the many languages produced is a language for teaching middle school and high school students how to program with mathematics especially algebra. The language includes a system for creating graphical user interfaces, say animations or video games, from plain mathematics. As a result, students who program in this language simultaneously learn to program and enhance their mathematical problem solving skills. The languagei s available within the Racket infrastructure as well as a standaloneWeb-delivered platform (WeScheme).</p> <p>In addition to this continued support for outreach project, the projectalso had a major influence on two large industrial language design projects: Oracle/Sun's FORTRESS and Mozilla's RUST. Both teams employed current or former PhD students of the team to design and implement subsystems for the production of programming languages. --&nbsp;</p> <p>Google has recently adopted the team's optimization coach for its JavaScript implementation.</p> <p>LogicBox has adopted the logic-constraint programming language to the Clojure programming language.&nbsp;</p> <p><strong>OUTCOMES </strong>The team produced a wealth of tools and papers with the funding from the Infrastructure proposal.&nbsp;</p> <p>The tools include an enhanced IDE for developing languages, a plug-in forreporting novice-friendly error messages, a novel ``open compilers'' alsoknown as optimization coach, the first stepper for lazy languages, a logic-constraint programming language, and a tool that constructs a run-time value flow graph to discover opportunities for injecting laziness into data structure algorithms.</p> <p>The papers appeared at a w...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  Software engineers use programming languages to give instructions to a computer (running, for example, the Windows operating system) or a platform (say, a web browser) but also to communicate with each other. For both tasks, the chosen language dictates how easily a programmer can articulate his/her thoughts about a problem and its solution. For the latter task, the choice of language also determines how quickly an engineer other than the creator of some code can comprehend.   More recently, software engineers have also created special programmingl anguages for domain specialists without (or little) training inprogramming such as biologists, doctors or musicians. With such languages, a biologist may describe the pathway into a cell or amusician may express parts of a drum solo. This project inspired a doctor at Northwestern to articulate opiate prescriptions as programs to reduce the number of accidental deaths. These languages are successful if domain specialists can ``think'' in them and software engineers can easily connect this code to the surrounding software infrastructure.   Because of these needs, researchers are in need of new tools for rapidly creating programming languages of all kinds and shapes. This NSF Infrastructure grant financed the production of tools for the Racket programming language, which is a language for creating languages.Northeastern University was the lead institution, while Brown University, Northwestern University, and the University of Utah were subcontractors.  INTELLECTUAL MERIT With the construction of the Racket infrastructure, the team confirmed the basic thesis of the proposal, namely, that with Racket, programmers can produce languages as libraries. Once a language is just a library, other programmers can easily reuse it for many projects and, moreimportantly, can reuse the vast number of existing tools for the hostlanguage to program in it. In the case of Racket, a programming language produced in Racket can reuse the IDE (DrRacket), its syntax annotation system, its stepper, its debugger, its profiler, and other, smaller tools. For example, within the Racket code base, 40 Racket-derived languages coexist.  BROADER IMPACT One of the many languages produced is a language for teaching middle school and high school students how to program with mathematics especially algebra. The language includes a system for creating graphical user interfaces, say animations or video games, from plain mathematics. As a result, students who program in this language simultaneously learn to program and enhance their mathematical problem solving skills. The languagei s available within the Racket infrastructure as well as a standaloneWeb-delivered platform (WeScheme).  In addition to this continued support for outreach project, the projectalso had a major influence on two large industrial language design projects: Oracle/Sun's FORTRESS and Mozilla's RUST. Both teams employed current or former PhD students of the team to design and implement subsystems for the production of programming languages. --   Google has recently adopted the team's optimization coach for its JavaScript implementation.  LogicBox has adopted the logic-constraint programming language to the Clojure programming language.   OUTCOMES The team produced a wealth of tools and papers with the funding from the Infrastructure proposal.   The tools include an enhanced IDE for developing languages, a plug-in forreporting novice-friendly error messages, a novel ``open compilers'' alsoknown as optimization coach, the first stepper for lazy languages, a logic-constraint programming language, and a tool that constructs a run-time value flow graph to discover opportunities for injecting laziness into data structure algorithms.  The papers appeared at a wide variety of conferences. The team published a series of papers in mainstream conferences including ESOP, ICFP, OOPSLA,POPL, and PLDI. Most of these papers explain the novel tools that the team produce...]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
