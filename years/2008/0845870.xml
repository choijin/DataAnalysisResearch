<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Scalable Dynamic Program Reasoning</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>02/15/2009</AwardEffectiveDate>
<AwardExpirationDate>01/31/2016</AwardExpirationDate>
<AwardTotalIntnAmount>425000.00</AwardTotalIntnAmount>
<AwardAmount>425000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>In software engineering, dynamic analysis is the checking of correct program behavior during program executions. Dynamic analysis is advancing beyond traditional capabilities such as profiling, trace traversing, and simple property verification. The broader ramifications of dynamic analysis hinge on meeting a key challenge called dynamic reasoning, which asks what transformations on a program execution would lead to logical satisfaction of the properties. For example, in data race detection, deciding whether a data race is benign can be translated into deciding if changing the order of the two conflicting memory accesses affects the output. Automatically patching faulty code is equivalent to looking for changes so that the desired output can be produced. &lt;br/&gt;&lt;br/&gt;This research targets a number of key challenges for dynamic reasoning. Novel canonical representations facilitate aligning executions, particularly the original execution and its transformed version, so that execution comparison can be performed at compatible places. Efficient transformation techniques include checkpointing long executions and selectively perturbing execution state to observe satisfiability. A reasoning engine based on constraint solving aims to translate an arbitrary execution region into symbolic constraints and then use a solver to reason about satisfiability.  Using dynamic slicing to delimit the execution region is the key to scalability.  Among the broader impacts will be certifiably more correct software. &lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>02/18/2009</MinAmdLetterDate>
<MaxAmdLetterDate>05/23/2013</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0845870</AwardID>
<Investigator>
<FirstName>Xiangyu</FirstName>
<LastName>Zhang</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Xiangyu Zhang</PI_FULL_NAME>
<EmailAddress>xyzhang@cs.purdue.edu</EmailAddress>
<PI_PHON>7654944600</PI_PHON>
<NSF_ID>000494973</NSF_ID>
<StartDate>02/18/2009</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Purdue University</Name>
<CityName>West Lafayette</CityName>
<ZipCode>479072114</ZipCode>
<PhoneNumber>7654941055</PhoneNumber>
<StreetAddress>Young Hall</StreetAddress>
<StreetAddress2><![CDATA[155 S Grant Street]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>072051394</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PURDUE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>072051394</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Purdue University]]></Name>
<CityName>West Lafayette</CityName>
<StateCode>IN</StateCode>
<ZipCode>479072114</ZipCode>
<StreetAddress><![CDATA[Young Hall]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0113</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2009~85000</FUND_OBLG>
<FUND_OBLG>2010~85000</FUND_OBLG>
<FUND_OBLG>2011~85000</FUND_OBLG>
<FUND_OBLG>2012~85000</FUND_OBLG>
<FUND_OBLG>2013~85000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This project sets out to develop a technique called Dynamic Reasoning (DR) that answers the following research question: given a program execution E, what change should be made on&nbsp; a program variable X at an execution point A so that a property Y is satisfied at a later execution point B. An example is to find a predicate instance in a failing execution so that switching the branch outcome of the predicate produces the correct output. Such a dynamic patch reveals substantial information about the software failure. A DR analysis originates from one execution, perturbs the execution (by changing program state, switching predicates, or permuting interleavings) at some place to synthesize new executions, and then correlates these executions to validate properties. DR inherits the advantages from static and dynamic analyses while mitigating their limitations. It analyzes concrete executions so that it is precise; it reasons about a small number of executions or execution regions so that it scales well; it makes use of static analysis to facilitate and optimize its runtime operations. A wide range of analysis problems in various areas such as debugging, security, information assurance and scientific data validation can be classified as DR problems.</p> <p>In the project period, the PI has developed a number of primitives that enable DR, including <em>execution indexing</em> that can identify corresponding execution points across multiple executions that take different paths, <em>dual execution</em> that spawns a slave execution for a given regular execution and mutates the state of the slave execution to achieve dynamic reasoning, <em>lightweight logging and replay</em>, and <em>forced-execution</em> that suppresses exceptions caused by state mutation. These primitives feature both effectiveness and efficiency. The PI has shown that they have substantially improved the state of the art in many applications such as software vetting, forensic analysis, and debugging. Research outcomes of this project have received four best paper awards on prestigious software engineering and security conferences, and also media coverage. Some of the findings have caused Apple to revoke popular applications from their official store due to hidden suspicious behavior. Many of the techniques developed in this project are publicly released and/or transferred to industry.</p><br> <p>            Last Modified: 05/18/2016<br>      Modified by: Xiangyu&nbsp;Zhang</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This project sets out to develop a technique called Dynamic Reasoning (DR) that answers the following research question: given a program execution E, what change should be made on  a program variable X at an execution point A so that a property Y is satisfied at a later execution point B. An example is to find a predicate instance in a failing execution so that switching the branch outcome of the predicate produces the correct output. Such a dynamic patch reveals substantial information about the software failure. A DR analysis originates from one execution, perturbs the execution (by changing program state, switching predicates, or permuting interleavings) at some place to synthesize new executions, and then correlates these executions to validate properties. DR inherits the advantages from static and dynamic analyses while mitigating their limitations. It analyzes concrete executions so that it is precise; it reasons about a small number of executions or execution regions so that it scales well; it makes use of static analysis to facilitate and optimize its runtime operations. A wide range of analysis problems in various areas such as debugging, security, information assurance and scientific data validation can be classified as DR problems.  In the project period, the PI has developed a number of primitives that enable DR, including execution indexing that can identify corresponding execution points across multiple executions that take different paths, dual execution that spawns a slave execution for a given regular execution and mutates the state of the slave execution to achieve dynamic reasoning, lightweight logging and replay, and forced-execution that suppresses exceptions caused by state mutation. These primitives feature both effectiveness and efficiency. The PI has shown that they have substantially improved the state of the art in many applications such as software vetting, forensic analysis, and debugging. Research outcomes of this project have received four best paper awards on prestigious software engineering and security conferences, and also media coverage. Some of the findings have caused Apple to revoke popular applications from their official store due to hidden suspicious behavior. Many of the techniques developed in this project are publicly released and/or transferred to industry.       Last Modified: 05/18/2016       Submitted by: Xiangyu Zhang]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
