<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>Collaborative Research:    CSR-PSCE, SM:   Adaptive Memory Management in Shared Environments</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2008</AwardEffectiveDate>
<AwardExpirationDate>08/31/2012</AwardExpirationDate>
<AwardTotalIntnAmount>118657.00</AwardTotalIntnAmount>
<AwardAmount>134657</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Krishna Kant</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>Program performance is highly dependent on the amount of memory available to the&lt;br/&gt;program. In traditional computing systems, the memory working set of an application&lt;br/&gt;has a bounded size - providing more memory to an application improves performance&lt;br/&gt;until its working set is met. Once the working set is met, additional memory yields little&lt;br/&gt;or no benefit. However, in the presence of garbage collection (a technique for memory&lt;br/&gt;management where space that is unlikely to be reused by an application is&lt;br/&gt;automatically reclaimed), the relationship between program performance and memory&lt;br/&gt;allocation is more complex. Data is managed at three levels: the compiler manages&lt;br/&gt;data objects at the program level, the garbage collector manages the heap at the virtual&lt;br/&gt;machine level, and the virtual memory manager manages virtual memory at the&lt;br/&gt;operating system level. The middle layer plays a critical role. Increasing an application's&lt;br/&gt;heap size can reduce the frequency of garbage collections and improve performance,&lt;br/&gt;but too large a heap may trigger paging and degrade performance.</AbstractNarration>
<MinAmdLetterDate>08/19/2008</MinAmdLetterDate>
<MaxAmdLetterDate>06/24/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0834323</AwardID>
<Investigator>
<FirstName>Matthew</FirstName>
<LastName>Hertz</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Matthew A Hertz</PI_FULL_NAME>
<EmailAddress>mhertz@buffalo.edu</EmailAddress>
<PI_PHON>7166454736</PI_PHON>
<NSF_ID>000228258</NSF_ID>
<StartDate>08/19/2008</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Canisius College</Name>
<CityName>Buffalo</CityName>
<ZipCode>142081098</ZipCode>
<PhoneNumber>7168882103</PhoneNumber>
<StreetAddress>2001 Main Street</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>26</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY26</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>071486583</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>CANISIUS COLLEGE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071486583</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Canisius College]]></Name>
<CityName>Buffalo</CityName>
<StateCode>NY</StateCode>
<ZipCode>142081098</ZipCode>
<StreetAddress><![CDATA[2001 Main Street]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>26</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY26</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>9178</Code>
<Text>UNDERGRADUATE EDUCATION</Text>
</ProgramReference>
<ProgramReference>
<Code>9216</Code>
<Text>ADVANCED SOFTWARE TECH &amp; ALGOR</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2008~76930</FUND_OBLG>
<FUND_OBLG>2009~41727</FUND_OBLG>
<FUND_OBLG>2010~16000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Program performance is highly dependent on the amount of memory available to the program. While this is true for all programs, it is especially true for programs using garbage collection.&nbsp; Garbage collection (or, less formally, "dynamic memory management") improves program security and programmer productivity by automating several common, error-prone memory requirements.&nbsp; This improvement comes at a cost of dramatically increasing the program's overall memory demands and, in particular, the amount of memory it uses on a regular basis (its "working set").&nbsp; When the computer does not have enough free RAM to meet these demands, the performance of garbage collected applications plummets and quickly becomes unusable.&nbsp; While past projects had looked at improving this performance for single programs running on dedicated machines, this project developed techniques that work in the multi-programmed environments that are really used today.</p> <p>This process is complicated by the fact that the relationship between program performance and memory allocation is complex. Data is managed at three levels: the compiler manages data objects at the program level, the garbage collector manages the heap at the virtual machine level, and the virtual memory manager manages virtual memory at the operating system level. Our approach, which we named Poor Richard's Memory Manager, was based off the maxim "a penny saved is a penny earned."&nbsp; It targets that crucial middle level, but does so in a way that is independent of the actual garbage collector.&nbsp; By making our changes small and portable, we can save the performance optimizations that already exist within existing systems. We then used a collaborative approach in which processes work from a common "whiteboard" to make system-wide decisions and insure that they fully utilize memory.&nbsp; The result of these decisions was an algorithm that could be easily added to any garbage collection system (it required under 100 lines of code within the actual GC) and works within any operating system. Our results showed that it improved the performance of every garbage collector on which we tried and could scale from simple single processor systems all the way up to multiprocessor, multicore workstations.&nbsp; This should greatly improve the performance of garbage collection on all these machines and make it easier to gain the program safety and improved productivity these languages provide.</p><br> <p>            Last Modified: 11/30/2012<br>      Modified by: Matthew&nbsp;A&nbsp;Hertz</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Program performance is highly dependent on the amount of memory available to the program. While this is true for all programs, it is especially true for programs using garbage collection.  Garbage collection (or, less formally, "dynamic memory management") improves program security and programmer productivity by automating several common, error-prone memory requirements.  This improvement comes at a cost of dramatically increasing the program's overall memory demands and, in particular, the amount of memory it uses on a regular basis (its "working set").  When the computer does not have enough free RAM to meet these demands, the performance of garbage collected applications plummets and quickly becomes unusable.  While past projects had looked at improving this performance for single programs running on dedicated machines, this project developed techniques that work in the multi-programmed environments that are really used today.  This process is complicated by the fact that the relationship between program performance and memory allocation is complex. Data is managed at three levels: the compiler manages data objects at the program level, the garbage collector manages the heap at the virtual machine level, and the virtual memory manager manages virtual memory at the operating system level. Our approach, which we named Poor Richard's Memory Manager, was based off the maxim "a penny saved is a penny earned."  It targets that crucial middle level, but does so in a way that is independent of the actual garbage collector.  By making our changes small and portable, we can save the performance optimizations that already exist within existing systems. We then used a collaborative approach in which processes work from a common "whiteboard" to make system-wide decisions and insure that they fully utilize memory.  The result of these decisions was an algorithm that could be easily added to any garbage collection system (it required under 100 lines of code within the actual GC) and works within any operating system. Our results showed that it improved the performance of every garbage collector on which we tried and could scale from simple single processor systems all the way up to multiprocessor, multicore workstations.  This should greatly improve the performance of garbage collection on all these machines and make it easier to gain the program safety and improved productivity these languages provide.       Last Modified: 11/30/2012       Submitted by: Matthew A Hertz]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
