<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CPA-SEL: Collaborative Research - Continuing Progress Toward Verified Software</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2008</AwardEffectiveDate>
<AwardExpirationDate>02/28/2013</AwardExpirationDate>
<AwardTotalIntnAmount>232591.00</AwardTotalIntnAmount>
<AwardAmount>295106</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Most engineered artifacts, such as bridges and nuclear power plants, are tested by subjecting them to operating conditions and observing results.&lt;br/&gt;Software is different.  It manifests dynamic behavior when running on computers, and software quality (with respect to achieving specified&lt;br/&gt;behavior) is normally tested that way.  But software also can be considered purely symbolic -- a sequence of instructions -- and hence can be subjected to mathematical proof of correctness. Achieving such "verified software" has been identified as a "grand challenge" for computing research.  The work of this project's interdisciplinary team of software engineers and logicians focuses on the thesis that practical, scalable, automated software verification is feasible, one component at a time, by combining careful language design with recent advances in automated theorem proving.  The plan is to evaluate this thesis empirically by generating the logical verification conditions for a benchmark suite of software components like those used in computing courses and commercial software, and proving them automatically.  The project's significance will derive from its proof of concept that the verified software grand challenge can be conquered, and from a better understanding of what the next generation of software engineers need to be taught to produce verified software.&lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>08/09/2008</MinAmdLetterDate>
<MaxAmdLetterDate>08/26/2011</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0811737</AwardID>
<Investigator>
<FirstName>Bruce</FirstName>
<LastName>Weide</LastName>
<PI_MID_INIT>W</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Bruce W Weide</PI_FULL_NAME>
<EmailAddress>weide.1@osu.edu</EmailAddress>
<PI_PHON>6142921517</PI_PHON>
<NSF_ID>000279349</NSF_ID>
<StartDate>08/09/2008</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Harvey</FirstName>
<LastName>Friedman</LastName>
<PI_MID_INIT>M</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Harvey M Friedman</PI_FULL_NAME>
<EmailAddress>friedman@math.ohio-state.edu</EmailAddress>
<PI_PHON>6142929079</PI_PHON>
<NSF_ID>000312906</NSF_ID>
<StartDate>08/09/2008</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Ohio State University Research Foundation -DO NOT USE</Name>
<CityName>Columbus</CityName>
<ZipCode>432101016</ZipCode>
<PhoneNumber>6146888734</PhoneNumber>
<StreetAddress>1960 KENNY RD</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Ohio</StateName>
<StateCode>OH</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>OH03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>071650709</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>OHIO STATE UNIVERSITY RESEARCH FOUNDATION, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM/>
</Institution>
<Performance_Institution>
<Name><![CDATA[Ohio State University]]></Name>
<CityName>Columbus</CityName>
<StateCode>OH</StateCode>
<ZipCode>432101016</ZipCode>
<StreetAddress><![CDATA[Office of Sponsored Programs]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Ohio</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>OH03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>2880</Code>
<Text>SOFTWARE ENGINEERING AND LANGU</Text>
</ProgramElement>
<ProgramElement>
<Code>7352</Code>
<Text>COMPUTING PROCESSES &amp; ARTIFACT</Text>
</ProgramElement>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0111</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2008~232591</FUND_OBLG>
<FUND_OBLG>2009~15999</FUND_OBLG>
<FUND_OBLG>2011~46516</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>About 10 years ago, a grand-challenge problem for computer science was posed to the research community: to develop a "verifying compiler". &nbsp;This is a compiler that produces executable code from a computer program's source code only when it can <em>prove mathematically and automatically</em> that the program will always behave as specified. &nbsp;While the importance of verified-as-correct software to U.S. national security and infrastructure is apparent, the critical and growing role of correct software to our society at large, where CT scans are interpreted and cars and planes are controlled by software, cannot be overstated.</p> <p>This project's primary technical outcomes include a prototype of such a verifying compiler for a research programming language (RESOLVE) with features very similar to those widely used in commercial practice (e.g., Java, C#); a set of benchmark problems to be used in comparing the capabilities of verifying compilers that might be developed by our research group and others around the world; and a host of detailed guidelines and rules-of-thumb that permit well-designed software systems of essentially arbitrary size to be automatically proved correct, one software component at a time.</p> <p>The intellectual merit of the project's outcomes lies primarily in the combined importance and difficulty of developing correct software. &nbsp;No one seriously doubts the long-term practical importance of fully correct software, or its relevance to long-term U.S. national competitiveness. &nbsp;Yet there was, until recently, a stark difference between the global technical leadership situation in software verification research and that in most other computer science research areas. &nbsp;The U.S. was clearly <em>not</em> the epicenter of research toward a verifying compiler; Europe was. &nbsp;In the past few years, however, prototype verifying compilers that have been developed at Microsoft Research, Ohio State University, and Clemson University (the latter two under this collaborative research project) have proved uniquely able to deal with some of the difficult practical issues faced by software engineers using modern industrial-strength programming languages.</p> <p>The broader impacts of the project's outcomes lie primarily in how our verifying compiler has affected the way we educate future computer scientists. &nbsp;For nearly 20 years, undergraduate computer science majors at Ohio State have learned how to use formal (mathematical) specifications of the intended behavior of software in order to say exactly how that software is supposed to behave. &nbsp;Until recently, though, the tools they used to check compliance with this intended behavior were based on semi-automated testing, similar to the approach presently used in industry practice. &nbsp;Any mathematical proofs of correctness assigned to the students were necessarily for trivial programs because these proofs are tedious for humans to carry out. &nbsp;Now, we are able to demonstrate the true value of having good formal specifications for software: our prototype verifying compiler can process programs with sophisticated specifications and either automatically prove they are correct for those specifications, or automatically point directly to locations in the program code that have defects. &nbsp;The "lights go on" for many students when they see how much more effective than testing such a tool can be -- <em>if</em> they learn to apply in their software engineering courses the mathematics and logic they have learned throughout the rest of the curriculum. &nbsp;In addition to this impact on literally hundreds of students each semester, the project supported three completed Ph.D. students (now at Google, Intel, and SpaceX) and three other students who are currently in the final two years of their Ph.D. studies.</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p><br> <p>            Last Modifi...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ About 10 years ago, a grand-challenge problem for computer science was posed to the research community: to develop a "verifying compiler".  This is a compiler that produces executable code from a computer program's source code only when it can prove mathematically and automatically that the program will always behave as specified.  While the importance of verified-as-correct software to U.S. national security and infrastructure is apparent, the critical and growing role of correct software to our society at large, where CT scans are interpreted and cars and planes are controlled by software, cannot be overstated.  This project's primary technical outcomes include a prototype of such a verifying compiler for a research programming language (RESOLVE) with features very similar to those widely used in commercial practice (e.g., Java, C#); a set of benchmark problems to be used in comparing the capabilities of verifying compilers that might be developed by our research group and others around the world; and a host of detailed guidelines and rules-of-thumb that permit well-designed software systems of essentially arbitrary size to be automatically proved correct, one software component at a time.  The intellectual merit of the project's outcomes lies primarily in the combined importance and difficulty of developing correct software.  No one seriously doubts the long-term practical importance of fully correct software, or its relevance to long-term U.S. national competitiveness.  Yet there was, until recently, a stark difference between the global technical leadership situation in software verification research and that in most other computer science research areas.  The U.S. was clearly not the epicenter of research toward a verifying compiler; Europe was.  In the past few years, however, prototype verifying compilers that have been developed at Microsoft Research, Ohio State University, and Clemson University (the latter two under this collaborative research project) have proved uniquely able to deal with some of the difficult practical issues faced by software engineers using modern industrial-strength programming languages.  The broader impacts of the project's outcomes lie primarily in how our verifying compiler has affected the way we educate future computer scientists.  For nearly 20 years, undergraduate computer science majors at Ohio State have learned how to use formal (mathematical) specifications of the intended behavior of software in order to say exactly how that software is supposed to behave.  Until recently, though, the tools they used to check compliance with this intended behavior were based on semi-automated testing, similar to the approach presently used in industry practice.  Any mathematical proofs of correctness assigned to the students were necessarily for trivial programs because these proofs are tedious for humans to carry out.  Now, we are able to demonstrate the true value of having good formal specifications for software: our prototype verifying compiler can process programs with sophisticated specifications and either automatically prove they are correct for those specifications, or automatically point directly to locations in the program code that have defects.  The "lights go on" for many students when they see how much more effective than testing such a tool can be -- if they learn to apply in their software engineering courses the mathematics and logic they have learned throughout the rest of the curriculum.  In addition to this impact on literally hundreds of students each semester, the project supported three completed Ph.D. students (now at Google, Intel, and SpaceX) and three other students who are currently in the final two years of their Ph.D. studies.                Last Modified: 06/27/2013       Submitted by: Bruce W Weide]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
