<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>Compiler Technology for Scalable Servers</AwardTitle>
<AwardEffectiveDate>09/01/2000</AwardEffectiveDate>
<AwardExpirationDate>08/31/2004</AwardExpirationDate>
<AwardTotalIntnAmount>240000.00</AwardTotalIntnAmount>
<AwardAmount>240000</AwardAmount>
<AwardInstrument>
<Value>Continuing grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Xiaodong Zhang</SignBlockName>
</ProgramOfficer>
<AbstractNarration>This research investigates compiler techniques for improving the&lt;br/&gt;performance and scalability of Internet server programs. Servers have&lt;br/&gt;a different set of characteristics from the computations that compiler&lt;br/&gt;writers have focused on in the past. Instead of executing a&lt;br/&gt;compute-bound computation with a modest number of long-lived threads,&lt;br/&gt;servers typically use many short-lived threads to manage I/O bound&lt;br/&gt;connections from multiple clients. These new characteristics place a&lt;br/&gt;premium on previously less relevant aspects of the system such as the&lt;br/&gt;thread creation overhead and thread stack overhead. They also provide&lt;br/&gt;opportunities that the compiler can exploit to improve the memory&lt;br/&gt;management. The research will attack thread overhead by automatically&lt;br/&gt;transforming multithreaded code to event-driven form.  Code in&lt;br/&gt;event-driven form contains an event loop that repeatedly blocks&lt;br/&gt;waiting for the next event from any of the current connections. It&lt;br/&gt;then invokes a handler that executes the appropriate action, then&lt;br/&gt;returns to the event loop. This transformation will eliminate thread&lt;br/&gt;creation and management overhead. The compiler will attack memory&lt;br/&gt;management overhead by analyzing the program to identify objects whose&lt;br/&gt;lifetimes are tied to individual threads, then using specialized&lt;br/&gt;memory management algorithms for these objects.&lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>09/06/2000</MinAmdLetterDate>
<MaxAmdLetterDate>02/05/2004</MaxAmdLetterDate>
<ARRAAmount/>
<AwardID>0073513</AwardID>
<Investigator>
<FirstName>Martin</FirstName>
<LastName>Rinard</LastName>
<EmailAddress>rinard@lcs.mit.edu</EmailAddress>
<StartDate>09/06/2000</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
</Institution>
<ProgramElement>
<Code>2876</Code>
<Text>DISTRIBUTED SYSTEMS</Text>
</ProgramElement>
<ProgramReference>
<Code>9215</Code>
<Text>HIGH PERFORMANCE COMPUTING SYSTEMS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
</Award>
</rootTag>
