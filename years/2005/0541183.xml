<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>Deep and Scalable Software Checking</AwardTitle>
<AwardEffectiveDate>07/01/2006</AwardEffectiveDate>
<AwardExpirationDate>06/30/2010</AwardExpirationDate>
<AwardAmount>375000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sankar Basu</SignBlockName>
</ProgramOfficer>
<AbstractNarration>ABSTRACT&lt;br/&gt;CCF-0541183&lt;br/&gt;PI: Daniel Jackson, MIT&lt;br/&gt;&lt;br/&gt;Deep and Scalable Software Checking&lt;br/&gt;&lt;br/&gt;The growing role of software in civic infrastructure and the potentially huge costs of software failure make dependable software a pressing need. Technology for developing dependable software will be vital to the US economy in the coming decades.&lt;br/&gt;&lt;br/&gt;This project is developing a new approach for checking software to ensure that it has the desired high-level properties. In industry, two techniques are widely used: testing, which cannot achieve sufficient coverage to find the defects responsible for low-probability failures, and static analysis (such as type checking),  &lt;br/&gt;which can typically handle only very limited properties, such as the absence of certain kinds of overflow or exception. In research, there has been a renewed interest in deeper techniques that are capable of finding the most subtle defects and thus dramatically increasing the developer's confidence in the correctness of the code. Unfortunately, these have tended not be scalable, since they often require more resources (either in computation or in human effort) than is economical. This project is exploring a new approach that promises  &lt;br/&gt;both depth and scalability, in which a program is checked not for every possible case (which seems to lead to scalability problems), but rather for every case within some finite bounds. The key idea is to generate a logical formula (representing the behaviours of the code), and to present it with a similar formula (characterizing failure to satisfy a required property) to a constraint solver, which then uses powerful search techniques to explore a huge space of potential executions for those that would result in failures.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>07/25/2006</MinAmdLetterDate>
<MaxAmdLetterDate>07/25/2006</MaxAmdLetterDate>
<ARRAAmount/>
<AwardID>0541183</AwardID>
<Investigator>
<FirstName>Daniel</FirstName>
<LastName>Jackson</LastName>
<EmailAddress>dnj@csail.mit.edu</EmailAddress>
<StartDate>07/25/2006</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
</Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7352</Code>
<Text>COMPUTING PROCESSES &amp; ARTIFACT</Text>
</ProgramElement>
<ProgramReference>
<Code>7352</Code>
<Text>COMPUTING PROCESSES &amp; ARTIFACT</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
</Award>
</rootTag>
