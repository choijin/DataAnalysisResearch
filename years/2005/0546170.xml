<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CAREER: Modular Verification of Software</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>03/15/2006</AwardEffectiveDate>
<AwardExpirationDate>02/29/2012</AwardExpirationDate>
<AwardTotalIntnAmount>320000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>ABSTRACT&lt;br/&gt;0546170&lt;br/&gt;Rupak Majumdar&lt;br/&gt;University of California - Los Angeles,&lt;br/&gt;&lt;br/&gt;Modular Verification of Software Majumdar&lt;br/&gt;&lt;br/&gt;Intellectual Merits. Writing correct software is hard. Our techniques to ensure software reliability&lt;br/&gt;lag far behind our requirements for more and more complex systems. Unlike for lowlevel correctness requirements (such as correct syntax, or correct use of types), application level properties are currently not specifiable or automatically checkable. Testing remains the dominant methodology to ensure software quality with regard to application level properties, however, it is not exhaustive, and nasty bugs are often exposed post-deployment. Thus, the availability of analyses that can automatically check higher-level properties of large software systems soundly and precisely will mark a major advance in our ability to develop more reliable software.  This project leverages recent advances in software verification and explores new ideas to significantly extend the capabilities of modern verification tools to handle larger programs and more complex properties. We contend that the leap to scalably verifying end-to-end properties of software&lt;br/&gt;will be enabled by novel techniques in modular software verification, over and above existing techniques like model checking, predicate abstraction, and abstraction refinement. While the basic principles of modularity in system verification have been known for decades, they have not been widely adopted in program analysis tools because there is no push-button way to apply them in full generality. We focus on the technical challenges in automating modular verification by studying the following widely occurring verification patterns.  Tighter integration of type information in model checking through predicated types.  Automatically synthesizing temporal interfaces that specify behavioral requirements.  Integration of abstract data types into symbolic reasoning.  Automatic parameterized verification through design decomposition.  Our research will immediately benefit any large software system where robustness and reliability are pressing concerns; we shall validate our research by verifying end-to-end properties of enterprise applications and high performance servers from which we derived the verification patterns and which are beyond the scope of current tools.</AbstractNarration>
<MinAmdLetterDate>02/07/2006</MinAmdLetterDate>
<MaxAmdLetterDate>03/29/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0546170</AwardID>
<Investigator>
<FirstName>Rupak</FirstName>
<LastName>Majumdar</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Rupak Majumdar</PI_FULL_NAME>
<EmailAddress>rupak@cs.ucla.edu</EmailAddress>
<PI_PHON>3108258127</PI_PHON>
<NSF_ID>000490653</NSF_ID>
<StartDate>02/07/2006</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Los Angeles</Name>
<CityName>LOS ANGELES</CityName>
<ZipCode>900951406</ZipCode>
<PhoneNumber>3107940102</PhoneNumber>
<StreetAddress>10889 Wilshire Boulevard</StreetAddress>
<StreetAddress2><![CDATA[Suite 700]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>33</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA33</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>092530369</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CALIFORNIA, LOS ANGELES</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Los Angeles]]></Name>
<CityName>LOS ANGELES</CityName>
<StateCode>CA</StateCode>
<ZipCode>900951406</ZipCode>
<StreetAddress><![CDATA[10889 Wilshire Boulevard]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>33</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA33</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>1640</Code>
<Text>Information Technology Researc</Text>
</ProgramElement>
<ProgramElement>
<Code>2880</Code>
<Text>SOFTWARE ENGINEERING AND LANGU</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0106</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0107</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2006~80000</FUND_OBLG>
<FUND_OBLG>2007~80000</FUND_OBLG>
<FUND_OBLG>2008~160000</FUND_OBLG>
<FUND_OBLG>2010~80000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The main goal of the project was to develop techniques and tools that would automatically find bugs in large software implementations. Software bugs are very common in large systems, and range from minor annoyances to catastrophic. They cost the economy billions of dollars.</p> <p>Over the last decade, a class of techniques, called model checking, have addressed the problem of software reliability. These techniques automatically analyze a piece of code to check if all possible executions of the program are correct with respect to a programmer-specified property. A programmer-specified property can be an assertion in the code, or state generic properties such as the program should not access memory outside some valid region.&nbsp;</p> <p>The outcome of this project are algorithms and tools for model checking software implementations. The project came up with theoretical algorithms to model check parameterized and asynchronous programs. Asynchronous programs are concurrent programs using a common programming idiom that is used in servers, in web programs, and in smartphones. Parameterized programs are families of programs that can run arbitrarily many threads at one time. The theoretical results developed in the project show how to automatically analyze such programs.</p> <p>As part of this project, we also developed the tools Blast and Splat. Blast takes a C program and a property and makes sure that either all executions of the program satisfy the property or finds a test case that violates the property. Splat is a test generation tool for C programs. It automatically generates a set of tests that is sufficient to visit all program statements.</p> <p>Blast and Splat are available online, and have been used in many different domains both within academia and in industry. For example, Blast was used to verify kernel device drivers in Linux and Splat was used to generate tests in engine control units.</p><br> <p>            Last Modified: 01/26/2016<br>      Modified by: Rupak&nbsp;Majumdar</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The main goal of the project was to develop techniques and tools that would automatically find bugs in large software implementations. Software bugs are very common in large systems, and range from minor annoyances to catastrophic. They cost the economy billions of dollars.  Over the last decade, a class of techniques, called model checking, have addressed the problem of software reliability. These techniques automatically analyze a piece of code to check if all possible executions of the program are correct with respect to a programmer-specified property. A programmer-specified property can be an assertion in the code, or state generic properties such as the program should not access memory outside some valid region.   The outcome of this project are algorithms and tools for model checking software implementations. The project came up with theoretical algorithms to model check parameterized and asynchronous programs. Asynchronous programs are concurrent programs using a common programming idiom that is used in servers, in web programs, and in smartphones. Parameterized programs are families of programs that can run arbitrarily many threads at one time. The theoretical results developed in the project show how to automatically analyze such programs.  As part of this project, we also developed the tools Blast and Splat. Blast takes a C program and a property and makes sure that either all executions of the program satisfy the property or finds a test case that violates the property. Splat is a test generation tool for C programs. It automatically generates a set of tests that is sufficient to visit all program statements.  Blast and Splat are available online, and have been used in many different domains both within academia and in industry. For example, Blast was used to verify kernel device drivers in Linux and Splat was used to generate tests in engine control units.       Last Modified: 01/26/2016       Submitted by: Rupak Majumdar]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
