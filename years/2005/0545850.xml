<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>"CAREER:" Enforcing and Validating User-Defined Programming Disciplines</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>03/15/2006</AwardEffectiveDate>
<AwardExpirationDate>02/29/2012</AwardExpirationDate>
<AwardTotalIntnAmount>320000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>John Reppy</SignBlockName>
<PO_EMAI/>
<PO_PHON/>
</ProgramOfficer>
<AbstractNarration>ABSTRACT&lt;br/&gt;&lt;br/&gt;CCF-0545850&lt;br/&gt;Todd Millstein&lt;br/&gt;University of California - Los Angeles&lt;br/&gt;&lt;br/&gt;CAREER: Enforcing and Validating User-Defined Programming Disciplines&lt;br/&gt;&lt;br/&gt;Programmers manage the complexity of developing and maintaining software systems by adhering to various programming disciplines, which impose additional structure on program entities.  However, today's&lt;br/&gt;programming languages lack support for specifying and checking important classes of programming disciplines, making these disciplines easy to forget or misuse.  This research investigates a framework for&lt;br/&gt;user-defined programming disciplines.  A user of the framework specifies a programming discipline through declarative rules, which are automatically enforced on programs at compile time.  The user may also specify a discipline's intended run-time invariants, and the framework helps to ensure that the provided rules respect these invariants.  The research focuses on an instantiation of the framework for Java that targets three major discipline classes: disciplines for design patterns; disciplines that impose structure on concurrent&lt;br/&gt;programs, and disciplines that ensure strong forms of object encapsulation.  The proposed framework aims to improve the quality of software systems by allowing programmers to easily document, enforce, and validate relied-upon programming disciplines.  The resulting tools will be made publicly available and incorporated in the classroom.&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>02/16/2006</MinAmdLetterDate>
<MaxAmdLetterDate>03/29/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0545850</AwardID>
<Investigator>
<FirstName>Todd</FirstName>
<LastName>Millstein</LastName>
<PI_MID_INIT>D</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Todd D Millstein</PI_FULL_NAME>
<EmailAddress>todd@cs.ucla.edu</EmailAddress>
<PI_PHON>3108255942</PI_PHON>
<NSF_ID>000229495</NSF_ID>
<StartDate>02/16/2006</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of California-Los Angeles</Name>
<CityName>LOS ANGELES</CityName>
<ZipCode>900951406</ZipCode>
<PhoneNumber>3107940102</PhoneNumber>
<StreetAddress>10889 Wilshire Boulevard</StreetAddress>
<StreetAddress2><![CDATA[Suite 700]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<StateCode>CA</StateCode>
<CONGRESSDISTRICT>33</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CA33</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>092530369</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF CALIFORNIA, LOS ANGELES</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>071549000</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of California-Los Angeles]]></Name>
<CityName>LOS ANGELES</CityName>
<StateCode>CA</StateCode>
<ZipCode>900951406</ZipCode>
<StreetAddress><![CDATA[10889 Wilshire Boulevard]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>California</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>33</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CA33</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>1640</Code>
<Text>Information Technology Researc</Text>
</ProgramElement>
<ProgramElement>
<Code>2880</Code>
<Text>SOFTWARE ENGINEERING AND LANGU</Text>
</ProgramElement>
<ProgramReference>
<Code>1045</Code>
<Text>CAREER-Faculty Erly Career Dev</Text>
</ProgramReference>
<ProgramReference>
<Code>1187</Code>
<Text>PECASE- eligible</Text>
</ProgramReference>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0106</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0107</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2006~80000</FUND_OBLG>
<FUND_OBLG>2007~80000</FUND_OBLG>
<FUND_OBLG>2008~160000</FUND_OBLG>
<FUND_OBLG>2010~80000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software is everywhere in our society and is critical to a wide range<br />of activities, from commerce and finance to scientific research to<br />control of automotive and avionics systems.&nbsp; However, building robust<br />software systems today is a significant challenge, due in part to the<br />fragile nature of the languages in which computer programs are<br />written.&nbsp; Software programmers must get myriads of small details<br />right, and any false move or omission can lead to system crashes,<br />incorrect operation, and security vulnerabilities.<br /><br />One way that programming languages help programmers manage this<br />complexity is by checking a set of correctness constraints on<br />programs.&nbsp; The checkers, called <em>static type systems</em>, check programs<br />before they are run and guarantee basic correctness properties for all<br />possible executions of a program.&nbsp; For example, the popular Java<br />programming language includes a static type system that can catch a<br />range of errors, from simple typos (e.g., accidentally referring to<br />some program entity by the wrong name) to more subtle issues (e.g.,<br />forgetting to handle the possibility of a network disconnection).<br /><br />While static type systems are quite useful, today they are set in<br />stone by the programming language provider and only check for a small<br />set of program errors.&nbsp; Any other checks that programmers require for<br />their applications must be performed through manual code inspection<br />and testing, a process which is costly, tedious, and error prone.<br />Therefore, it is highly desirable to allow programmers to easily<br />augment a language's static type system to enforce additional<br />constraints on programs.&nbsp; Such optional type system extensions have<br />come to be known as <em>pluggable type systems</em>.<br /><br />This project has advanced both the theory and practice of pluggable<br />type systems.&nbsp; The main artifact resulting from our research is<br />JavaCOP, the first pluggable type system for the popular Java<br />programming language.&nbsp; JavaCOP includes a special language for<br />specifying new checks and includes several expressive features that we<br />found to be necessary in practice.&nbsp; We have built a diverse suite of<br />pluggable type systems in JavaCOP and used them to ensure important<br />properties and detect errors in hundreds of thousands of lines of<br />existing Java software.<br /><br />Pluggable type systems like JavaCOP help programmers to identify<br />important errors in their software.&nbsp; Once an error is found, the<br />programmer must still deduce its cause and decide how to repair the<br />error, which are themselves difficult tasks.&nbsp; Therefore in the final<br />part of this project we have developed novel approaches to automatic <em>program repair</em>.&nbsp; Our first approach is useful during the testing phase of software development.&nbsp; Given a set of test inputs for a program, some of which cause the program to behave erroneously, our approach automatically modifies the program so that it behaves correctly on all test inputs.&nbsp; Our second approach monitors a running program for errors and automatically modifies its execution state in order to restore programmer-specified correctness properties.&nbsp; This approach allows deployed software to gracefully recover from errors in order to safely continue execution.</p><br> <p>            Last Modified: 05/21/2012<br>      Modified by: Todd&nbsp;D&nbsp;Millstein</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Software is everywhere in our society and is critical to a wide range of activities, from commerce and finance to scientific research to control of automotive and avionics systems.  However, building robust software systems today is a significant challenge, due in part to the fragile nature of the languages in which computer programs are written.  Software programmers must get myriads of small details right, and any false move or omission can lead to system crashes, incorrect operation, and security vulnerabilities.  One way that programming languages help programmers manage this complexity is by checking a set of correctness constraints on programs.  The checkers, called static type systems, check programs before they are run and guarantee basic correctness properties for all possible executions of a program.  For example, the popular Java programming language includes a static type system that can catch a range of errors, from simple typos (e.g., accidentally referring to some program entity by the wrong name) to more subtle issues (e.g., forgetting to handle the possibility of a network disconnection).  While static type systems are quite useful, today they are set in stone by the programming language provider and only check for a small set of program errors.  Any other checks that programmers require for their applications must be performed through manual code inspection and testing, a process which is costly, tedious, and error prone. Therefore, it is highly desirable to allow programmers to easily augment a language's static type system to enforce additional constraints on programs.  Such optional type system extensions have come to be known as pluggable type systems.  This project has advanced both the theory and practice of pluggable type systems.  The main artifact resulting from our research is JavaCOP, the first pluggable type system for the popular Java programming language.  JavaCOP includes a special language for specifying new checks and includes several expressive features that we found to be necessary in practice.  We have built a diverse suite of pluggable type systems in JavaCOP and used them to ensure important properties and detect errors in hundreds of thousands of lines of existing Java software.  Pluggable type systems like JavaCOP help programmers to identify important errors in their software.  Once an error is found, the programmer must still deduce its cause and decide how to repair the error, which are themselves difficult tasks.  Therefore in the final part of this project we have developed novel approaches to automatic program repair.  Our first approach is useful during the testing phase of software development.  Given a set of test inputs for a program, some of which cause the program to behave erroneously, our approach automatically modifies the program so that it behaves correctly on all test inputs.  Our second approach monitors a running program for errors and automatically modifies its execution state in order to restore programmer-specified correctness properties.  This approach allows deployed software to gracefully recover from errors in order to safely continue execution.       Last Modified: 05/21/2012       Submitted by: Todd D Millstein]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
