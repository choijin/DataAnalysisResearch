<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CRI:   IAD:    Accelerator-Based High-Performance Computing</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/01/2008</AwardEffectiveDate>
<AwardExpirationDate>03/31/2013</AwardExpirationDate>
<AwardTotalIntnAmount>569866.00</AwardTotalIntnAmount>
<AwardAmount>569866</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Commodity processors are highly programmable, but their need to support general purpose computation limits both peak and sustained performance. Such observations have motivated the use of "accelerator" boards, which are co-processing elements that interface with the host server through a standard hardware bus such as PCI-Express but have their own computational engine and typically their own memory as well. Unlike the main processor, the accelerator does not support general applications; instead, its hardware and software is tuned for only specific types of computations.  Accelerators can offload the most demanding parts of an application from the host processor, speeding up the desired computation using their specialized resources. This improved performance enables various forms of high-performance computing (HPC), but comes at a high cost in programmability.&lt;br/&gt;&lt;br/&gt;This research targets high-performance computing research using PC-based clusters for cost and scalability combined with accelerators for high performance. The Purdue Everest project encompasses several related efforts in achieving high performance, low power consumption, and high programmability for highly heterogeneous systems.  Acquiring a 30-node Gigabit Ethernet-based cluster of multicore PC-based workstations equipped with various accelerator boards (e.g., GPU, Cell, FPGA, Crypto) will enable research into effective and highly-programmable use of accelerator-based clusters. Supporting multiple accelerators per node allows applications to use different accelerator boards in different phases.  This cluster also allows fair apples-to-apples comparisons of different accelerators by keeping the other system factors constant. This research also investigates the use of multiple concurrency domains, with parallelism across the cluster, across the cores in a single node, among the host processors and accelerators in a single node, and across the processing elements of a given accelerator.</AbstractNarration>
<MinAmdLetterDate>03/26/2008</MinAmdLetterDate>
<MaxAmdLetterDate>03/31/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0751153</AwardID>
<Investigator>
<FirstName>Rudolf</FirstName>
<LastName>Eigenmann</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Rudolf Eigenmann</PI_FULL_NAME>
<EmailAddress>eigenman@udel.edu</EmailAddress>
<PI_PHON>3028310678</PI_PHON>
<NSF_ID>000315744</NSF_ID>
<StartDate>03/26/2008</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Y. Charlie</FirstName>
<LastName>Hu</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Y. Charlie Hu</PI_FULL_NAME>
<EmailAddress>ychu@purdue.edu</EmailAddress>
<PI_PHON>7654949143</PI_PHON>
<NSF_ID>000118830</NSF_ID>
<StartDate>03/26/2008</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Vijay</FirstName>
<LastName>Pai</LastName>
<PI_MID_INIT>S</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vijay S Pai</PI_FULL_NAME>
<EmailAddress>vpai@purdue.edu</EmailAddress>
<PI_PHON>7654966610</PI_PHON>
<NSF_ID>000184842</NSF_ID>
<StartDate>03/26/2008</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Mithuna</FirstName>
<LastName>Thottethodi</LastName>
<PI_MID_INIT>S</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Mithuna S Thottethodi</PI_FULL_NAME>
<EmailAddress>mithuna@purdue.edu</EmailAddress>
<PI_PHON>7654944600</PI_PHON>
<NSF_ID>000253970</NSF_ID>
<StartDate>03/26/2008</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Vijay</FirstName>
<LastName>Raghunathan</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Vijay Raghunathan</PI_FULL_NAME>
<EmailAddress>vr@purdue.edu</EmailAddress>
<PI_PHON>7654947392</PI_PHON>
<NSF_ID>000203148</NSF_ID>
<StartDate>03/26/2008</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Purdue University</Name>
<CityName>West Lafayette</CityName>
<ZipCode>479072114</ZipCode>
<PhoneNumber>7654941055</PhoneNumber>
<StreetAddress>Young Hall</StreetAddress>
<StreetAddress2><![CDATA[155 S Grant Street]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN04</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>072051394</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PURDUE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>072051394</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Purdue University]]></Name>
<CityName>West Lafayette</CityName>
<StateCode>IN</StateCode>
<ZipCode>479072114</ZipCode>
<StreetAddress><![CDATA[Young Hall]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>04</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN04</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7359</Code>
<Text>CCRI-CISE Cmnty Rsrch Infrstrc</Text>
</ProgramElement>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2008~492268</FUND_OBLG>
<FUND_OBLG>2009~38012</FUND_OBLG>
<FUND_OBLG>2010~39586</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><br /> Automatic compiler techniques have been developed that fit large-data  computations into limited memory sizes on GPUs/accelerator devices. The  techniques use pipelining methods to overlap computation on the device  with the communication needed to move data to and from the devices. In  doing so, computations could be run on GPUs that previously had failed  due to insufficient memory and significant speedups were achieved as a  result of the new pipelining methods.</p> <pre>A key challenge faced by users of public clouds today is how to request for the right amount of resources in the production datacenter that satisfies a target performance for a given cloud application. An obvious approach is to develop a performance model for a class of applications such as MapReduce.  However, several recent studies have shown that even for the class of well-studied MapReduce jobs, their running times can be seriously affected by numerous external factors ranging from dozen or so configuration parameters, to the physical machine characteristics (CPU, memory, disk, and network bandwidth), to implementation deficiencies such as Java, garbage collection.  These factors make direct performance modeling extremely difficult. In this study, we proposed a more practical systematic methodology to solve this problem.  In particular, we developed a projection model that can prescribe the right amount of resources for MapReduce jobs to meet a given job completion time. The model is based on insights into performance bottlenecks of MapReduce jobs and their scaling properties, and parameterized with component running times based on profiling on small clusters with sampled inputs.  Using the CAP testbed, we developed the projection model. We then evaluated its effectiveness using a wide variety of MapReduce benchmarks running on CAP.  Our evaluation results show our projection model can predict job running times with 2.7\% of accuracy when scaling to 32 nodes on the CAP testbed.  CAP turns out to be valuable for this project as our experience has confirmed that evalution on Amazon EC2 faced performanec unpredictability as different jobs would compete for the shared network resources; current Amazone EC2 does not provide network isolation.</pre><br> <p>            Last Modified: 06/11/2013<br>      Modified by: Vijay&nbsp;S&nbsp;Pai</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[   Automatic compiler techniques have been developed that fit large-data  computations into limited memory sizes on GPUs/accelerator devices. The  techniques use pipelining methods to overlap computation on the device  with the communication needed to move data to and from the devices. In  doing so, computations could be run on GPUs that previously had failed  due to insufficient memory and significant speedups were achieved as a  result of the new pipelining methods. A key challenge faced by users of public clouds today is how to request for the right amount of resources in the production datacenter that satisfies a target performance for a given cloud application. An obvious approach is to develop a performance model for a class of applications such as MapReduce.  However, several recent studies have shown that even for the class of well-studied MapReduce jobs, their running times can be seriously affected by numerous external factors ranging from dozen or so configuration parameters, to the physical machine characteristics (CPU, memory, disk, and network bandwidth), to implementation deficiencies such as Java, garbage collection.  These factors make direct performance modeling extremely difficult. In this study, we proposed a more practical systematic methodology to solve this problem.  In particular, we developed a projection model that can prescribe the right amount of resources for MapReduce jobs to meet a given job completion time. The model is based on insights into performance bottlenecks of MapReduce jobs and their scaling properties, and parameterized with component running times based on profiling on small clusters with sampled inputs.  Using the CAP testbed, we developed the projection model. We then evaluated its effectiveness using a wide variety of MapReduce benchmarks running on CAP.  Our evaluation results show our projection model can predict job running times with 2.7\% of accuracy when scaling to 32 nodes on the CAP testbed.  CAP turns out to be valuable for this project as our experience has confirmed that evalution on Amazon EC2 faced performanec unpredictability as different jobs would compete for the shared network resources; current Amazone EC2 does not provide network isolation.       Last Modified: 06/11/2013       Submitted by: Vijay S Pai]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
