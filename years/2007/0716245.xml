<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CT-ISG: Cross-Leveraging Cryptography with Learning Theory</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2007</AwardEffectiveDate>
<AwardExpirationDate>08/31/2011</AwardExpirationDate>
<AwardTotalIntnAmount>0.00</AwardTotalIntnAmount>
<AwardAmount>396236</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This research involves a detailed study of the connections between Cryptography and Computational Learning Theory.  Cryptography is about manipulating information in order to achieve confidentiality, integrity, privacy, etc., while learning theory is about efficiently extracting information from some unknown object.  Learning theory provides a rigorous basis for the practically important field of machine learning, and cryptography plays a similar role for the crucial area of computer security.  In this research the investigators work to obtain new cryptographic results based on the presumed hardness of various problems in computational learning theory, and work to obtain new learning results via cryptography, thus extending and deepening the current understanding of both areas and the connections between them.  The research is integrated with a plan to achieve broader impact through education by developing an advanced course on the connections between cryptography and learning theory at Columbia University and advising and guiding a diverse group of graduate students in their development as researchers and educators.&lt;br/&gt;&lt;br/&gt;In more detail, the research involves (i) constructing and applying new cryptographic primitives, such as public-key cryptosystems and pseudorandom generators with very low circuit complexity, from learning problems that are widely believed to be hard; (ii) continuing ongoing work on exploring the average-case learnability of various well-studied concept classes such as decision trees and DNF formulas; (iii) applying computational hardness of learning to establishing computational hardness of learning for various Boolean function classes, using tools from cryptography; (v) working to obtain computational separations between pairs of well-studied learning models by showing that learning problems that have polynomial-time algorithms in one model are intractable (under a cryptographic assumption) in the other model; and (vi) exploring the foundational issue of what are the minimal assumptions required to prove computational hardness of learning.</AbstractNarration>
<MinAmdLetterDate>08/27/2007</MinAmdLetterDate>
<MaxAmdLetterDate>08/31/2010</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>0716245</AwardID>
<Investigator>
<FirstName>Rocco</FirstName>
<LastName>Servedio</LastName>
<PI_MID_INIT>A</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Rocco A Servedio</PI_FULL_NAME>
<EmailAddress>rocco@cs.columbia.edu</EmailAddress>
<PI_PHON>2129397065</PI_PHON>
<NSF_ID>000232661</NSF_ID>
<StartDate>08/27/2007</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Tal</FirstName>
<LastName>Malkin</LastName>
<PI_MID_INIT>G</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Tal G Malkin</PI_FULL_NAME>
<EmailAddress>tal@cs.columbia.edu</EmailAddress>
<PI_PHON>2128546851</PI_PHON>
<NSF_ID>000096938</NSF_ID>
<StartDate>08/27/2007</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Columbia University</Name>
<CityName>NEW YORK</CityName>
<ZipCode>100276902</ZipCode>
<PhoneNumber>2128546851</PhoneNumber>
<StreetAddress>2960 Broadway</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<StateCode>NY</StateCode>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NY10</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049179401</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049179401</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Columbia University]]></Name>
<CityName>NEW YORK</CityName>
<StateCode>NY</StateCode>
<ZipCode>100276902</ZipCode>
<StreetAddress><![CDATA[2960 Broadway]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New York</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>10</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NY10</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<FoaInformation>
<Code>0000912</Code>
<Name>Computer Science</Name>
</FoaInformation>
<ProgramElement>
<Code>7371</Code>
<Text>CYBER TRUST</Text>
</ProgramElement>
<ProgramElement>
<Code>7456</Code>
<Text>ITR-CYBERTRUST</Text>
</ProgramElement>
<ProgramElement>
<Code>7795</Code>
<Text>TRUSTWORTHY COMPUTING</Text>
</ProgramElement>
<ProgramElement>
<Code>7927</Code>
<Text>COMPLEXITY &amp; CRYPTOGRAPHY</Text>
</ProgramElement>
<ProgramReference>
<Code>9218</Code>
<Text>BASIC RESEARCH &amp; HUMAN RESORCS</Text>
</ProgramReference>
<ProgramReference>
<Code>HPCC</Code>
<Text>HIGH PERFORMANCE COMPUTING &amp; COMM</Text>
</ProgramReference>
<Appropriation>
<Code>0107</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>490100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0108</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0109</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0110</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2007~175000</FUND_OBLG>
<FUND_OBLG>2008~100000</FUND_OBLG>
<FUND_OBLG>2009~100000</FUND_OBLG>
<FUND_OBLG>2010~21236</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Our project addressed the interface between cryptography and learning<br />theory. Roughly speaking, cryptography is about manipulating and<br />encoding information so that it is difficult to reconstruct the original<br />information (for instance, so that sensitive information like a credit<br />card number can be sent securely over the Internet).&nbsp; Learning theory is<br />about efficiently extracting information from an unknown object (such as<br />learning a underlying prediction rule that explains a large data set).<br />So learning theory and cryptography can be viewed as "two sides of the<br />same coin" -- if a scheme for processing information is<br />cryptographically secure then it is hard to learn the underlying<br />information, while on the other hand any time we have an efficient<br />learning algorithm it means that there is a provable violation of<br />cryptographic security.<br /><br />One of our major research findings was establishing a new connection<br />between cryptography and learnability for an important class of<br />functions that are widely studied in computer science, called "monotone<br />functions". A monotone function is one for which the output of the<br />function always increases whenever the input to the function increases.<br />So for example, the function f(x) = x^2 - 4x + 4 is not monotone<br />(because increasing the input from 1 to 2 causes the output of the<br />function to go from 1 to 0), but the function f(x) = 3x + 4 is monotone<br />(because increasing x always causes f(x) to increase).&nbsp; It's clear that<br />if a function is monotone then it is at least a little bit predictable,<br />since we know that increasing the input to such a function can only cause the<br />function to increase and never to decrease.&nbsp; But how much help does<br />monotonicity really give us if we are trying to learn an unknown function<br />to high accuracy?&nbsp; Are monotone functions always easy to learn?<br /><br />This is an important question because many real-world phenomena that<br />scientists are interested in modelling correspond to monotone functions.<br />For example, the probability of developing a disease might plausibly be<br />a monotone function of exposure to various environmental toxins (more<br />exposure means a higher likelihood of developing the disease), but we<br />don't know the precise nature of this relationship.&nbsp; If we had efficient<br />and general ways to learn relationships like this which correspond to<br />monotone functions, it could be a very useful tool.<br /><br />Versions of this question have been studied for quite a while in<br />learning theory, and preliminary evidence before our work suggested that<br />monotone functions might be much easier to learn than nonmonotone<br />functions.&nbsp; We used tools from cryptography to show that in fact, for<br />many learning problems monotonicity is not very helpful if we want to<br />learn an unknown function to high accuracy.&nbsp; To put it another way,<br />while monotoncity does provide a certain "weak" form of predictability<br />(because increasing inputs always imply increasing outputs), there are<br />relatively simple monotone functions which are almost as hard to learn<br />to high accuracy as nonmonotone functions.<br /><br />While this particular finding of ours was "bad news" in terms of coming<br />up with efficient learning algorithms, there are some bright sides.&nbsp; For<br />one thing, knowing what we *can't* do is important for guiding research<br />efforts -- our findings may save future researchers from wasting time on<br />to develop efficient learning algorithms for problems which we now know<br />provably don't have such algorithms.&nbsp; Another positive aspect is that<br />with our new understanding of how monotone functions can be<br />"cryptographically hard", we or other researchers may be able to build<br />ne...]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Our project addressed the interface between cryptography and learning theory. Roughly speaking, cryptography is about manipulating and encoding information so that it is difficult to reconstruct the original information (for instance, so that sensitive information like a credit card number can be sent securely over the Internet).  Learning theory is about efficiently extracting information from an unknown object (such as learning a underlying prediction rule that explains a large data set). So learning theory and cryptography can be viewed as "two sides of the same coin" -- if a scheme for processing information is cryptographically secure then it is hard to learn the underlying information, while on the other hand any time we have an efficient learning algorithm it means that there is a provable violation of cryptographic security.  One of our major research findings was establishing a new connection between cryptography and learnability for an important class of functions that are widely studied in computer science, called "monotone functions". A monotone function is one for which the output of the function always increases whenever the input to the function increases. So for example, the function f(x) = x^2 - 4x + 4 is not monotone (because increasing the input from 1 to 2 causes the output of the function to go from 1 to 0), but the function f(x) = 3x + 4 is monotone (because increasing x always causes f(x) to increase).  It's clear that if a function is monotone then it is at least a little bit predictable, since we know that increasing the input to such a function can only cause the function to increase and never to decrease.  But how much help does monotonicity really give us if we are trying to learn an unknown function to high accuracy?  Are monotone functions always easy to learn?  This is an important question because many real-world phenomena that scientists are interested in modelling correspond to monotone functions. For example, the probability of developing a disease might plausibly be a monotone function of exposure to various environmental toxins (more exposure means a higher likelihood of developing the disease), but we don't know the precise nature of this relationship.  If we had efficient and general ways to learn relationships like this which correspond to monotone functions, it could be a very useful tool.  Versions of this question have been studied for quite a while in learning theory, and preliminary evidence before our work suggested that monotone functions might be much easier to learn than nonmonotone functions.  We used tools from cryptography to show that in fact, for many learning problems monotonicity is not very helpful if we want to learn an unknown function to high accuracy.  To put it another way, while monotoncity does provide a certain "weak" form of predictability (because increasing inputs always imply increasing outputs), there are relatively simple monotone functions which are almost as hard to learn to high accuracy as nonmonotone functions.  While this particular finding of ours was "bad news" in terms of coming up with efficient learning algorithms, there are some bright sides.  For one thing, knowing what we *can't* do is important for guiding research efforts -- our findings may save future researchers from wasting time on to develop efficient learning algorithms for problems which we now know provably don't have such algorithms.  Another positive aspect is that with our new understanding of how monotone functions can be "cryptographically hard", we or other researchers may be able to build new cryptographic schemes for securely encoding and communicating information using monotone functions.  Since monotone functions are often simpler or more efficient to compute than nonmonotone functions, this could lead to simpler, faster and better schemes for cryptographically secure communication in the future.       Last Modified: 02/23/2012       Submitted by: Rocco A Servedio]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
