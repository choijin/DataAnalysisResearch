<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Small: Language-level Control of Authority</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2015</AwardEffectiveDate>
<AwardExpirationDate>08/31/2018</AwardExpirationDate>
<AwardTotalIntnAmount>483230.00</AwardTotalIntnAmount>
<AwardAmount>483230</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Modern computer applications are typically made up of different software components that are created by, or may act on behalf of, mutually distrustful entities. To ensure the security of computer systems, it is important to restrict the ability of the components to perform actions within the computer system. The Principle of Least Authority states that a component should be given only the ability (or authority) it needs to perform its task, and no more. If this principle is followed, and a component is malicious or has errors, then the component is limited in the damage it can do to the computer system. However, existing techniques for building computer applications make it difficult to enforce the Principle of Least Authority.  This project aims to develop the foundational ideas and technology to specify, reason about, and restrict the authority of software components, in order to make it easier to follow the Principle of Least Authority, and thereby improve the security of computer systems. All software and tools developed during the project will be publicly released, and the project will engage graduate and undergraduate students with this research.&lt;br/&gt;&lt;br/&gt;The project will investigate and extend the theory of language-level control of authority, and will use this theory to provide practical tools and techniques to reason about and enforce application-specific authority control. There are three research directions that this project seeks to explore. First, develop a language-based framework for the design and implementation of authority control mechanisms. The framework will provide extensible and composable authority control mechanisms. Second, investigate the theory of language-based authorization mechanisms (including extensible authorization mechanisms). Third, investigate the interaction between authorization mechanisms and information-flow control in order to simplify enforcement of expressive and precise information security guarantees.   For the first two directions, the research approach is to: (1) develop formal language models that capture the essence of the mechanisms being investigated; (2) formally state desirable semantic properties of the models; (3) develop mechanisms that provably enforce the desirable semantic properties; (4) validate the models and mechanisms through prototype implementations. For the third research direction, the research approach is to extend the formal language models and prototype implementations with information-flow control mechanisms, and establish guarantees that authority control mechanisms can provide regarding information security.</AbstractNarration>
<MinAmdLetterDate>08/14/2015</MinAmdLetterDate>
<MaxAmdLetterDate>08/14/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1524052</AwardID>
<Investigator>
<FirstName>Stephen</FirstName>
<LastName>Chong</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephen Chong</PI_FULL_NAME>
<EmailAddress>chong@seas.harvard.edu</EmailAddress>
<PI_PHON>6174955501</PI_PHON>
<NSF_ID>000535045</NSF_ID>
<StartDate>08/14/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Harvard University</Name>
<CityName>Cambridge</CityName>
<ZipCode>021385369</ZipCode>
<PhoneNumber>6174955501</PhoneNumber>
<StreetAddress>1033 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[5th Floor]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>082359691</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>PRESIDENT AND FELLOWS OF HARVARD COLLEGE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001963263</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Harvard SEAS]]></Name>
<CityName>Cambridge</CityName>
<StateCode>MA</StateCode>
<ZipCode>021382933</ZipCode>
<StreetAddress><![CDATA[33 Oxford Street,  145 MD]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~483230</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Security requirements of software components vary greatly. To appropriately restrict the authority of components (and thus to meet these varying needs), programming languages need to provide authorization mechanisms. This helps apply the Principle of Least Authority, which states that a component should be given only the authority needed to perform its task and no more.</p> <p>However, existing languages provide little support for authorization mechanisms that can be adapted to meet an application&rsquo;s security needs, or for restricting and reasoning about authority of components within an application. To address this situation, it is necessary to understand the relationship of different authorization mechanisms to each other, including relative expressive power and compositional properties.</p> <p>This project investigated the use of programming language concepts and techniques to control authority in software components. We briefly summarize some of the key research accomplishments of this project.</p> <p>&nbsp;</p> <p>We introduced the concept of &ldquo;authorization contracts&rdquo;, an extension of software contracts to specify and restrict the authority of code. The key idea is that code executes in the context of an <em>authority environment</em>, which restricts what code is permitted to do. Sometimes code should execute with the authority of the entity that produced the code, other times it should execute with the authority of the entity that is executing the code. Authorization contracts provide a mechanism for programmers to easily and flexibly control the authority environment that code should execute under, and thus control what the code can do. We have implemented these contracts in the Racket programming language and used the framework to implement diverse access control mechanisms: discretionary access control, stack inspection, history&shy;based access control, and object&shy;capabilities.</p> <p>Due to our work investigating the implementation of authority contracts in the Racket programming language, we discovered a vulnerability in Typed Racket&rsquo;s sandboxing mechanism, allowing untrusted code to escape the sandbox. We developed a patch for the vulnerability, which was included in the Racket v6.9 release (April 2017).</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>We developed Clio, a system that uses cryptography to enforce confidentiality and integrity policies on untrusted storage, while shielding developers from the error-prone details of correctly using cryptography. We proved that Clio is secure with a novel proof technique composing cryptographic proof techniques with standard programming language techniques. We implemented a prototype version of Clio and used it on a case study to explore its practicality.</p> <p>&nbsp;</p> <p>Trusted Execution Environments (TEEs) are an emerging hardware mechanism that can provide low-level protection of data and computation. However, TEEs by themselves don&rsquo;t guarantee security of an application. We have developed DFLAC, a simple programming language that explores the combination of high-level programming language abstractions with TEEs. Specifically, DFLAC allows the programmer to express fine-grained authorization policies between security principals, and to express confidentiality and integrity requirements of a program. DFLAC ensures that when the program executes, it uses TEEs to securely execute the program and ensure that the confidentiality and integrity requirements. We have proven that DFLAC enforces a strong information security guarantee for confidentiality, and---due to the nature of TEEs---a weaker guarantee for integrity. DFLAC shows that high-level abstractions of information-flow and authorization may be an effective approach to program decentralized distributed applications that use TEEs.</p> <p>&nbsp;</p> <p>We have developed Flamio, a language that incorporates FLAM (an existing model of authorization) into a language with coarse-grained information flow control. FLAM enables reasoning at runtime about the trust relationships between security principals, and coarse-grained information-flow control allows simple dynamic tracking of sensitive information in a system. Combining the two enables flexible expressive computer systems with strong information security guarantees. Our implementation of Flamio provides evidence that coarse-grained information-flow techniques are a useful and practical mechanism to provide strong information security.</p> <p>&nbsp;</p> <p>We have also developed a coarse-grained information-flow control mechanism to track and control the flow of sensitive information in Java. We were able to adapt an existing open-source medical-records application to use our mechanism with relatively few modifications. This work is additional evidence that coarse-grained information-flow can be an effective and light-weight approach to achieve strong information security guarantees.</p><br> <p>            Last Modified: 11/28/2018<br>      Modified by: Stephen&nbsp;Chong</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Security requirements of software components vary greatly. To appropriately restrict the authority of components (and thus to meet these varying needs), programming languages need to provide authorization mechanisms. This helps apply the Principle of Least Authority, which states that a component should be given only the authority needed to perform its task and no more.  However, existing languages provide little support for authorization mechanisms that can be adapted to meet an application?s security needs, or for restricting and reasoning about authority of components within an application. To address this situation, it is necessary to understand the relationship of different authorization mechanisms to each other, including relative expressive power and compositional properties.  This project investigated the use of programming language concepts and techniques to control authority in software components. We briefly summarize some of the key research accomplishments of this project.     We introduced the concept of "authorization contracts", an extension of software contracts to specify and restrict the authority of code. The key idea is that code executes in the context of an authority environment, which restricts what code is permitted to do. Sometimes code should execute with the authority of the entity that produced the code, other times it should execute with the authority of the entity that is executing the code. Authorization contracts provide a mechanism for programmers to easily and flexibly control the authority environment that code should execute under, and thus control what the code can do. We have implemented these contracts in the Racket programming language and used the framework to implement diverse access control mechanisms: discretionary access control, stack inspection, history&shy;based access control, and object&shy;capabilities.  Due to our work investigating the implementation of authority contracts in the Racket programming language, we discovered a vulnerability in Typed Racket?s sandboxing mechanism, allowing untrusted code to escape the sandbox. We developed a patch for the vulnerability, which was included in the Racket v6.9 release (April 2017).        We developed Clio, a system that uses cryptography to enforce confidentiality and integrity policies on untrusted storage, while shielding developers from the error-prone details of correctly using cryptography. We proved that Clio is secure with a novel proof technique composing cryptographic proof techniques with standard programming language techniques. We implemented a prototype version of Clio and used it on a case study to explore its practicality.     Trusted Execution Environments (TEEs) are an emerging hardware mechanism that can provide low-level protection of data and computation. However, TEEs by themselves don?t guarantee security of an application. We have developed DFLAC, a simple programming language that explores the combination of high-level programming language abstractions with TEEs. Specifically, DFLAC allows the programmer to express fine-grained authorization policies between security principals, and to express confidentiality and integrity requirements of a program. DFLAC ensures that when the program executes, it uses TEEs to securely execute the program and ensure that the confidentiality and integrity requirements. We have proven that DFLAC enforces a strong information security guarantee for confidentiality, and---due to the nature of TEEs---a weaker guarantee for integrity. DFLAC shows that high-level abstractions of information-flow and authorization may be an effective approach to program decentralized distributed applications that use TEEs.     We have developed Flamio, a language that incorporates FLAM (an existing model of authorization) into a language with coarse-grained information flow control. FLAM enables reasoning at runtime about the trust relationships between security principals, and coarse-grained information-flow control allows simple dynamic tracking of sensitive information in a system. Combining the two enables flexible expressive computer systems with strong information security guarantees. Our implementation of Flamio provides evidence that coarse-grained information-flow techniques are a useful and practical mechanism to provide strong information security.     We have also developed a coarse-grained information-flow control mechanism to track and control the flow of sensitive information in Java. We were able to adapt an existing open-source medical-records application to use our mechanism with relatively few modifications. This work is additional evidence that coarse-grained information-flow can be an effective and light-weight approach to achieve strong information security guarantees.       Last Modified: 11/28/2018       Submitted by: Stephen Chong]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
