<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Compiler and Architectural Techniques for Soft Error Resilience</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/01/2015</AwardEffectiveDate>
<AwardExpirationDate>06/30/2018</AwardExpirationDate>
<AwardTotalIntnAmount>450000.00</AwardTotalIntnAmount>
<AwardAmount>466000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Almadena Chtchelkanova</SignBlockName>
<PO_EMAI>achtchel@nsf.gov</PO_EMAI>
<PO_PHON>7032927498</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Due to technology scaling, electronic circuits are becoming more susceptible to radiation-induced soft errors also known as transient faults. Soft errors may lead to application crash or even worse, silent data corruptions (SDC) that are not caught by the error detection logic but may cause the application to produce incorrect output. Another serious problem is the rise of detected unrecoverable errors (DUE) that often directly impact the reliability of any computer applications. The challenge is to achieve soft error resilience in a way that does not significantly increase the performance overhead, power consumption, and complexity of underlying hardware. To this end, this project designs and develops low-cost hardware/software cooperative techniques for soft error resilience. The resulting artifacts and technologies are expected to contribute to the nation's competitiveness by addressing the challenge of building reliable computing systems in the presence of soft errors.&lt;br/&gt;This research involves three intermediate research goals: design novel microarchitecture, that dynamically verifies the correctness of the processor core execution based on sensor-based soft error detection, to achieve soft error resilience at low cost; design a compiler that forms verifiable and recoverable regions in the presence of soft errors and provides relevant program analysis techniques; and design and develop compiler optimization and microarchitectural techniques that significantly reduce the verification overhead. This project will create tools and technologies for realization of soft error resilient computing systems, contributing fundamentally to the fault tolerance research community. Adoption of the resulting compiler and microarchitectural techniques will impact a broad range of any disciplines that need correct computation results thus requiring reliable computing systems, covering from mobile devices to high-performance large-scale computing systems. Consequently, use of the resulting technologies will make the execution of current and emerging applications much more reliable, and therefore directly affect our way of life.</AbstractNarration>
<MinAmdLetterDate>07/01/2015</MinAmdLetterDate>
<MaxAmdLetterDate>05/11/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1527463</AwardID>
<Investigator>
<FirstName>Changhee</FirstName>
<LastName>Jung</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Changhee Jung</PI_FULL_NAME>
<EmailAddress>chjung@purdue.edu</EmailAddress>
<PI_PHON>4047883821</PI_PHON>
<NSF_ID>000654054</NSF_ID>
<StartDate>07/01/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Dongyoon</FirstName>
<LastName>Lee</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Dongyoon Lee</PI_FULL_NAME>
<EmailAddress>dongyoon@cs.stonybrook.edu</EmailAddress>
<PI_PHON>6316321522</PI_PHON>
<NSF_ID>000678858</NSF_ID>
<StartDate>07/01/2015</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Virginia Polytechnic Institute and State University</Name>
<CityName>BLACKSBURG</CityName>
<ZipCode>240610001</ZipCode>
<PhoneNumber>5402315281</PhoneNumber>
<StreetAddress>Sponsored Programs 0170</StreetAddress>
<StreetAddress2><![CDATA[300 Turner Street NW, Suite 4200]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Virginia</StateName>
<StateCode>VA</StateCode>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>VA09</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>003137015</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>VIRGINIA POLYTECHNIC INSTITUTE AND STATE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>003137015</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Virginia Polytechnic Institute and State University]]></Name>
<CityName/>
<StateCode>VA</StateCode>
<ZipCode>240610001</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Virginia</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>VA09</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7942</Code>
<Text>HIGH-PERFORMANCE COMPUTING</Text>
</ProgramReference>
<ProgramReference>
<Code>9251</Code>
<Text>REU SUPP-Res Exp for Ugrd Supp</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~450000</FUND_OBLG>
<FUND_OBLG>2016~16000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><div class="page" title="Page 1">Due to technology scaling, circuits are becoming more susceptible toparticle-strike induced soft errors that may cause system crash or silent datacorruption (SDC). Our take on this is that the resilience must be achieved in anenergy-efficient way unlike traditional hardware approaches. To this end, wehave endeavored to design and implement compiler-directed soft error resiliencetechniques.<br />When physicists developed sensor based soft error detection, computer architectstook it as a key technol- ogy for SDC-freedom due to the ability to senseparticle strikes and proposed a coarse-grained hardware checkpointing forrecovery. However, since not all the strikes lead to soft errors, we believedthat a fine- grained recovery such as idempotent processing must be used totolerate the false positives. In fact, it was an open problem how to combinesensor-based detection and idempotence-based recovery with no detecteduncorrectable error (DUE). The crux of the problem is that the detection latency(sensing time) makes it pos- sible for soft errors to escape the idempotentregion where they occur. To prevent such DUEs by ensuring region-level errorcontainment, we created tail-DMR, a selective instruction duplication scheme.The compiler identifies the DUE-vulnerable instructions at the tail of eachidempotent region and duplicates them for in- stant error detection so thattheir errors are contained in the region. This research lays the groundwork forother compiler-directed error resilience schemes.<br />Later, we found out that the region-level error containment can be obviated byredefining the idempotent processing from the processor&rsquo;s point of view tocontain the errors within the core. The key idea is to regard the committedstores of each region as unverified, holding them in a gated store queue (GSQ)until they become error-free, i.e., no sensor raises the alarm during thedetection latency period after the boundary (end) of the region; a new logiccalled region boundary buffer (RBB) precisely gates/releases the GSQ by trackingthe end time of regions. That way the processor core never merges unverifiedstores to cache, and the recovery can be made by flushing the GSQ on error andrestarting from the most recently verified region boundary. That is, theregion-level error containment is relaxed to core-level containment! The upshotis that it requires neither extra error detection such as the tail-DMR norcomplex hardware modification as in prior work that replicatesmicroarchitectural components and modifies cache coherence protocols. Thisresearch has inspired the design and use of the GSQ-driven recovery fordifferent problem domains such as nonvolatile processors used in energyharvesting systems.<br />The irony of the original idempotent processing is that although it is to beused for lightweight soft error recovery, it requires expensive hardware support(e.g., 100% soft-error tolerant register file) and incurs significant executiontime overhead. Considering that soft errors rarely occur (e.g., &asymp; one per day),no one would be willing to adopt the idempotent processing for such rare errorcorrection at the cost of paying the significant performance overhead all day.To this end, we developed two effective compiler optimization techniques, i.e.,eager checkpointing and checkpoint pruning. To remove the need of the expensivehardware support, the compiler protects the register inputs of each idempotentregion during their entire liveness period by eagerly checkpointing the inputvalues right after they are defined.&nbsp; To minimize the checkpoint overhead, wecreated a novel program analysis that identifies and eliminates thosecheckpoints whose value can be safely reconstructed by other values of existingcheckpoints. The beauty of this approach is that it shifts the runtime overheadof the soft-error free execution to that of the error recovery execution withoutcompromising the recovery guarantee, thereby promoting the wide use ofidempotent processing!</div><br> <p>            Last Modified: 07/04/2018<br>      Modified by: Changhee&nbsp;Jung</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[Due to technology scaling, circuits are becoming more susceptible toparticle-strike induced soft errors that may cause system crash or silent datacorruption (SDC). Our take on this is that the resilience must be achieved in anenergy-efficient way unlike traditional hardware approaches. To this end, wehave endeavored to design and implement compiler-directed soft error resiliencetechniques. When physicists developed sensor based soft error detection, computer architectstook it as a key technol- ogy for SDC-freedom due to the ability to senseparticle strikes and proposed a coarse-grained hardware checkpointing forrecovery. However, since not all the strikes lead to soft errors, we believedthat a fine- grained recovery such as idempotent processing must be used totolerate the false positives. In fact, it was an open problem how to combinesensor-based detection and idempotence-based recovery with no detecteduncorrectable error (DUE). The crux of the problem is that the detection latency(sensing time) makes it pos- sible for soft errors to escape the idempotentregion where they occur. To prevent such DUEs by ensuring region-level errorcontainment, we created tail-DMR, a selective instruction duplication scheme.The compiler identifies the DUE-vulnerable instructions at the tail of eachidempotent region and duplicates them for in- stant error detection so thattheir errors are contained in the region. This research lays the groundwork forother compiler-directed error resilience schemes. Later, we found out that the region-level error containment can be obviated byredefining the idempotent processing from the processor?s point of view tocontain the errors within the core. The key idea is to regard the committedstores of each region as unverified, holding them in a gated store queue (GSQ)until they become error-free, i.e., no sensor raises the alarm during thedetection latency period after the boundary (end) of the region; a new logiccalled region boundary buffer (RBB) precisely gates/releases the GSQ by trackingthe end time of regions. That way the processor core never merges unverifiedstores to cache, and the recovery can be made by flushing the GSQ on error andrestarting from the most recently verified region boundary. That is, theregion-level error containment is relaxed to core-level containment! The upshotis that it requires neither extra error detection such as the tail-DMR norcomplex hardware modification as in prior work that replicatesmicroarchitectural components and modifies cache coherence protocols. Thisresearch has inspired the design and use of the GSQ-driven recovery fordifferent problem domains such as nonvolatile processors used in energyharvesting systems. The irony of the original idempotent processing is that although it is to beused for lightweight soft error recovery, it requires expensive hardware support(e.g., 100% soft-error tolerant register file) and incurs significant executiontime overhead. Considering that soft errors rarely occur (e.g., &asymp; one per day),no one would be willing to adopt the idempotent processing for such rare errorcorrection at the cost of paying the significant performance overhead all day.To this end, we developed two effective compiler optimization techniques, i.e.,eager checkpointing and checkpoint pruning. To remove the need of the expensivehardware support, the compiler protects the register inputs of each idempotentregion during their entire liveness period by eagerly checkpointing the inputvalues right after they are defined.  To minimize the checkpoint overhead, wecreated a novel program analysis that identifies and eliminates thosecheckpoints whose value can be safely reconstructed by other values of existingcheckpoints. The beauty of this approach is that it shifts the runtime overheadof the soft-error free execution to that of the error recovery execution withoutcompromising the recovery guarantee, thereby promoting the wide use ofidempotent processing!       Last Modified: 07/04/2018       Submitted by: Changhee Jung]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
