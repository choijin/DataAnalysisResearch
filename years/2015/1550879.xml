<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Collaborative Research:Concurrent Programming with Composable Transactional Objects</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>04/21/2015</AwardEffectiveDate>
<AwardExpirationDate>06/30/2017</AwardExpirationDate>
<AwardTotalIntnAmount>240853.00</AwardTotalIntnAmount>
<AwardAmount>240853</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>SHF: Small: Collaborative Research: Concurrent Programming with Composable Transactional Objects&lt;br/&gt;&lt;br/&gt;With multicore architectures becoming increasingly prevalent, the problem of constructing scalable and efficient concurrent software has attracted increasing attention.  There has been growing interest programming models that allow programmers to demarcate regions of thread code---so-called transactions---that should appear to occur atomically, when viewed from the perspective of other threads.&lt;br/&gt;&lt;br/&gt;The premise of this project is that current, monolithic software transactional memory (STM) designs are inherently too inefficient and permit too little parallelism.  Instead we propose a very different approach: a library of customized concurrent data structures that can be composed, through a very light-weight run-time, to form transactions.  Each data structure is optimized to exploit the semantics of its type.  The intellectual merits are the development of new type-specific synchronization and recovery algorithms, along with formal tools to reason about their correctness.  These ideas will be embodied in a novel concurrency library and verification toolkit, which will be used to construct benchmarks and applications.  The boarder impacts involve incorporating concurrency into education and the potential to benefit society through higher performing, more reliable, and less expensive software.</AbstractNarration>
<MinAmdLetterDate>07/15/2015</MinAmdLetterDate>
<MaxAmdLetterDate>07/15/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1550879</AwardID>
<Investigator>
<FirstName>Eric</FirstName>
<LastName>Koskinen</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Eric Koskinen</PI_FULL_NAME>
<EmailAddress>eric.koskinen@stevens.edu</EmailAddress>
<PI_PHON>2016691206</PI_PHON>
<NSF_ID>000608272</NSF_ID>
<StartDate>07/15/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Yale University</Name>
<CityName>New Haven</CityName>
<ZipCode>065208327</ZipCode>
<PhoneNumber>2037854689</PhoneNumber>
<StreetAddress>Office of Sponsored Projects</StreetAddress>
<StreetAddress2><![CDATA[P.O. Box 208327]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Connecticut</StateName>
<StateCode>CT</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CT03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>043207562</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>YALE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>043207562</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Yale University]]></Name>
<CityName/>
<StateCode>CT</StateCode>
<ZipCode>065103209</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Connecticut</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CT03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0114</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2014~240853</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span>With multicore architectures becoming increasingly prevalent, the problem of constructing scalable and efficient concurrent software has attracted increasing attention. There has been growing interest programming models that allow programmers to demarcate regions of thread code---so-called transactions---that should appear to occur atomically, when viewed from the perspective of other threads.</span><br /><br /><span>The premise of this project was that current, monolithic software transactional memory (STM) designs were inherently too inefficient and permit too little parallelism. We instead took a very different approach: a library of customized concurrent data structures that can be composed, through a very light-weight run-time, to form transactions. Each data structure is optimized to exploit the semantics of its type.</span><br /><br /><span>The key outcomes of this project were:</span></p> <ul> <li>We designed, implemented, and ran preliminary tests on the Proust transactional framework, a novel way to integrate libaries of transactional objects on top of a software transactional memory system.</li> <li>We developed a novel method for reasoning about the correctness of a wide range of transactional memory algorithms and implementations (published in PLDI 2015).</li> <li>We designed, implemented, and tested a novel application of transactional object libraries in the form of a proposal to add concurrent execution to "smart contracts" used by cryptocurrencies such as Ethereum. Experimental results (published in PODC 2017) show that the latency of executing and verifying smart contracts can be substantially reduced using our techniques.</li> <li>Our work on the Proust framework shows that one can substantially increase concurrency for selected data types using this framewor (described in a PODC 2017 brief announcement).</li> <li>We developed a novel form of synchronization called Corrective Synchronization, as opposed to optimistic &amp; pessimistic forms of synchronization. &nbsp;We developed, implemented, and tested novel methods that combine abstract interpretation with a dynamic runtime to automatically perform corrective synchronization. Our work (published in VMCAI 2017) showed that corrective synchronization can achieve better performance than optimistic or pessimistic synchronization under some workloads.</li> <li>Our work influenced and contributed to other research activities (e.g. published in PLDI 2014 and EC2 2015).</li> </ul> <p><span>Finally, the boarder impacts involved incorporating concurrency into education and the potential to benefit society through higher performing, more reliable, and less expensive software.</span></p><br> <p>            Last Modified: 09/14/2017<br>      Modified by: Eric&nbsp;Koskinen</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ With multicore architectures becoming increasingly prevalent, the problem of constructing scalable and efficient concurrent software has attracted increasing attention. There has been growing interest programming models that allow programmers to demarcate regions of thread code---so-called transactions---that should appear to occur atomically, when viewed from the perspective of other threads.  The premise of this project was that current, monolithic software transactional memory (STM) designs were inherently too inefficient and permit too little parallelism. We instead took a very different approach: a library of customized concurrent data structures that can be composed, through a very light-weight run-time, to form transactions. Each data structure is optimized to exploit the semantics of its type.  The key outcomes of this project were:  We designed, implemented, and ran preliminary tests on the Proust transactional framework, a novel way to integrate libaries of transactional objects on top of a software transactional memory system. We developed a novel method for reasoning about the correctness of a wide range of transactional memory algorithms and implementations (published in PLDI 2015). We designed, implemented, and tested a novel application of transactional object libraries in the form of a proposal to add concurrent execution to "smart contracts" used by cryptocurrencies such as Ethereum. Experimental results (published in PODC 2017) show that the latency of executing and verifying smart contracts can be substantially reduced using our techniques. Our work on the Proust framework shows that one can substantially increase concurrency for selected data types using this framewor (described in a PODC 2017 brief announcement). We developed a novel form of synchronization called Corrective Synchronization, as opposed to optimistic &amp; pessimistic forms of synchronization.  We developed, implemented, and tested novel methods that combine abstract interpretation with a dynamic runtime to automatically perform corrective synchronization. Our work (published in VMCAI 2017) showed that corrective synchronization can achieve better performance than optimistic or pessimistic synchronization under some workloads. Our work influenced and contributed to other research activities (e.g. published in PLDI 2014 and EC2 2015).   Finally, the boarder impacts involved incorporating concurrency into education and the potential to benefit society through higher performing, more reliable, and less expensive software.       Last Modified: 09/14/2017       Submitted by: Eric Koskinen]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
