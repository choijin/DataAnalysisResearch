<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Medium: Collaborative: New Protocols and Systems for RAM-Based Secure Computation</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>05/15/2016</AwardEffectiveDate>
<AwardExpirationDate>07/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>364769.00</AwardTotalIntnAmount>
<AwardAmount>364769</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Secure computation allows users to collaboratively compute any program on their private data, while ensuring that they learn nothing beyond the output of the computation. Existing protocols for secure computation primarily rely on a boolean-circuit representation for the program being evaluated, which can be highly inefficient. This project focuses on developing secure-computation protocols in the RAM model of computation. Particularly challenging here is the need to ensure that memory accesses are oblivious, and do not leak information about private data. We are designing efficient oblivious data structures that can be used as general-purpose building blocks for secure protocols in the RAM model of computation. &lt;br/&gt;&lt;br/&gt;This project develops a framework that enables programmers to write high-level code that can then be compiled by a back-end algorithm that analyzes the code and makes use of the oblivious data structures we provide. This work is influenced by the needs of real applications, and the techniques to analyze the exact requirements of the program will evaluated and to tailor the resulting protocol to those requirements. This project aims to develop tools making secure computation more accessible to non-specialists, so it can be more broadly used to perform computations on private data. The PIs on this project mentor both graduate and undergraduate students and actively encourage involvement of minority students. The project develops new course materials and interact with the broader community through involvement in the IEEE cybersecurity initiative and the Maryland Cybersecurity Council.</AbstractNarration>
<MinAmdLetterDate>05/17/2016</MinAmdLetterDate>
<MaxAmdLetterDate>04/11/2019</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1562888</AwardID>
<Investigator>
<FirstName>Ruzica</FirstName>
<LastName>Piskac</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ruzica Piskac</PI_FULL_NAME>
<EmailAddress>ruzica.piskac@yale.edu</EmailAddress>
<PI_PHON>2034328001</PI_PHON>
<NSF_ID>000655841</NSF_ID>
<StartDate>04/11/2019</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Ruzica</FirstName>
<LastName>Piskac</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Ruzica Piskac</PI_FULL_NAME>
<EmailAddress>ruzica.piskac@yale.edu</EmailAddress>
<PI_PHON>2034328001</PI_PHON>
<NSF_ID>000655841</NSF_ID>
<StartDate>12/21/2018</StartDate>
<EndDate>04/11/2019</EndDate>
<RoleCode>Former Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Mariana</FirstName>
<LastName>Raykova</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Mariana Raykova</PI_FULL_NAME>
<EmailAddress>mariana.raykova@yale.edu</EmailAddress>
<PI_PHON>2034321246</PI_PHON>
<NSF_ID>000656535</NSF_ID>
<StartDate>05/17/2016</StartDate>
<EndDate>04/11/2019</EndDate>
<RoleCode>Former Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Yale University</Name>
<CityName>New Haven</CityName>
<ZipCode>065208327</ZipCode>
<PhoneNumber>2037854689</PhoneNumber>
<StreetAddress>Office of Sponsored Projects</StreetAddress>
<StreetAddress2><![CDATA[P.O. Box 208327]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Connecticut</StateName>
<StateCode>CT</StateCode>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CT03</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>043207562</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>YALE UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>043207562</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Yale University]]></Name>
<CityName>New Haven</CityName>
<StateCode>CT</StateCode>
<ZipCode>065208285</ZipCode>
<StreetAddress><![CDATA[AKW, 51 Prospect Street]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Connecticut</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>03</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CT03</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>9102</Code>
<Text>WOMEN, MINORITY, DISABLED, NEC</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~364769</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">Secure computation protocols enable multiple distrusting parties, each with their own private input, to interact and perform some agreed upon computation, revealing nothing in the process beyond the result of that computation. Traditionally, protocols for secure computation are designed in the </span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: italic; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">circuit model</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">. One benefit of this approach is that circuits are stateless, which precludes the participants from learning something about the other user inputs through memory access patterns. Unfortunately, the reliance on a circuit representation is also limiting, as access to memory can provide algorithms that are asymptotically faster than circuit-based computation. Oblivious RAM protocols allow us to fix this problem, by providing a method for accessing memory obliviously -- that is, without revealing which location in memory has been fetched.&nbsp;&nbsp;</span></p> <p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">The use of ORAM in secure computation was relatively unexplored prior to our work in this project. The fact that it can be used generically had been observed twenty years ago, but since that time, researchers in the field have begun to optimize constructions of secure computation with an eye on concrete performance. The concrete performance of a generic approach to using Oblivious RAM inside a secure computation is prohibitively expensive.&nbsp;&nbsp;</span></p> <p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">In this project, we have explored several directions for improving the use of oblivious memory access in secure computation:&nbsp;</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">&nbsp;</span></p> <p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">Constructing new ORAM protocols</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">.&nbsp; ORAM was originally designed for a client/server model in which the client has storage constraints, but is allowed to see all data. In secure computation, all parties have similar storage constraints, but none may see the data. We designed new ORAM protocols for this setting, improving efficiency by leveraging the fact that the parties have linear storage. Additionally, our protocols are faster to instantiate than existing constructions in the client/server model. In this same direction, we have designed new oblivious data structures that have better memory locality, allowing the server to reduce the total number of physical memory accesses while preserving privacy.</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">&nbsp;</span></p> <p>&nbsp;</p> <p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">Constructing new languages</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">. We developed a new programming language, called L_obliv, for writing oblivious algorithms and data structures (including ORAM). We have proven that type-correct programs in L-obliv offer probabilistic obliviousness: no matter the values of secrets, the distribution of publicly observable traces is unaffected.&nbsp;</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">&nbsp;</span></p> <p>&nbsp;</p> <p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">Exploring other notions of data obliviousness.</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"> We have begun the investigation of alternatives to fully oblivious computation. Specifically, we have investigated a security definition that allows some leakage in the form of memory access patterns, but admits a proof that the leakage preserves differential privacy for the users that have contributed data.</span></p> <p>&nbsp;</p> <p><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: bold; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">Leveraging data oblivious computation in program analysis.</span><span style="font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;">&nbsp; We have explored methods for securely performing static analysis without revealing the details of the program. This allows us to formally verify properties of the given code while maintaining privacy.&nbsp; </span></p><br> <p>            Last Modified: 02/14/2021<br>      Modified by: Ruzica&nbsp;Piskac</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Secure computation protocols enable multiple distrusting parties, each with their own private input, to interact and perform some agreed upon computation, revealing nothing in the process beyond the result of that computation. Traditionally, protocols for secure computation are designed in the circuit model. One benefit of this approach is that circuits are stateless, which precludes the participants from learning something about the other user inputs through memory access patterns. Unfortunately, the reliance on a circuit representation is also limiting, as access to memory can provide algorithms that are asymptotically faster than circuit-based computation. Oblivious RAM protocols allow us to fix this problem, by providing a method for accessing memory obliviously -- that is, without revealing which location in memory has been fetched.    The use of ORAM in secure computation was relatively unexplored prior to our work in this project. The fact that it can be used generically had been observed twenty years ago, but since that time, researchers in the field have begun to optimize constructions of secure computation with an eye on concrete performance. The concrete performance of a generic approach to using Oblivious RAM inside a secure computation is prohibitively expensive.    In this project, we have explored several directions for improving the use of oblivious memory access in secure computation:    Constructing new ORAM protocols.  ORAM was originally designed for a client/server model in which the client has storage constraints, but is allowed to see all data. In secure computation, all parties have similar storage constraints, but none may see the data. We designed new ORAM protocols for this setting, improving efficiency by leveraging the fact that the parties have linear storage. Additionally, our protocols are faster to instantiate than existing constructions in the client/server model. In this same direction, we have designed new oblivious data structures that have better memory locality, allowing the server to reduce the total number of physical memory accesses while preserving privacy.      Constructing new languages. We developed a new programming language, called L_obliv, for writing oblivious algorithms and data structures (including ORAM). We have proven that type-correct programs in L-obliv offer probabilistic obliviousness: no matter the values of secrets, the distribution of publicly observable traces is unaffected.       Exploring other notions of data obliviousness. We have begun the investigation of alternatives to fully oblivious computation. Specifically, we have investigated a security definition that allows some leakage in the form of memory access patterns, but admits a proof that the leakage preserves differential privacy for the users that have contributed data.     Leveraging data oblivious computation in program analysis.  We have explored methods for securely performing static analysis without revealing the details of the program. This allows us to formally verify properties of the given code while maintaining privacy.         Last Modified: 02/14/2021       Submitted by: Ruzica Piskac]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
