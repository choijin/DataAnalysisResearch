<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>TWC: Small: Confidentiality Measurement of Complex Computations using Quantitative Information Flow</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2015</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>495695.00</AwardTotalIntnAmount>
<AwardAmount>495695</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Concern about information privacy is a major obstacle to user adoption of new information technology applications, from smart phone applications to the deployment of automated workflows in the largest health-care and government enterprises. This project addresses privacy concerns caused by software through errors and malicious attacks.   A major security concern about software revolves around whether computers reveal information that they should not. Much of the information we entrust to computers might be described as secret, private, or confidential, because we want to limit who has access to it. However many things can go wrong in computer systems to allow information to be revealed when it should not. In this project the focus is on the information that is present in the results of a computation. A computation might take information from several sources and combine it in a complex way to produce output. These outputs are usually not in a format that can easily be read directly by people, thus the output from a computation may be undesirably "leaking" information without our knowledge. The project tackles this problem using techniques called quantitative information flow analysis, which allow one computer program to automatically determine how much information another computer program is revealing. For instance, such an analysis system might report that one program always reveals 4 bits of secret information, while another program revealed 1000 bits of secret information in its most recent execution. By comparing these measurements to the expected behavior of a program, one can detect situations that might be causing a program to reveal information that it should not. Previous quantitative information flow analysis systems have demonstrated that the basic approach is sound, but they have been limited in the kinds and sizes of programs where they are effective, and they require guidance from software developers to obtain good results. This project will develop new techniques that eliminate these restrictions to make quantitative information flow analysis more widely applicable.  &lt;br/&gt;&lt;br/&gt;The quantitative information-flow techniques, which measure the number of bits of information about secret computation inputs that are revealed by computation outputs, give a measurement that can be evaluated separately without reference to the intended meaning of the computation results and without additional annotation or specification of the subject program.  By combining a quantitative analysis with techniques from taint analysis and symbolic execution, the tools can track in a precise way where secret information flows, and the connection between input values and output values. Quantitative information-flow measurement has not yet seen practical adoption because existing approaches have too high overhead, do not naturally support multiple kinds of secret data, are limited in the software to which they apply, and/or require occasional developer annotations. The project seeks to overcome the limitations of previous approaches by generalizing the underlying techniques and improving their precision, while at the same time improving their performance and applicability via staged optimizations and complete automation.  The research will demonstrate the approach by application to a number of realistic challenge problems in computer security and privacy.</AbstractNarration>
<MinAmdLetterDate>08/11/2015</MinAmdLetterDate>
<MaxAmdLetterDate>08/11/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1526319</AwardID>
<Investigator>
<FirstName>Stephen</FirstName>
<LastName>McCamant</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephen McCamant</PI_FULL_NAME>
<EmailAddress>mccamant@cs.umn.edu</EmailAddress>
<PI_PHON>6126267526</PI_PHON>
<NSF_ID>000630498</NSF_ID>
<StartDate>08/11/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Minnesota-Twin Cities</Name>
<CityName>Minneapolis</CityName>
<ZipCode>554552070</ZipCode>
<PhoneNumber>6126245599</PhoneNumber>
<StreetAddress>200 OAK ST SE</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Minnesota</StateName>
<StateCode>MN</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MN05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>555917996</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>REGENTS OF THE UNIVERSITY OF MINNESOTA</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>117178941</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Minnesota-Twin Cities]]></Name>
<CityName>Minneapolis</CityName>
<StateCode>MN</StateCode>
<ZipCode>554550167</ZipCode>
<StreetAddress><![CDATA[200 Union St. SE]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Minnesota</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MN05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>8060</Code>
<Text>Secure &amp;Trustworthy Cyberspace</Text>
</ProgramElement>
<ProgramReference>
<Code>7434</Code>
<Text>CNCI</Text>
</ProgramReference>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~495695</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>At a high level, much of what computer programs do consists of<br />storing, copying, and transforming information. Though information can<br />take many forms, we can define it abstractly as that which allows us<br />to distinguish between different possible situations, i.e. to answer<br />questions. We can also measure information: one "bit" of information<br />is the quantity of information that will allow one to answer one<br />yes-no question, if the yes and no answers are equally likely.<br /><br />A major security concern about software revolves around whether<br />computers reveal information that they should not. Much of the<br />information we use with computers might be described as "secret",<br />"private", or "confidential", because we want to limit who has access<br />to it. However many things can go wrong in computer systems to allow<br />information to be revealed when it should not.<br /><br />In this project we have focused in particular on the information that<br />is present in the results of a computation. A computation might take<br />information from several sources and combine it in a complex way to<br />produce output. These outputs are also often not in a format that can<br />easily be read directly by people, so it is far from obvious what<br />information they contain. Thus the output from a computation may be<br />undesirably "leaking" information without our knowledge.<br /><br />In this project we have tackled this problem using techniques called<br />quantitative information flow analysis, which allow one computer<br />program to automatically determine how much information another<br />computer program is revealing. For instance such an analysis system<br />might report that one program always reveals 4 bits of secret<br />information, while another program revealed 1000 bits of secret<br />information in its most recent execution. By comparing these<br />measurements to the expected behavior of a program, we can find<br />situations, for instance program bugs, which might be causing a<br />program to reveal information that it should not.<br /><br />In this project we have developed new algorithms for quantitative<br />information flow analysis, including ones based on logical formula<br />representations of program behaviors. The information flow problem is<br />related to counting the number of solutions of these formulas, but<br />enumerating solutions one by one would be too slow even for a<br />computer. Instead our algorithms construct queries (mathematical<br />questions) whose answers reveal partial information about the solution<br />count, and the results of those queries guide the selection of the<br />next query. Some of the basic principles of this approach are<br />illustrated in an accompanying figure. The green curve that looks like<br />a lopsided bell curve represents the uncertainty about the information<br />flow as a probability distribution. The probability distribution is<br />represented in the computer by a set of points called a particle<br />filter (blue circles) that are sampled from the distribution, so that<br />there are more points closer to the correct answer. The algorithm uses<br />this representation to select a new query. The query has a fixed set<br />of outcomes, analogous to the measuring marks on a ruler.<br /><br />Quantitative information flow analysis systems potentially allow both<br />software developers and software users to better understand whether<br />programs satisfy the information security properties that they desire:<br />users can refrain from using insecure software until developers fix<br />it. This project has supported the professional development of<br />graduate students who have disseminated our research results at<br />international conferences, and the major tools we have developed are<br />publicly available under open-source licenses.<br /><br /><br /></p><br> <p>            Last Modified: 05/18/2020<br>      Modified by: Stephen&nbsp;Mccamant</p> </div> <div class="porSideCol"> <div class="each-gallery"> <div class="galContent" id="gallery0"> <div class="photoCount" id="photoCount0">          Image         </div> <div class="galControls onePhoto" id="controls0"></div> <div class="galSlideshow" id="slideshow0"></div> <div class="galEmbox" id="embox"> <div class="image-title"></div> </div> </div> <div class="galNavigation onePhoto" id="navigation0"> <ul class="thumbs" id="thumbs0"> <li> <a href="/por/images/Reports/POR/2020/1526319/1526319_10386251_1589831475115_distrib-round5.svg--rgov-214x142.jpg" original="/por/images/Reports/POR/2020/1526319/1526319_10386251_1589831475115_distrib-round5.svg--rgov-800width.jpg" title="Graph illustrating information-flow analysis"><img src="/por/images/Reports/POR/2020/1526319/1526319_10386251_1589831475115_distrib-round5.svg--rgov-66x44.jpg" alt="Graph illustrating information-flow analysis"></a> <div class="imageCaptionContainer"> <div class="imageCaption">One approach to information flow analysis works by refining an incomplete estimate with multiple queries.</div> <div class="imageCredit">Seonmo Kim and Stephen McCamant</div> <div class="imagePermisssions">Copyrighted</div> <div class="imageSubmitted">Stephen&nbsp;Mccamant</div> <div class="imageTitle">Graph illustrating information-flow analysis</div> </div> </li> </ul> </div> </div> </div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ At a high level, much of what computer programs do consists of storing, copying, and transforming information. Though information can take many forms, we can define it abstractly as that which allows us to distinguish between different possible situations, i.e. to answer questions. We can also measure information: one "bit" of information is the quantity of information that will allow one to answer one yes-no question, if the yes and no answers are equally likely.  A major security concern about software revolves around whether computers reveal information that they should not. Much of the information we use with computers might be described as "secret", "private", or "confidential", because we want to limit who has access to it. However many things can go wrong in computer systems to allow information to be revealed when it should not.  In this project we have focused in particular on the information that is present in the results of a computation. A computation might take information from several sources and combine it in a complex way to produce output. These outputs are also often not in a format that can easily be read directly by people, so it is far from obvious what information they contain. Thus the output from a computation may be undesirably "leaking" information without our knowledge.  In this project we have tackled this problem using techniques called quantitative information flow analysis, which allow one computer program to automatically determine how much information another computer program is revealing. For instance such an analysis system might report that one program always reveals 4 bits of secret information, while another program revealed 1000 bits of secret information in its most recent execution. By comparing these measurements to the expected behavior of a program, we can find situations, for instance program bugs, which might be causing a program to reveal information that it should not.  In this project we have developed new algorithms for quantitative information flow analysis, including ones based on logical formula representations of program behaviors. The information flow problem is related to counting the number of solutions of these formulas, but enumerating solutions one by one would be too slow even for a computer. Instead our algorithms construct queries (mathematical questions) whose answers reveal partial information about the solution count, and the results of those queries guide the selection of the next query. Some of the basic principles of this approach are illustrated in an accompanying figure. The green curve that looks like a lopsided bell curve represents the uncertainty about the information flow as a probability distribution. The probability distribution is represented in the computer by a set of points called a particle filter (blue circles) that are sampled from the distribution, so that there are more points closer to the correct answer. The algorithm uses this representation to select a new query. The query has a fixed set of outcomes, analogous to the measuring marks on a ruler.  Quantitative information flow analysis systems potentially allow both software developers and software users to better understand whether programs satisfy the information security properties that they desire: users can refrain from using insecure software until developers fix it. This project has supported the professional development of graduate students who have disseminated our research results at international conferences, and the major tools we have developed are publicly available under open-source licenses.          Last Modified: 05/18/2020       Submitted by: Stephen Mccamant]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
