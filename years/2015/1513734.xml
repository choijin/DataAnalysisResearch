<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>NeTS: Medium: Collaborative Research: DEFIND: DEclarative Formal Interative Network Design</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2015</AwardEffectiveDate>
<AwardExpirationDate>09/30/2021</AwardExpirationDate>
<AwardTotalIntnAmount>399999.00</AwardTotalIntnAmount>
<AwardAmount>399999</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Darleen Fisher</SignBlockName>
<PO_EMAI>dlfisher@nsf.gov</PO_EMAI>
<PO_PHON>7032928950</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Networks are complex systems that unfortunately are ridden with errors, which may lead to disruption of services with grave consequences. One approach to eliminating errors is to construct a formal model of the network and verify the correctness properties. However, extracting models from existing networks is often beyond what network operators can do.  To lower the complexity of network design and verification, an alternative approach is to use high-level abstract domain specific languages (DSLs) to define networks. For instance, in the context of Software Defined Networks (SDN), researchers have developed Frenetic, Pyretic, NetKAT network programming languages.  These DSLs are often backed by formal semantics, which provide some correctness guarantees of programs (networks) written in them.  However, DSLs have yet to make inroads into practical network deployments.  One key barrier to adoption is that these languages tend to be used in silos, decoupled from the process of designing, implementing, and deploying the networks.  To address these challenges, this research proposes DEFIND, a platform that enables iterative network design and unifies the entire toolchain of specifying, implementing, deploying, verifying and debugging networks.&lt;br/&gt;&lt;br/&gt;The proposed research includes the following three tightly connected tasks that comprise DEFIND. All three tasks use the Network Datalog declarative networking language, as the unified intermediary language. The first research task develops static analysis techniques to analyze the correctness properties of network protocols. When properties do not hold, DEFIND provides meaningful feedback to aid program debugging.  The second research task leverages dynamic provenance tracking to generate counter-examples and suggest potential fixes when static analysis in the first research task cannot provide conclusive results.  The final task provides a new API for programming networks, whereby a network operator specifies the desired functionality of the network using example behavior. DEFIND aims to automatically generate network specifications from these examples. Results from the first two tasks are applied to refine examples and generate correct network specifications.&lt;br/&gt;&lt;br/&gt;The broader impact of this proposal lies in the development of a unifying framework that combines both formal analysis and implementation of network protocols during design, analysis, and implementation phase. DEFIND aims to enable network operators, even if they are not trained in programming, to directly design and configure new network protocols. The PIs will co-teach a research seminar that investigates the application of formal methods and programming techniques in the domain of network protocol design.</AbstractNarration>
<MinAmdLetterDate>08/21/2015</MinAmdLetterDate>
<MaxAmdLetterDate>08/21/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1513734</AwardID>
<Investigator>
<FirstName>Wenchao</FirstName>
<LastName>Zhou</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Wenchao Zhou</PI_FULL_NAME>
<EmailAddress>wzhou@cs.georgetown.edu</EmailAddress>
<PI_PHON>2026874652</PI_PHON>
<NSF_ID>000636942</NSF_ID>
<StartDate>08/21/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Georgetown University</Name>
<CityName>Washington</CityName>
<ZipCode>200571789</ZipCode>
<PhoneNumber>2026250100</PhoneNumber>
<StreetAddress>37th &amp; O St N W</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>District of Columbia</StateName>
<StateCode>DC</StateCode>
<CONGRESSDISTRICT>00</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>DC00</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>049515844</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>GEORGETOWN UNIVERSITY (THE)</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>049515844</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Georgetown University]]></Name>
<CityName>Washington</CityName>
<StateCode>DC</StateCode>
<ZipCode>200571789</ZipCode>
<StreetAddress><![CDATA[37th and O St N W]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>District of Columbia</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>00</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>DC00</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7363</Code>
<Text>Networking Technology and Syst</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~399999</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The overall goal of the project is to develop a platform that enables iterative network design and unifies the entire toolchain of specifying, implementing, deploying, verifying and debugging networks. Within this overall goal, we have three key subgoals: (1) use of static analysis to reason about protocol correctness, (2) dynamic provenance tracking to identify errors that static analysis may not be able to find, and finally, (3) example driven network programming.</p> <p><strong>Subgoal 1. Static analysis of protocol correctness.</strong> To ensure the correctness of testing an ensemble of network policies, we propose a formal correctness definition for scheduling ensembles of tests. We develop an efficient algorithm that provably generates correct scheduling plans. Based on these formal foundations, we develop a test scheduling framework called Mikado. Mikado takes as input an ensemble of test traffic traces generated by various third-party tools. It then generates an efficient and correct schedule of the test traces. Mikado can reduce the end-to-end testing time by up to 90% and can schedule tests for thousands of network policies in large networks with 1000+ nodes within three minutes. This work was presented at NSDI 2018.</p> <p>To efficiently statically verify stateful networks, one has to carefully consider tradeoff between the expressiveness of the policy, the type of networks (models) to be verified, and the complexity of the verification problem. Our work NetSMC simplifies the network semantic model where only one network packet is processed by the network functions at a time. We evaluate NetSMC on a number of network policies and topologies and compared it against existing network verification tool VMN. Our custom verification tool is much more efficient than VMN, and than if we were to use SMT solvers as a black box. This work was presented at NSDI 2020.</p> <p><strong>Subgoal 2. Provenance-based tracking and analysis.</strong> We explore techniques to dynamically compress distributed provenance. Logically, the compression is achieved by grouping equivalent provenance graphs and maintaining only one concrete copy for each equivalence class. We statically analyze the programs of a target application to allow for quick detection of provenance equivalence at runtime. Our experimental results demonstrate that our distributed provenance compression technique leads to orders of magnitude storage reduction and noticeable query latency improvement over alternative approaches. This work was presented at SIGMOD 2017.</p> <p>We further introduce privacy-preserving network provenance (PPNP), a distributed provenance scheme that supports the richness of network provenance while providing strong privacy guarantees over confidential data. We propose a cryptographic approach to preserve the confidentiality of provenance (sub)graphs while allowing authorized nodes to query and access the parts that are visible to them. The PPNP scheme leverages a cryptographic primitive called Searchable Symmetric Encryption (SSE) and allows privacy-preserving retrieval of a labeled (sub)graphs of an encrypted graph. We formally analyze the proposed PPNP scheme and construct a proof-of-concept implementation which we call PrivProv. Our results demonstrate that PrivProv achieves strong confidentiality guarantees with a negligible increase in latency and low bandwidth overhead. This work was presented at VLDB 2017.</p> <p>We also consider the extension of provenance query capabilities to support more complex, for example, probabilistic data. We observe that, in many data-intensive applications, there has been a paradigm shift towards probabilistic and statistical reasoning. Probabilistic logic programming (PLP) languages are increasingly used to supporting developing these applications. We develop a prototype system called P3 (Provenance for Probabilistic logic Programs) for explaining and analyzing probabilistic computations. Our evaluation on several application scenarios (a visual question answering application and a mutual trust calculation in social networks) demonstrates that the system can support a wide-range of provenance queries that provides explanations for the results of learning tasks. This work was presented at EDBT 2020, and won the best paper award.</p> <p><strong>Subgoal 3. Example-driven programming. </strong>We explore the field of example-driven program synthesis. More specifically, we develop Facon, a new tool that enables us to automatically generate programs in arbitrary DSLs, based on input/output examples. Since input/output examples apply to any network protocols, this approach can be generalized, hence enabling us to migrate legacy networks to new DSLs, or to transform one DSL to another. Facon is successfully able to synthesize various software-defined networking controllers and distributed routing programs from example traces. Moreover, when given incomplete examples, Facon actively poses only a few additional queries to converge to the correct target program.</p> <p>&nbsp;</p><br> <p>            Last Modified: 06/24/2021<br>      Modified by: Wenchao&nbsp;Zhou</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ The overall goal of the project is to develop a platform that enables iterative network design and unifies the entire toolchain of specifying, implementing, deploying, verifying and debugging networks. Within this overall goal, we have three key subgoals: (1) use of static analysis to reason about protocol correctness, (2) dynamic provenance tracking to identify errors that static analysis may not be able to find, and finally, (3) example driven network programming.  Subgoal 1. Static analysis of protocol correctness. To ensure the correctness of testing an ensemble of network policies, we propose a formal correctness definition for scheduling ensembles of tests. We develop an efficient algorithm that provably generates correct scheduling plans. Based on these formal foundations, we develop a test scheduling framework called Mikado. Mikado takes as input an ensemble of test traffic traces generated by various third-party tools. It then generates an efficient and correct schedule of the test traces. Mikado can reduce the end-to-end testing time by up to 90% and can schedule tests for thousands of network policies in large networks with 1000+ nodes within three minutes. This work was presented at NSDI 2018.  To efficiently statically verify stateful networks, one has to carefully consider tradeoff between the expressiveness of the policy, the type of networks (models) to be verified, and the complexity of the verification problem. Our work NetSMC simplifies the network semantic model where only one network packet is processed by the network functions at a time. We evaluate NetSMC on a number of network policies and topologies and compared it against existing network verification tool VMN. Our custom verification tool is much more efficient than VMN, and than if we were to use SMT solvers as a black box. This work was presented at NSDI 2020.  Subgoal 2. Provenance-based tracking and analysis. We explore techniques to dynamically compress distributed provenance. Logically, the compression is achieved by grouping equivalent provenance graphs and maintaining only one concrete copy for each equivalence class. We statically analyze the programs of a target application to allow for quick detection of provenance equivalence at runtime. Our experimental results demonstrate that our distributed provenance compression technique leads to orders of magnitude storage reduction and noticeable query latency improvement over alternative approaches. This work was presented at SIGMOD 2017.  We further introduce privacy-preserving network provenance (PPNP), a distributed provenance scheme that supports the richness of network provenance while providing strong privacy guarantees over confidential data. We propose a cryptographic approach to preserve the confidentiality of provenance (sub)graphs while allowing authorized nodes to query and access the parts that are visible to them. The PPNP scheme leverages a cryptographic primitive called Searchable Symmetric Encryption (SSE) and allows privacy-preserving retrieval of a labeled (sub)graphs of an encrypted graph. We formally analyze the proposed PPNP scheme and construct a proof-of-concept implementation which we call PrivProv. Our results demonstrate that PrivProv achieves strong confidentiality guarantees with a negligible increase in latency and low bandwidth overhead. This work was presented at VLDB 2017.  We also consider the extension of provenance query capabilities to support more complex, for example, probabilistic data. We observe that, in many data-intensive applications, there has been a paradigm shift towards probabilistic and statistical reasoning. Probabilistic logic programming (PLP) languages are increasingly used to supporting developing these applications. We develop a prototype system called P3 (Provenance for Probabilistic logic Programs) for explaining and analyzing probabilistic computations. Our evaluation on several application scenarios (a visual question answering application and a mutual trust calculation in social networks) demonstrates that the system can support a wide-range of provenance queries that provides explanations for the results of learning tasks. This work was presented at EDBT 2020, and won the best paper award.  Subgoal 3. Example-driven programming. We explore the field of example-driven program synthesis. More specifically, we develop Facon, a new tool that enables us to automatically generate programs in arbitrary DSLs, based on input/output examples. Since input/output examples apply to any network protocols, this approach can be generalized, hence enabling us to migrate legacy networks to new DSLs, or to transform one DSL to another. Facon is successfully able to synthesize various software-defined networking controllers and distributed routing programs from example traces. Moreover, when given incomplete examples, Facon actively poses only a few additional queries to converge to the correct target program.          Last Modified: 06/24/2021       Submitted by: Wenchao Zhou]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
