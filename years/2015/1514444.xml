<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Medium: Dynamic Binary Translation for a Retargetable and Behaviorally-Accurate Cross-Architecture Whole System Virtual Machine</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2015</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>829165.00</AwardTotalIntnAmount>
<AwardAmount>829165</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This project focuses on improving the performance, applicability and reliability of whole system virtualization. Whole system virtualization is an approach that allows the complete set of software from one kind of computer to run as if it were a single program on a different kind of computer without any change at the binary (machine code) level. In particular, it allows software to migrate among different machines from different vendors with different system upgrades in large data centers, or between mobile devices and more powerful servers to allow better power management, system reliability and overall performance enhancement. Whole system virtualization is also important in other applications such as software development and system security.&lt;br/&gt;&lt;br/&gt;Dynamic binary translation is the key enabling technology studied in this project. With dynamic binary translation, machine instructions in their binary form from one machine are translated to instructions for another machine with a different instruction set architecture, so software can run seamlessly across different platforms on either real or virtual machines. The project will result in a prototype using the open-source software QEMU as its front-end and LLVM as its back-end in a client-server environment with ARM-based clients and Intel x86-based servers.  This prototype will provide a test bed to study several issues important to dynamic binary translation that supports whole system virtualization of multi-threaded codes on multi-core platforms.   &lt;br/&gt;&lt;br/&gt;This project addresses several technology challenges as it goes from research discovery toward application. The first is to improve the performance of the translated multi-threaded code and to reduce the overheads incurred during the binary translation, in particular in a client-server environment. It also addresses the challenges related to migrating binary codes across machines with different memory consistency models, and addresses challenges to verifying the correctness of the translated code. &lt;br/&gt;&lt;br/&gt;</AbstractNarration>
<MinAmdLetterDate>07/07/2015</MinAmdLetterDate>
<MaxAmdLetterDate>07/20/2017</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1514444</AwardID>
<Investigator>
<FirstName>Pen-Chung</FirstName>
<LastName>Yew</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Pen-Chung Yew</PI_FULL_NAME>
<EmailAddress>yew@cs.umn.edu</EmailAddress>
<PI_PHON>6126257387</PI_PHON>
<NSF_ID>000094289</NSF_ID>
<StartDate>07/07/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Antonia</FirstName>
<LastName>Zhai</LastName>
<PI_MID_INIT>B</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Antonia B Zhai</PI_FULL_NAME>
<EmailAddress>zhaix005@umn.edu</EmailAddress>
<PI_PHON>6126245599</PI_PHON>
<NSF_ID>000122966</NSF_ID>
<StartDate>07/07/2015</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Stephen</FirstName>
<LastName>McCamant</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Stephen McCamant</PI_FULL_NAME>
<EmailAddress>mccamant@cs.umn.edu</EmailAddress>
<PI_PHON>6126267526</PI_PHON>
<NSF_ID>000630498</NSF_ID>
<StartDate>07/07/2015</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Minnesota-Twin Cities</Name>
<CityName>Minneapolis</CityName>
<ZipCode>554552070</ZipCode>
<PhoneNumber>6126245599</PhoneNumber>
<StreetAddress>200 OAK ST SE</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Minnesota</StateName>
<StateCode>MN</StateCode>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MN05</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>555917996</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>REGENTS OF THE UNIVERSITY OF MINNESOTA</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>117178941</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Minnesota-Twin Cities]]></Name>
<CityName>Minneapolis</CityName>
<StateCode>MN</StateCode>
<ZipCode>554552070</ZipCode>
<StreetAddress><![CDATA[200 Union Street, SE]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Minnesota</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>05</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MN05</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0117</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~215624</FUND_OBLG>
<FUND_OBLG>2016~300480</FUND_OBLG>
<FUND_OBLG>2017~313061</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>We have developed a new learning-based approach to advance the state of the art for dynamic binary translation (DBT), which is one of the key enabling technologies in system virtualization.</p> <p>The new approach can automatically learn translation rules from training source programs to translate a sequence of binary instructions in one machine instruction set architecture (ISA), e.g. ARM, to a semantically- and behaviorally-equivalent instruction sequence of another machine instruction set architecture, e.g. Intel x86. This allows the machine binary code of one machine (e.g. ARM) to be run directly on another machine with a different ISA (e.g. Intel). With this technology, we can offload applications on mobile devices (usually with ARM processors) to more powerful servers (usually with Intel processors) at runtime, and improve mobile applications' performance as well as conserving mobile devices' battery power.</p> <p>It is a promising approach to scaling the development of DBT systems, reducing the development effort, and extending the translation rules that cover common multi-instruction idioms for better performance. It is also the first time that a learning-based approach is applied to the "translation" process of a compiler. We have built a research prototype based on QEMU that demonstrates the basic concept and the feasibility of such an approach. The experimental results show that such an approach can be easily incorporated in existing DBTs to produce higher-quality translated binary codes, and significantly reduce the effort in generating and applying the translation rules.</p> <p>As part of the verification process for such a learning-based approach, we have used symbolic execution to construct a formula describing the contents of the output locations (e.g., registers) of an instruction sequence in terms of the contents of the input locations. The verification system can then confirm the semantic equality, first by checking syntactic equivalence after standard simplifications, and then if needed, using an SMT solver. We find this approach has improved the assurance of the rule-based system and reduced the needed complexity in other phases. It has also supported our prototype in discovering many correct rules and producing high-quality translated codes.</p> <p>We have also explored several other applications of binary-level symbolic execution in support of the development and testing of instruction-level tools. As part of the effort in developing new binary-level coverage criteria, we have used symbolic execution to enumerate instructions and then represent the semantics of instructions to automatically determine which instructions with large ISAs (such as x86 or ARM) have met a definition relevant to including them in code coverage metrics. We have also developed techniques in binary-level symbolic execution for DBT systems (e.g., supporting dynamically-generated binary code), which supports more kinds of testing and verification of DBT tools.&nbsp; In an initial test of the concept, we have found that this approach can symbolically represent the semantics of the same x86 instruction as executed either by the Bochs emulator or the DBT-based QEMU system, confirming that the two implementations behaved the same for all inputs and without enumerating concrete tests.</p> <p>Techniques for assessing and improving the correctness of dynamic binary translation systems has covered three major directions: (1) accelerating the execution of instruction tests, (2) checking the correctness of learned translation rules, and (3) effective binary symbolic execution of DBT systems in support of development and testing. Previous systems had automatically generated tests for DBT-based and other CPU-level virtual machines, but a key limiting factor of many such previous systems was the time taken to execute the tests. To test portably and in isolation the behavior of an instruction that might have unknown side-effects, the safest approach is to execute that instruction in a freshly created VM image and then compare the resulting VM state. But, starting a VM and verifying its entire state are very expensive operations given the many test cases needed to cover a complex modern instruction set.&nbsp; We have developed techniques to combine a large number of individual instruction tests into a single VM image, accelerating test execution by 2-5 orders of magnitude in common cases when most tests pass. Some key techniques we have developed include reverting the expected side-effects of tested instructions, using CPU features to isolate disruptive instruction behaviors, and compacting the instruction outputs to reduce space usage. In particular, we have developed a new approach modeled after the Feistel network construction from cryptography, which allows previous test outputs to be incorporated in the generation of subsequent pseudo-random test inputs bijectively. We have demonstrated the effectiveness of all of our approaches in QEMU.</p> <p>We have also demonstrated that cross-ISA DBTs allow applications to be migrated to platforms that are more suitable for their execution in that scenario, for example, from a mobile device (e.g. an ARM-based mobile device) to an edge server (e.g. an Intel x86 server) to improve mobile applications' performance and conserve battery power of the mobile device.</p><br> <p>            Last Modified: 12/09/2019<br>      Modified by: Pen-Chung&nbsp;Yew</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ We have developed a new learning-based approach to advance the state of the art for dynamic binary translation (DBT), which is one of the key enabling technologies in system virtualization.  The new approach can automatically learn translation rules from training source programs to translate a sequence of binary instructions in one machine instruction set architecture (ISA), e.g. ARM, to a semantically- and behaviorally-equivalent instruction sequence of another machine instruction set architecture, e.g. Intel x86. This allows the machine binary code of one machine (e.g. ARM) to be run directly on another machine with a different ISA (e.g. Intel). With this technology, we can offload applications on mobile devices (usually with ARM processors) to more powerful servers (usually with Intel processors) at runtime, and improve mobile applications' performance as well as conserving mobile devices' battery power.  It is a promising approach to scaling the development of DBT systems, reducing the development effort, and extending the translation rules that cover common multi-instruction idioms for better performance. It is also the first time that a learning-based approach is applied to the "translation" process of a compiler. We have built a research prototype based on QEMU that demonstrates the basic concept and the feasibility of such an approach. The experimental results show that such an approach can be easily incorporated in existing DBTs to produce higher-quality translated binary codes, and significantly reduce the effort in generating and applying the translation rules.  As part of the verification process for such a learning-based approach, we have used symbolic execution to construct a formula describing the contents of the output locations (e.g., registers) of an instruction sequence in terms of the contents of the input locations. The verification system can then confirm the semantic equality, first by checking syntactic equivalence after standard simplifications, and then if needed, using an SMT solver. We find this approach has improved the assurance of the rule-based system and reduced the needed complexity in other phases. It has also supported our prototype in discovering many correct rules and producing high-quality translated codes.  We have also explored several other applications of binary-level symbolic execution in support of the development and testing of instruction-level tools. As part of the effort in developing new binary-level coverage criteria, we have used symbolic execution to enumerate instructions and then represent the semantics of instructions to automatically determine which instructions with large ISAs (such as x86 or ARM) have met a definition relevant to including them in code coverage metrics. We have also developed techniques in binary-level symbolic execution for DBT systems (e.g., supporting dynamically-generated binary code), which supports more kinds of testing and verification of DBT tools.  In an initial test of the concept, we have found that this approach can symbolically represent the semantics of the same x86 instruction as executed either by the Bochs emulator or the DBT-based QEMU system, confirming that the two implementations behaved the same for all inputs and without enumerating concrete tests.  Techniques for assessing and improving the correctness of dynamic binary translation systems has covered three major directions: (1) accelerating the execution of instruction tests, (2) checking the correctness of learned translation rules, and (3) effective binary symbolic execution of DBT systems in support of development and testing. Previous systems had automatically generated tests for DBT-based and other CPU-level virtual machines, but a key limiting factor of many such previous systems was the time taken to execute the tests. To test portably and in isolation the behavior of an instruction that might have unknown side-effects, the safest approach is to execute that instruction in a freshly created VM image and then compare the resulting VM state. But, starting a VM and verifying its entire state are very expensive operations given the many test cases needed to cover a complex modern instruction set.  We have developed techniques to combine a large number of individual instruction tests into a single VM image, accelerating test execution by 2-5 orders of magnitude in common cases when most tests pass. Some key techniques we have developed include reverting the expected side-effects of tested instructions, using CPU features to isolate disruptive instruction behaviors, and compacting the instruction outputs to reduce space usage. In particular, we have developed a new approach modeled after the Feistel network construction from cryptography, which allows previous test outputs to be incorporated in the generation of subsequent pseudo-random test inputs bijectively. We have demonstrated the effectiveness of all of our approaches in QEMU.  We have also demonstrated that cross-ISA DBTs allow applications to be migrated to platforms that are more suitable for their execution in that scenario, for example, from a mobile device (e.g. an ARM-based mobile device) to an edge server (e.g. an Intel x86 server) to improve mobile applications' performance and conserve battery power of the mobile device.       Last Modified: 12/09/2019       Submitted by: Pen-Chung Yew]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
