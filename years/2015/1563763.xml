<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>CSR: Medium: A High-Performance Certified File System and  Applications</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/01/2016</AwardEffectiveDate>
<AwardExpirationDate>05/31/2021</AwardExpirationDate>
<AwardTotalIntnAmount>900000.00</AwardTotalIntnAmount>
<AwardAmount>900000</AwardAmount>
<AwardInstrument>
<Value>Continuing Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Marilyn McClure</SignBlockName>
<PO_EMAI>mmcclure@nsf.gov</PO_EMAI>
<PO_PHON>7032925197</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Applications rely on file systems to store their data, but even carefully written applications and file systems may have bugs that cause data loss, especially in the face of system crashes (e.g., due to power failure).  Even in mature file systems such as ext4, bugs that can lead to data loss are not uncommon.  Application developers also misuse file-system APIs in ways that lead to user data being lost after a crash.&lt;br/&gt;&lt;br/&gt;Formal verification is a good way to prove the absence of bugs in a file system. By considering all possible operations and crashes, verification can ensure that the file system is bug-free.  The goal of this proposal is to develop a certified high-performance file system, VCFS (Verified Concurrent File System). The investigators aim to make VCFS's performance good enough to support demanding applications while guaranteeing crash safety.  VCFS and its applications will come with mathematical proofs that their implementations meet their specifications under any sequences of crashes.&lt;br/&gt;&lt;br/&gt;The main outcomes of this research will be as follows: (1) A logic system, CFSL (Concurrent File System Logic), that allows reasoning about parallelism and crashes. (2) A precise specification of the POSIX API under concurrency and crashes. (3) The VCFS file system, for which we will prove that its implementation meets our POSIX specification under crashes and concurrency. VCFS will include sophisticated performance optimizations. (4) A certified high-performance mail server, as a test case of using VCFS and its formally specified APIs to prove application-level properties (in this case, that the server will not lose acknowledged messages).&lt;br/&gt;&lt;br/&gt;CFSL will enable developers to reason about concurrency and crashes in the context of file systems.  The POSIX specification, along with VCFS, will help programmers develop applications that are both high-performance and safe under computer crashes.  The investigators will use their understanding of writing certified software to create a new class on certified software.</AbstractNarration>
<MinAmdLetterDate>04/22/2016</MinAmdLetterDate>
<MaxAmdLetterDate>05/31/2019</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1563763</AwardID>
<Investigator>
<FirstName>M. Frans</FirstName>
<LastName>Kaashoek</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>M. Frans Kaashoek</PI_FULL_NAME>
<EmailAddress>kaashoek@lcs.mit.edu</EmailAddress>
<PI_PHON>6172537149</PI_PHON>
<NSF_ID>000098539</NSF_ID>
<StartDate>04/22/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Robert</FirstName>
<LastName>Morris</LastName>
<PI_MID_INIT>T</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Robert T Morris</PI_FULL_NAME>
<EmailAddress>rtm@csail.mit.edu</EmailAddress>
<PI_PHON>6172535983</PI_PHON>
<NSF_ID>000471357</NSF_ID>
<StartDate>04/22/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Nickolai</FirstName>
<LastName>Zeldovich</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Nickolai Zeldovich</PI_FULL_NAME>
<EmailAddress>nickolai@csail.mit.edu</EmailAddress>
<PI_PHON>6172536005</PI_PHON>
<NSF_ID>000520788</NSF_ID>
<StartDate>04/22/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Adam</FirstName>
<LastName>Chlipala</LastName>
<PI_MID_INIT>J</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Adam J Chlipala</PI_FULL_NAME>
<EmailAddress>adamc@csail.mit.edu</EmailAddress>
<PI_PHON>6172531000</PI_PHON>
<NSF_ID>000610723</NSF_ID>
<StartDate>04/22/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Massachusetts Institute of Technology</Name>
<CityName>Cambridge</CityName>
<ZipCode>021394301</ZipCode>
<PhoneNumber>6172531000</PhoneNumber>
<StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
<StreetAddress2><![CDATA[NE18-901]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<StateCode>MA</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>MA07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>001425594</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>MASSACHUSETTS INSTITUTE OF TECHNOLOGY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>001425594</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Massachusetts Institute of Technology]]></Name>
<CityName/>
<StateCode>MA</StateCode>
<ZipCode>021394301</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Massachusetts</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>MA07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7354</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0118</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Appropriation>
<Code>0119</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~462543</FUND_OBLG>
<FUND_OBLG>2018~242232</FUND_OBLG>
<FUND_OBLG>2019~195225</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Applications rely on file systems to store their data, but even carefully written applications and file systems may have bugs that cause data loss, especially in the face of system crashes (e.g., due to power failure).&nbsp; Even in mature file systems such as Linux ext4, bugs that can lead to data loss are not uncommon.&nbsp; Application developers also misuse file-system APIs in ways that lead to user data being lost after a crash.</p> <p><br />Many of these bugs are subtle: the system works in most cases, but an inopportune combination of system calls and crashes can trigger a bug.&nbsp; A common approach for dealing with these bugs is to use bug-finding tools, model checking, testing, and so on to find bugs and then fix them.&nbsp; While these approaches are effective at finding some bugs, they cannot prove the absence of bugs in the resulting systems.</p> <p><br />Formal verification is a good way to prove the absence of bugs in a file system.&nbsp; By considering all possible operations and crashes, verification can ensure that the file system is bug-free.&nbsp; Our earlier work on FSCQ [Chen et al. 2015] shows that it is possible to build a certified system (i.e., one with a machine-checkable proof that its implementation meets its specification).&nbsp; However, there is large gap between FSCQ and a practical certified file system, owing to FSCQ's poor performance.</p> <p><br />This project explored several techniques to improve performance of storage systems, often requiring a new verification approach:</p> <p><br />- Performance: Delayed writes. DFSCQ extends FSCQ with delayed writes. DFSCQ provides a precise specification for fsync and fdatasync, which allow applications to achieve high performance and crash safety.&nbsp; DFSCQ's specification captures the behavior of sophisticated optimizations, including log-bypass writes, and DFSCQ's proof rules out some of the common bugs in file-system implementations despite the complex optimizations.&nbsp; An evaluation shows that DFSCQ achieves 103 MB/s on large file writes to an SSD and durably creates small files at a rate of 1,618 files per second.&nbsp; This is slower than Linux ext4 (which achieves 295 MB/s for large file writes and 4,977 files/s for small file creation) but much faster than two previous verified file systems, Yggdrasil and FSCQ.</p> <p><br />- Verification: layered recovery.&nbsp; Argosy is a framework for machine-checked proofs of storage systems that supports layered recovery implementations with modular proofs.&nbsp; Reasoning about layered recovery procedures is especially challenging because the system can crash in the middle of a more abstract layer's recovery procedure and must start over with the lowest-level recovery procedure.&nbsp; Argosy introduces recovery refinement, a set of conditions that ensure proper implementation of an interface with a recovery procedure. Argosy includes a proof that recovery refinements compose, using Kleene algebra for concise definitions and metatheory.&nbsp; We implemented Crash Hoare Logic, the program logic used by DFSCQ, to prove recovery refinement, and demonstrated the whole system by verifying an example of layered recovery featuring a write-ahead log running on top of a disk replication system.</p> <p><br />- Performance: From Haskell to Go. Due to the rigidity of Coq's extraction and the overhead of Haskell, the resulting code&rsquo;s CPU performance can suffer, with limited opportunity for optimization. To address this challenge, we built Goose, a subset of Go and a translator from that subset to a model in Perennial (see below) with supports for reasoning about Go threads, data structures, and file-system primitives.</p> <p><br />- Performance and verification: Concurrency with Perennial.&nbsp; Perennial is a framework for verifying concurrent, crash-safe systems.&nbsp; Perennial extends the Iris concurrency framework with three techniques to enable crash-safety reasoning: recovery leases, recovery helping, and versioned memory.&nbsp; We implemented and verified a crash-safe, concurrent mail server, Mailboat, using Perennial and Goose that achieves speedup on multiple cores.</p> <p><br />- Performance and verification: Concurrency with GoJournal and Perennial2.&nbsp; GoJournal is a verified, concurrent journaling system that provides atomicity for storage applications, together with Perennial 2.0, a framework for formally specifying and verifying concurrent crash-safe systems. GoJournal&rsquo;s goal is to bring the advantages of journaling for code to specs and proofs.&nbsp; Perennial 2.0 makes this possible by introducing several techniques to formalize GoJournal&rsquo;s specification and to manage the complexity in the proof of GoJournal&rsquo;s implementation. Lifting predicates and crash framing make the specification easy to use for developers, and logically atomic crash specifications allow for modular reasoning in GoJournal, making the proof tractable despite complex concurrency and crash interleavings.&nbsp; Performance experiments with an unverified NFS file system using GoJournal show similar performance (e.g., 90&ndash;95% throughput creating small files on an in-memory disk) to Linux&rsquo;s NFSserver exporting an ext4 file system, suggesting that GoJournal is a competitive journaling system.</p> <p><br />We incorporated ideas from this research in a new class on Principles of Computer Systems (https://6826.csail.mit.edu/2020/), which we taught several times during the lifetime of the project.</p><br> <p>            Last Modified: 07/01/2021<br>      Modified by: M. Frans&nbsp;Kaashoek</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Applications rely on file systems to store their data, but even carefully written applications and file systems may have bugs that cause data loss, especially in the face of system crashes (e.g., due to power failure).  Even in mature file systems such as Linux ext4, bugs that can lead to data loss are not uncommon.  Application developers also misuse file-system APIs in ways that lead to user data being lost after a crash.   Many of these bugs are subtle: the system works in most cases, but an inopportune combination of system calls and crashes can trigger a bug.  A common approach for dealing with these bugs is to use bug-finding tools, model checking, testing, and so on to find bugs and then fix them.  While these approaches are effective at finding some bugs, they cannot prove the absence of bugs in the resulting systems.   Formal verification is a good way to prove the absence of bugs in a file system.  By considering all possible operations and crashes, verification can ensure that the file system is bug-free.  Our earlier work on FSCQ [Chen et al. 2015] shows that it is possible to build a certified system (i.e., one with a machine-checkable proof that its implementation meets its specification).  However, there is large gap between FSCQ and a practical certified file system, owing to FSCQ's poor performance.   This project explored several techniques to improve performance of storage systems, often requiring a new verification approach:   - Performance: Delayed writes. DFSCQ extends FSCQ with delayed writes. DFSCQ provides a precise specification for fsync and fdatasync, which allow applications to achieve high performance and crash safety.  DFSCQ's specification captures the behavior of sophisticated optimizations, including log-bypass writes, and DFSCQ's proof rules out some of the common bugs in file-system implementations despite the complex optimizations.  An evaluation shows that DFSCQ achieves 103 MB/s on large file writes to an SSD and durably creates small files at a rate of 1,618 files per second.  This is slower than Linux ext4 (which achieves 295 MB/s for large file writes and 4,977 files/s for small file creation) but much faster than two previous verified file systems, Yggdrasil and FSCQ.   - Verification: layered recovery.  Argosy is a framework for machine-checked proofs of storage systems that supports layered recovery implementations with modular proofs.  Reasoning about layered recovery procedures is especially challenging because the system can crash in the middle of a more abstract layer's recovery procedure and must start over with the lowest-level recovery procedure.  Argosy introduces recovery refinement, a set of conditions that ensure proper implementation of an interface with a recovery procedure. Argosy includes a proof that recovery refinements compose, using Kleene algebra for concise definitions and metatheory.  We implemented Crash Hoare Logic, the program logic used by DFSCQ, to prove recovery refinement, and demonstrated the whole system by verifying an example of layered recovery featuring a write-ahead log running on top of a disk replication system.   - Performance: From Haskell to Go. Due to the rigidity of Coq's extraction and the overhead of Haskell, the resulting code’s CPU performance can suffer, with limited opportunity for optimization. To address this challenge, we built Goose, a subset of Go and a translator from that subset to a model in Perennial (see below) with supports for reasoning about Go threads, data structures, and file-system primitives.   - Performance and verification: Concurrency with Perennial.  Perennial is a framework for verifying concurrent, crash-safe systems.  Perennial extends the Iris concurrency framework with three techniques to enable crash-safety reasoning: recovery leases, recovery helping, and versioned memory.  We implemented and verified a crash-safe, concurrent mail server, Mailboat, using Perennial and Goose that achieves speedup on multiple cores.   - Performance and verification: Concurrency with GoJournal and Perennial2.  GoJournal is a verified, concurrent journaling system that provides atomicity for storage applications, together with Perennial 2.0, a framework for formally specifying and verifying concurrent crash-safe systems. GoJournal’s goal is to bring the advantages of journaling for code to specs and proofs.  Perennial 2.0 makes this possible by introducing several techniques to formalize GoJournal’s specification and to manage the complexity in the proof of GoJournal’s implementation. Lifting predicates and crash framing make the specification easy to use for developers, and logically atomic crash specifications allow for modular reasoning in GoJournal, making the proof tractable despite complex concurrency and crash interleavings.  Performance experiments with an unverified NFS file system using GoJournal show similar performance (e.g., 90&ndash;95% throughput creating small files on an in-memory disk) to Linux’s NFSserver exporting an ext4 file system, suggesting that GoJournal is a competitive journaling system.   We incorporated ideas from this research in a new class on Principles of Computer Systems (https://6826.csail.mit.edu/2020/), which we taught several times during the lifetime of the project.       Last Modified: 07/01/2021       Submitted by: M. Frans Kaashoek]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
