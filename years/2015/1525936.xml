<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF:  Small:   Driving Learning for Program Verification</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2015</AwardEffectiveDate>
<AwardExpirationDate>08/31/2019</AwardExpirationDate>
<AwardTotalIntnAmount>463706.00</AwardTotalIntnAmount>
<AwardAmount>463706</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Program verification has broad applications, from ensuring safety of mission-critical software to improving program robustness and programmer productivity. Automatic program verification techniques employ various forms of learning to enhance scalability on large programs. These include deductive learning in modern logic-based solvers and learning from counterexamples in abstraction refinement procedures. Modular verification is essential for scaling verification to large software, and concurrent program verification is critical due to the wide prevalence of multi-core hardware. &lt;br/&gt;&lt;br/&gt;This project develops techniques for learning inductive invariants for modular verification in a teacher-learner setting. The research objectives include studying suitable languages of invariants at procedure boundaries, identifying requirements for progress in learning, and developing effective techniques for guiding the learner. The project also addresses verification of concurrent programs, where learning over different event sequences is performed by dynamic and predictive analysis over program traces. The goal is to drive the learning toward unexplored program behaviors by automatically generating test inputs. The research objectives include studying new trace abstractions and coverage metrics for concurrent programs, and developing techniques for coverage-guided test generation. The methods for driving learning include directed testing to target specific scenarios relevant for learning. Beyond these specific contributions, the results will provide insights on applying machine learning techniques in combination with static and dynamic analysis for advancing program verification. The project includes development of educational material, tools, and benchmarks that will be made publicly available.</AbstractNarration>
<MinAmdLetterDate>06/24/2015</MinAmdLetterDate>
<MaxAmdLetterDate>06/24/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1525936</AwardID>
<Investigator>
<FirstName>Aarti</FirstName>
<LastName>Gupta</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Aarti Gupta</PI_FULL_NAME>
<EmailAddress>aartig@princeton.edu</EmailAddress>
<PI_PHON>6092583090</PI_PHON>
<NSF_ID>000689816</NSF_ID>
<StartDate>06/24/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Princeton University</Name>
<CityName>Princeton</CityName>
<ZipCode>085442020</ZipCode>
<PhoneNumber>6092583090</PhoneNumber>
<StreetAddress>Off. of Research &amp; Proj. Admin.</StreetAddress>
<StreetAddress2><![CDATA[P.O. Box 36]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<StateCode>NJ</StateCode>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>NJ12</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>002484665</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF PRINCETON UNIVERSITY, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>002484665</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Princeton University]]></Name>
<CityName>Princeton</CityName>
<StateCode>NJ</StateCode>
<ZipCode>085442020</ZipCode>
<StreetAddress><![CDATA[87 Prospect Avenue]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>New Jersey</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>12</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>NJ12</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~463706</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Program verification has broad applications, from ensuring safety of mission-critical software to improving program robustness and programmer productivity. Automatic program verification techniques employ various forms of learning -- in logic solvers, in algorithmic verification procedures, on program data. This project investigated the use of learning frameworks in different applications, where effective techniques are used to guide the learner to improve performance and scalability of verification.</p> <p>The first set of results are in learning <em>inductive invariants</em> for various applications. An important application is to prove whether a given program always terminates, or finding a situation where it does not terminate. The project contributed techniques for guided guessing of invariant candidates, which were then checked by a standard verifier. This is an instance of syntax-guided synthesis of invariants, where the learner proposed candidates using a grammar based on the syntax of the program. This significantly improved performance in comparison to existing tools. Another challenging application is in finding invariants to prove correctness of programs with multiple loops and arrays. A series of new techniques were proposed to enhance the grammars with data (from program executions) and other generalizations to find quantified invariants (whereas existing tools generate quantifier-free invariants). Another instance of a grammar-based approach was used for synthesis of new lemmas to automate induction on algebraic data types in a theorem-prover.</p> <p>The second set of results are in applying learning to improve <em>modular</em> verification, where verification is performed on smaller components instead of on a large monolithic model. One application is in generating procedure summaries to verify interprocedural recursive programs. Here, lemmas of a special form are learned that relate the summaries of procedures on call paths in the program. This allows handling of mutually recursive procedures (on which current methods perform poorly). Another set of applications targets relational programs, where copies of the same program or different programs are composed together. Here, new techniques were developed for lazy self-composition for security verification, and for leveraging symmetry in verifying k-copies of programs. New techniques were also developed for modular hardware verification, where a low-level implementation is verified against a high-level specification. A common practice is to manually provide environment invariants so that checking is done on only consistent states in the implementation. Instead, these environment environments were discovered automatically in a new approach that uses counterexamples to equivalence and grammars that leverage insights based on separation of control and data state in hardware designs.</p> <p>The third set of results are in applications in <em>security</em> <em>verification</em> and <em>network verification</em>, some of which involved concurrent and distributed programs. The project contributed a novel trace-based analysis approach for diagnosing malware attacks. This uses low-level memory access traces from normal runs and from malicious runs of the program to automatically identify the memory accesses that are specific to attacks, and then relates them to the program source code using a localization method. This combines the scalability of statistical methods for detecting malware attacks in traces with the diagnosis capabilities of static/dynamic program analysis.</p> <p>For verifying distributed network configurations, the first technique developed logic-based models of the configurations and the network topology. The novelty is that these logic models capture the stable states to which the network forwarding converges due to routing protocols such as OSPF, BGP, and static routes. Then queries on these models are solved by an SMT (Satisfiability Modulo Theory) solver to check a wide range of properties such as reachability between nodes, isolation among nodes, black holes, functional equivalence of routers, and fault-tolerance. To further improve the scalability of SMT-based verification, the second technique developed a new logic-based theory of network control plane equivalence, which is used to derive sound network abstractions that provide significant compression in size while preserving correctness of many properties of interest.</p> <p>Overall, the key outcomes of this project include twelve research papers published in leading conferences (CAV, VMCAI, FMCAD, CP, SIGCOMM). Five prototype tools have been made publicly available, along with new benchmark examples. The material was disseminated at conference presentations, two invited talks, and an in-depth tutorial at a winter school.</p> <p>Among the educational outcomes, the project provided partial support for the PhD research of two graduate students and mentorship for one post-doctoral fellow. The project also contributed to development of a new graduate-level course by the PI on automated software verification, which attracts graduate students (from the areas of programming languages, networks, computer architecture, systems, machine learning) as well as undergraduate students.</p> <p>&nbsp;</p><br> <p>            Last Modified: 11/29/2019<br>      Modified by: Aarti&nbsp;Gupta</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ Program verification has broad applications, from ensuring safety of mission-critical software to improving program robustness and programmer productivity. Automatic program verification techniques employ various forms of learning -- in logic solvers, in algorithmic verification procedures, on program data. This project investigated the use of learning frameworks in different applications, where effective techniques are used to guide the learner to improve performance and scalability of verification.  The first set of results are in learning inductive invariants for various applications. An important application is to prove whether a given program always terminates, or finding a situation where it does not terminate. The project contributed techniques for guided guessing of invariant candidates, which were then checked by a standard verifier. This is an instance of syntax-guided synthesis of invariants, where the learner proposed candidates using a grammar based on the syntax of the program. This significantly improved performance in comparison to existing tools. Another challenging application is in finding invariants to prove correctness of programs with multiple loops and arrays. A series of new techniques were proposed to enhance the grammars with data (from program executions) and other generalizations to find quantified invariants (whereas existing tools generate quantifier-free invariants). Another instance of a grammar-based approach was used for synthesis of new lemmas to automate induction on algebraic data types in a theorem-prover.  The second set of results are in applying learning to improve modular verification, where verification is performed on smaller components instead of on a large monolithic model. One application is in generating procedure summaries to verify interprocedural recursive programs. Here, lemmas of a special form are learned that relate the summaries of procedures on call paths in the program. This allows handling of mutually recursive procedures (on which current methods perform poorly). Another set of applications targets relational programs, where copies of the same program or different programs are composed together. Here, new techniques were developed for lazy self-composition for security verification, and for leveraging symmetry in verifying k-copies of programs. New techniques were also developed for modular hardware verification, where a low-level implementation is verified against a high-level specification. A common practice is to manually provide environment invariants so that checking is done on only consistent states in the implementation. Instead, these environment environments were discovered automatically in a new approach that uses counterexamples to equivalence and grammars that leverage insights based on separation of control and data state in hardware designs.  The third set of results are in applications in security verification and network verification, some of which involved concurrent and distributed programs. The project contributed a novel trace-based analysis approach for diagnosing malware attacks. This uses low-level memory access traces from normal runs and from malicious runs of the program to automatically identify the memory accesses that are specific to attacks, and then relates them to the program source code using a localization method. This combines the scalability of statistical methods for detecting malware attacks in traces with the diagnosis capabilities of static/dynamic program analysis.  For verifying distributed network configurations, the first technique developed logic-based models of the configurations and the network topology. The novelty is that these logic models capture the stable states to which the network forwarding converges due to routing protocols such as OSPF, BGP, and static routes. Then queries on these models are solved by an SMT (Satisfiability Modulo Theory) solver to check a wide range of properties such as reachability between nodes, isolation among nodes, black holes, functional equivalence of routers, and fault-tolerance. To further improve the scalability of SMT-based verification, the second technique developed a new logic-based theory of network control plane equivalence, which is used to derive sound network abstractions that provide significant compression in size while preserving correctness of many properties of interest.  Overall, the key outcomes of this project include twelve research papers published in leading conferences (CAV, VMCAI, FMCAD, CP, SIGCOMM). Five prototype tools have been made publicly available, along with new benchmark examples. The material was disseminated at conference presentations, two invited talks, and an in-depth tutorial at a winter school.  Among the educational outcomes, the project provided partial support for the PhD research of two graduate students and mentorship for one post-doctoral fellow. The project also contributed to development of a new graduate-level course by the PI on automated software verification, which attracts graduate students (from the areas of programming languages, networks, computer architecture, systems, machine learning) as well as undergraduate students.          Last Modified: 11/29/2019       Submitted by: Aarti Gupta]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
