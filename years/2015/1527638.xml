<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Xsmith, A Configurable Generator of Highly Effective Fuzz Testers</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>09/01/2015</AwardEffectiveDate>
<AwardExpirationDate>08/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>499998.00</AwardTotalIntnAmount>
<AwardAmount>499998</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Sol Greenspan</SignBlockName>
<PO_EMAI>sgreensp@nsf.gov</PO_EMAI>
<PO_PHON>7032927841</PO_PHON>
</ProgramOfficer>
<AbstractNarration>This project is developing new techniques for the creation of highly effective&lt;br/&gt;fuzz testers, also known as "fuzzers," for programming language compilers and&lt;br/&gt;interpreters.  Fuzz testing is an automatic and low-cost technique for finding&lt;br/&gt;defects in software systems.  A fuzzer randomly creates test inputs for a&lt;br/&gt;software system; a fuzzer is effective if it can continually create test cases&lt;br/&gt;that reveal defects throughout the system under test.  It is difficult to&lt;br/&gt;create effective fuzzers for programming language compilers and interpreters&lt;br/&gt;because these systems have highly structured inputs, but it is important that&lt;br/&gt;such fuzzers exist.  Programming language implementations are critical software&lt;br/&gt;infrastructure: defects in compilers and interpreters can potentially have&lt;br/&gt;great costs in terms of software correctness and reliability, human&lt;br/&gt;productivity, and computer security.  This project seeks to reduce the time and&lt;br/&gt;human effort needed to create sophisticated fuzzers for programming language&lt;br/&gt;implementations.  In so doing, this project is expected to advance the state of&lt;br/&gt;the art in random software testing, improve the quality of several programming&lt;br/&gt;language implementations selected for study, and produce new open-source&lt;br/&gt;software tools that programmers can use to develop new and more effective fuzz&lt;br/&gt;testers.&lt;br/&gt;&lt;br/&gt;The techniques developed by this project will be embodied in a new generator of&lt;br/&gt;fuzz testers, called Xsmith.  Xsmith will generate language fuzzers from&lt;br/&gt;specifications and thus reduce the time and effort required to create fuzzers.&lt;br/&gt;More importantly, Xsmith will inject sophisticated program-generation&lt;br/&gt;techniques into the language fuzzers it creates.  This project will investigate&lt;br/&gt;three techniques in particular.  This first is generation-time analysis,&lt;br/&gt;intended to allow Xsmith-derived fuzzers to create output that is both complex&lt;br/&gt;and meaningful.  The second is feature subsetting, intended to increase the&lt;br/&gt;likelihood that Xsmith-derived fuzzers will output bug-triggering test&lt;br/&gt;programs.  The third is iterative refinement, intended to further diversify the&lt;br/&gt;outputs from Xsmith-derived fuzzers.  The project participants will use Xsmith&lt;br/&gt;to create fuzz testers for a varied set of programming languages.  Where&lt;br/&gt;possible, the bug-finding power of Xsmith-derived fuzzers will be compared to&lt;br/&gt;that of existing fuzzers: quantitatively, in terms of the number of&lt;br/&gt;identifiably unique defects found within a fixed test-time budget, and&lt;br/&gt;qualitatively, in terms of the kinds of defects uncovered.  This evaluation&lt;br/&gt;will allow the investigators to assess the impact of the techniques embodied in&lt;br/&gt;Xsmith, both individually and collectively, over a range of programming&lt;br/&gt;language implementations.  Xsmith will be successful if it permits highly&lt;br/&gt;effective fuzz testers to be constructed with significantly less ad hoc code,&lt;br/&gt;and thus significantly less effort, than if they had been constructed from&lt;br/&gt;scratch.</AbstractNarration>
<MinAmdLetterDate>06/25/2015</MinAmdLetterDate>
<MaxAmdLetterDate>06/25/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1527638</AwardID>
<Investigator>
<FirstName>John</FirstName>
<LastName>Regehr</LastName>
<PI_MID_INIT>D</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>John D Regehr</PI_FULL_NAME>
<EmailAddress>regehr@cs.utah.edu</EmailAddress>
<PI_PHON>8015859086</PI_PHON>
<NSF_ID>000310362</NSF_ID>
<StartDate>06/25/2015</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Eric</FirstName>
<LastName>Eide</LastName>
<PI_MID_INIT>N</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Eric N Eide</PI_FULL_NAME>
<EmailAddress>eeide@cs.utah.edu</EmailAddress>
<PI_PHON>8015855512</PI_PHON>
<NSF_ID>000423472</NSF_ID>
<StartDate>06/25/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Utah</Name>
<CityName>SALT LAKE CITY</CityName>
<ZipCode>841128930</ZipCode>
<PhoneNumber>8015816903</PhoneNumber>
<StreetAddress>75 S 2000 E</StreetAddress>
<StreetAddress2><![CDATA[Second Floor]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Utah</StateName>
<StateCode>UT</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>UT02</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>009095365</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF UTAH, THE</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>009095365</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Utah]]></Name>
<CityName/>
<StateCode>UT</StateCode>
<ZipCode>841128930</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Utah</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>UT02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<ProgramReference>
<Code>9150</Code>
<Text>EXP PROG TO STIM COMP RES</Text>
</ProgramReference>
<Appropriation>
<Code>0115</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2015~499998</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This project developed new techniques for the creation of highly effective random testers, also known as "fuzzers," for programming language compilers and interpreters. An effective fuzzer is one that can continually create test cases that reveal defects throughout the compiler or interpreter being tested. While correct programming language implementations are essential to producing reliable and trustworthy software, it is difficult to create effective fuzzers for compilers and interpreters because these systems have highly structured inputs, and because programming language implementations apply many different and complex analyses to their inputs.<br /><br />The techniques developed by this project were embodied in a new generator of fuzz testers, called Xsmith. Xsmith generates language fuzzers from specifications and aims to reduce the time and effort required to create high-quality language fuzzers. Xsmith targets the creation of fuzzers that produce meaningful, well-formed programs: i.e., well-crafted test cases for a programming language implementation. A specification describes not only the syntax of a programming language but also its type system and other semantic rules that a fuzzer must follow while generating programs. Beyond implementing a specification, Xsmith injects sophisticated program-generation techniques into the language fuzzers it creates. This project investigated four techniques in particular. This first was generation-time analysis, intended to allow Xsmith-based fuzzers to create output that is both complex and meaningful. The second was feature subsetting, intended to increase the likelihood that Xsmith-derived fuzzers will output bug-triggering test programs. The third was iterative refinement, intended to further diversify the outputs from Xsmith-derived fuzzers. The fourth was parametric randomness, which allows an Xsmith-based fuzzer to be steered over time toward creating programs of interest.<br /><br />The project participants used Xsmith to create fuzzers for a varied set of programming languages including C, Lua, Python, Racket, Scheme, Verilog, and WebAssembly. The specifications of these fuzzers are short---generally, each is a few hundred lines of code---and they are much smaller than the implementations of comparable, hand-coded fuzzers that target these languages. Although these fuzzers are still evolving, they provide evidence that programmers can create a variety of language fuzzers atop Xsmith with modest effort.<br /><br />The intellectual merit of this project was found in its advancement of random software testing. Xsmith advances the state of the art by easing the creation of fuzzers that reliably produce semantically meaningful test cases: i.e., test programs that are syntactically and semantically well-formed, exercising language features while avoiding type errors and undefined behaviors. Xsmith shows how the basis for such fuzzers can be implemented in a language-agnostic manner. The knowledge gained will inform and propel the creation and use of fuzz testers for many language implementations. Xsmith-based fuzzers can be used both for "blackbox" testing and "greybox" (coverage-directed) testing of programming language implementations.<br /><br />The broader impacts of this project were realized through open-source software and educated students. Xsmith, its related libraries, and the Xsmith-based fuzzers were (are continue to be) distributed to the public as open-source software with substantial documentation. Programmers can use Xsmith to develop new fuzzers for programming language implementations. Beyond the end of the project, Xsmith will be successful if it permits highly effective fuzz testers to be constructed with significantly less ad hoc code, and thus significantly less effort, than if they had been constructed from scratch. Three graduate students and one undergraduate student were trained through their participation in the project. Xsmith is a primary component of one PhD dissertation, and the WebAssembly language fuzzer is the focus of one MS thesis. Both were in progress as of the project's end date.</p><br> <p>            Last Modified: 07/30/2021<br>      Modified by: Eric&nbsp;N&nbsp;Eide</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This project developed new techniques for the creation of highly effective random testers, also known as "fuzzers," for programming language compilers and interpreters. An effective fuzzer is one that can continually create test cases that reveal defects throughout the compiler or interpreter being tested. While correct programming language implementations are essential to producing reliable and trustworthy software, it is difficult to create effective fuzzers for compilers and interpreters because these systems have highly structured inputs, and because programming language implementations apply many different and complex analyses to their inputs.  The techniques developed by this project were embodied in a new generator of fuzz testers, called Xsmith. Xsmith generates language fuzzers from specifications and aims to reduce the time and effort required to create high-quality language fuzzers. Xsmith targets the creation of fuzzers that produce meaningful, well-formed programs: i.e., well-crafted test cases for a programming language implementation. A specification describes not only the syntax of a programming language but also its type system and other semantic rules that a fuzzer must follow while generating programs. Beyond implementing a specification, Xsmith injects sophisticated program-generation techniques into the language fuzzers it creates. This project investigated four techniques in particular. This first was generation-time analysis, intended to allow Xsmith-based fuzzers to create output that is both complex and meaningful. The second was feature subsetting, intended to increase the likelihood that Xsmith-derived fuzzers will output bug-triggering test programs. The third was iterative refinement, intended to further diversify the outputs from Xsmith-derived fuzzers. The fourth was parametric randomness, which allows an Xsmith-based fuzzer to be steered over time toward creating programs of interest.  The project participants used Xsmith to create fuzzers for a varied set of programming languages including C, Lua, Python, Racket, Scheme, Verilog, and WebAssembly. The specifications of these fuzzers are short---generally, each is a few hundred lines of code---and they are much smaller than the implementations of comparable, hand-coded fuzzers that target these languages. Although these fuzzers are still evolving, they provide evidence that programmers can create a variety of language fuzzers atop Xsmith with modest effort.  The intellectual merit of this project was found in its advancement of random software testing. Xsmith advances the state of the art by easing the creation of fuzzers that reliably produce semantically meaningful test cases: i.e., test programs that are syntactically and semantically well-formed, exercising language features while avoiding type errors and undefined behaviors. Xsmith shows how the basis for such fuzzers can be implemented in a language-agnostic manner. The knowledge gained will inform and propel the creation and use of fuzz testers for many language implementations. Xsmith-based fuzzers can be used both for "blackbox" testing and "greybox" (coverage-directed) testing of programming language implementations.  The broader impacts of this project were realized through open-source software and educated students. Xsmith, its related libraries, and the Xsmith-based fuzzers were (are continue to be) distributed to the public as open-source software with substantial documentation. Programmers can use Xsmith to develop new fuzzers for programming language implementations. Beyond the end of the project, Xsmith will be successful if it permits highly effective fuzz testers to be constructed with significantly less ad hoc code, and thus significantly less effort, than if they had been constructed from scratch. Three graduate students and one undergraduate student were trained through their participation in the project. Xsmith is a primary component of one PhD dissertation, and the WebAssembly language fuzzer is the focus of one MS thesis. Both were in progress as of the project's end date.       Last Modified: 07/30/2021       Submitted by: Eric N Eide]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
