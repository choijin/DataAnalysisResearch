<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Medium: Self-certifying Compilation and its Applications</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>08/01/2016</AwardEffectiveDate>
<AwardExpirationDate>07/31/2020</AwardExpirationDate>
<AwardTotalIntnAmount>854500.00</AwardTotalIntnAmount>
<AwardAmount>854500</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Nina Amla</SignBlockName>
<PO_EMAI>namla@nsf.gov</PO_EMAI>
<PO_PHON>7032927991</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Software is embedded into our daily activities. Ensuring that the software is trustworthy - does what is intended - and secure - is not vulnerable to attack - is a prime concern. Much attention has been devoted to establishing the correctness of high-level programs. This project is focused on the important task of ensuring that the, often complex and opaque, transformations carried out by a compiler do not degrade the trustworthiness and security guarantees of its input program.&lt;br/&gt;&lt;br/&gt;The key innovation pursued in this project is self-certification which guarantees the correctness and security of compilation. A self-certifying compiler creates a tangible, independently-checkable proof, justifying the correctness of the compilation run. By linking in information from external analysis tools certificates can also aid in obtaining better machine code. In particular,  they allow for automatic insertion of defensive measures, which protect the program from common security attacks. This work builds on existing theoretical ideas and compiler implementations, while extending them in new directions. The self-certifying compiler is implemented in the popular LLVM framework, making it suitable for immediate adoption by programmers, and its security benefits available to end users in a transparent fashion. Provable program correctness is a true "Grand Challenge" for computing. By developing both theory and implementation of a self-certifying compiler, this project is taking a significant step forward in meeting that challenge.</AbstractNarration>
<MinAmdLetterDate>07/28/2016</MinAmdLetterDate>
<MaxAmdLetterDate>07/28/2016</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1564296</AwardID>
<Investigator>
<FirstName>Lenore</FirstName>
<LastName>Zuck</LastName>
<PI_MID_INIT>D</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Lenore D Zuck</PI_FULL_NAME>
<EmailAddress>lenore@cs.uic.edu</EmailAddress>
<PI_PHON>3123551339</PI_PHON>
<NSF_ID>000118794</NSF_ID>
<StartDate>07/28/2016</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>Aravinda</FirstName>
<LastName>Sistla</LastName>
<PI_MID_INIT>P</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Aravinda P Sistla</PI_FULL_NAME>
<EmailAddress>sistla@cs.uic.edu</EmailAddress>
<PI_PHON>3129968779</PI_PHON>
<NSF_ID>000102528</NSF_ID>
<StartDate>07/28/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Investigator>
<FirstName>V. N.</FirstName>
<LastName>Venkatakrishnan</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>V. N. Venkatakrishnan</PI_FULL_NAME>
<EmailAddress>venkat@uic.edu</EmailAddress>
<PI_PHON>3129969406</PI_PHON>
<NSF_ID>000150699</NSF_ID>
<StartDate>07/28/2016</StartDate>
<EndDate/>
<RoleCode>Co-Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>University of Illinois at Chicago</Name>
<CityName>Chicago</CityName>
<ZipCode>606124305</ZipCode>
<PhoneNumber>3129962862</PhoneNumber>
<StreetAddress>809 S. Marshfield Avenue</StreetAddress>
<StreetAddress2><![CDATA[MB 502, M/C 551]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<StateCode>IL</StateCode>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IL07</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>098987217</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF ILLINOIS</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>041544081</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Illinois at Chicago]]></Name>
<CityName>Chicago</CityName>
<StateCode>IL</StateCode>
<ZipCode>606124305</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Illinois</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>07</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IL07</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7924</Code>
<Text>MEDIUM PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>8206</Code>
<Text>Formal Methods and Verification</Text>
</ProgramReference>
<Appropriation>
<Code>0116</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2016~854500</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>During this project we enhanced the theory of &nbsp;verifiable certificates (also called witnesses) with which to establish the correctness of compiler optimizations.&nbsp;</p> <p>We began with the approach of "semantic equivalence," that is, of showing that the code before and after compilation has equivalent behavior. The witnesses generated by a self-certifying compiler considerably simplify such proofs, by letting them to be carried out in small digestable chunks. We enhanced this method to use "syntactic" reasoning that is akin to rewriting or syntactic equality under renaming of variables. As far as we know, this is the first comprehensive approach to translation validation that combines the two, almost opposing, techniques of syntactic equality and semantic equivalence.&nbsp;</p> <p>We implemented this combined approach to certify LLVM's interprocedural optimizations, obtaining significant speedups in the certification process. Furthermore, we have also implemented a self-certification infrastructure for WebAssembly, a new intermediate language that is supported by all major web browsers.&nbsp;&nbsp;</p> <p>Preservation of semantics does not imply preservation of security. In fact, some known optimizations are semantic preserveing while making the code more vulnerable, as in exposing a secret for longer than necessary. We extended self-certification to security, showing how custom security certificates could be generated for a large class of useful security properties, guaranteeing their preservation across a chain of optimizations.&nbsp;</p><br> <p>            Last Modified: 08/03/2020<br>      Modified by: Lenore&nbsp;D&nbsp;Zuck</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ During this project we enhanced the theory of  verifiable certificates (also called witnesses) with which to establish the correctness of compiler optimizations.   We began with the approach of "semantic equivalence," that is, of showing that the code before and after compilation has equivalent behavior. The witnesses generated by a self-certifying compiler considerably simplify such proofs, by letting them to be carried out in small digestable chunks. We enhanced this method to use "syntactic" reasoning that is akin to rewriting or syntactic equality under renaming of variables. As far as we know, this is the first comprehensive approach to translation validation that combines the two, almost opposing, techniques of syntactic equality and semantic equivalence.   We implemented this combined approach to certify LLVM's interprocedural optimizations, obtaining significant speedups in the certification process. Furthermore, we have also implemented a self-certification infrastructure for WebAssembly, a new intermediate language that is supported by all major web browsers.    Preservation of semantics does not imply preservation of security. In fact, some known optimizations are semantic preserveing while making the code more vulnerable, as in exposing a secret for longer than necessary. We extended self-certification to security, showing how custom security certificates could be generated for a large class of useful security properties, guaranteeing their preservation across a chain of optimizations.        Last Modified: 08/03/2020       Submitted by: Lenore D Zuck]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
