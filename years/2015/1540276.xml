<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle>SHF: Small: Behavioral Software Contract Verification</AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>01/01/2015</AwardEffectiveDate>
<AwardExpirationDate>08/31/2017</AwardExpirationDate>
<AwardTotalIntnAmount>342229.00</AwardTotalIntnAmount>
<AwardAmount>342229</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>It is important for many critical software components to be correct and reliable, however verifying that software meets such requirements is difficult, expensive, and error-prone.  One approach is to use software contracts as a means to specify and monitor the obligations and guarantees of software components.  When the agreements of such contracts are not met during the operation of a program, the program stops and signals a violation and indicates the faulty component. Software contracts have been very important for high-assurance software, since they identify faulty program components, but they offer no guarantees that a component will not fail.  The goal of this research project is to investigate approaches to ahead-of-time software verification that can prove the absence of contract failures, thus giving a high level of confidence in the correctness and reliability of critical software components.  The research will contribute a new understanding of the interplay between program verification, software contracts, and modern programming languages.  Additionally, it will result in the development of tools for verifying software components with contracts.  It is expected that by verifying software contracts ahead-of-time, the overhead of monitoring contract agreements during program operation can be eliminated, which will encourage programmers to use contracts far more extensively than they currently do.  Such tools can dramatically reduce the difficulty and cost of developing high-assurance software.&lt;br/&gt;&lt;br/&gt;There are two paramount technical obstacles that must be overcome to achieve the goals of this project: (1) the expressivity of contracts, while crucial for the construction of reliable components, thwarts static reasoning about programs and incurs significant run-time monitoring costs, (2) the expressivity of higher-order programming languages, a mainstay of modern industrial software construction, thwarts static reasoning about contracts, despite the availability of mature automated tools and techniques.  This research project rectifies the situation by providing foundations for modular and compositional automated reasoning about behavioral contracts in a higher-order language.  Specifically, the project will provide: (1) a foundational theory in terms of a semantics for reasoning about components via their contracts, which enables automated component-based contract verification; (2) an interactive contract verification environment for exploring, testing, and refining programs and contracts; and (3) an evaluation of our approach and tools in the context of the Racket programming language implementation and standard library, which contains extensive use of contracts.</AbstractNarration>
<MinAmdLetterDate>04/02/2015</MinAmdLetterDate>
<MaxAmdLetterDate>04/02/2015</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>0</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>1540276</AwardID>
<Investigator>
<FirstName>Sam</FirstName>
<LastName>Tobin-Hochstadt</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Sam Tobin-Hochstadt</PI_FULL_NAME>
<EmailAddress>samth@cs.indiana.edu</EmailAddress>
<PI_PHON>8128563240</PI_PHON>
<NSF_ID>000611033</NSF_ID>
<StartDate>04/02/2015</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name>Indiana University</Name>
<CityName>Bloomington</CityName>
<ZipCode>474013654</ZipCode>
<PhoneNumber>3172783473</PhoneNumber>
<StreetAddress>509 E 3RD ST</StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<StateCode>IN</StateCode>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IN09</CONGRESS_DISTRICT_ORG>
<ORG_DUNS_NUM>006046700</ORG_DUNS_NUM>
<ORG_LGL_BUS_NAME>TRUSTEES OF INDIANA UNIVERSITY</ORG_LGL_BUS_NAME>
<ORG_PRNT_DUNS_NUM>006046700</ORG_PRNT_DUNS_NUM>
</Institution>
<Performance_Institution>
<Name><![CDATA[Indiana University]]></Name>
<CityName/>
<StateCode>IN</StateCode>
<ZipCode>474013654</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Indiana</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>09</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IN09</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>7798</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<ProgramReference>
<Code>7944</Code>
<Text>SOFTWARE ENG &amp; FORMAL METHODS</Text>
</ProgramReference>
<Appropriation>
<Code>0112</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<FUND_OBLG>2012~342228</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>This project focused on verifying programs written in existing dynamic<br />languages using tools from static analysis, satisfiyability checking,<br />and contract systems. The goal was to bring together these different<br />technologies to achieve a signficant advance in ability of program<br />verifiers to work on existing dynamically-typed programs.<br /><br />The project achieved its goals in several ways. First, it supported<br />the development of a new tool able to automatically verify contracts<br />in the Racket programming language, building upon a new approach to<br />symbolic execution. Symbolic execution is an existing technology not<br />previously applicable to the kinds of languages and specifications<br />considered by this project, but which new techniques were developed to<br />enable in this context. The tool also makes use of powerful automatic<br />theorem provers such as Z3, as anticipated in the project plan. Work<br />on this project has appeared in ICFP, PLDI, JFP, and POPL.<br /><br />The project also supported the integration between type systems for<br />dynamic languages, such as Typed Racket, and advanced theorem provers<br />such as Z3. This integration not only extended the capabilities of<br />type systems as tools for programmers, but led to a new understanding<br />of the fundamentals of such type systems. This work was published in<br />PLDI, and has led to new features shipping in Racket.<br /><br />The work also supported graduate student and postdoctoral researcher<br />training at Indiana University and Northeastern University.</p><br> <p>            Last Modified: 12/03/2017<br>      Modified by: Sam&nbsp;Tobin-Hochstadt</p> </div> <div class="porSideCol"></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[ This project focused on verifying programs written in existing dynamic languages using tools from static analysis, satisfiyability checking, and contract systems. The goal was to bring together these different technologies to achieve a signficant advance in ability of program verifiers to work on existing dynamically-typed programs.  The project achieved its goals in several ways. First, it supported the development of a new tool able to automatically verify contracts in the Racket programming language, building upon a new approach to symbolic execution. Symbolic execution is an existing technology not previously applicable to the kinds of languages and specifications considered by this project, but which new techniques were developed to enable in this context. The tool also makes use of powerful automatic theorem provers such as Z3, as anticipated in the project plan. Work on this project has appeared in ICFP, PLDI, JFP, and POPL.  The project also supported the integration between type systems for dynamic languages, such as Typed Racket, and advanced theorem provers such as Z3. This integration not only extended the capabilities of type systems as tools for programmers, but led to a new understanding of the fundamentals of such type systems. This work was published in PLDI, and has led to new features shipping in Racket.  The work also supported graduate student and postdoctoral researcher training at Indiana University and Northeastern University.       Last Modified: 12/03/2017       Submitted by: Sam Tobin-Hochstadt]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
